<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¯è§†åŒ–å†³ç­–æ ‘æ„å»ºå™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            display: flex;
            height: 100vh;
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }

        .sidebar {
            width: 300px;
            background: #f8fafc;
            border-right: 1px solid #e2e8f0;
            padding: 20px;
            overflow-y: auto;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .right-panel {
            width: 350px;
            background: #f8fafc;
            border-left: 1px solid #e2e8f0;
            padding: 20px;
            overflow-y: auto;
        }

        .header {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .canvas-area {
            flex: 1;
            background: white;
            border-radius: 8px;
            position: relative;
            overflow: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-height: 500px;
        }

        .section-title {
            font-size: 16px;
            font-weight: 600;
            color: #1e40af;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            color: #374151;
            font-weight: 500;
        }

        .form-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
        }

        .form-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .form-textarea {
            min-height: 80px;
            resize: vertical;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
        }

        .btn-success {
            background: #22c55e;
            color: white;
        }

        .btn-success:hover {
            background: #16a34a;
        }

        .btn-warning {
            background: #f59e0b;
            color: white;
        }

        .btn-warning:hover {
            background: #d97706;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .canvas {
            width: 100%;
            height: 100%;
            position: relative;
            padding: 20px;
            background: #fafbfc;
        }

        .canvas svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        .branch-line {
            stroke: #3b82f6;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }

        .branch-line.selected {
            stroke: #ef4444;
            stroke-width: 3;
        }

        .node {
            position: absolute;
            min-width: 120px;
            min-height: 60px;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 10px;
            cursor: move;
            user-select: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 10;
        }

        .node:hover {
            border-color: #3b82f6;
        }

        .node.selected {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .node.symptom { border-left: 4px solid #f59e0b; }
        .node.condition { border-left: 4px solid #0ea5e9; }
        .node.diagnosis { border-left: 4px solid #22c55e; }
        .node.treatment { border-left: 4px solid #ec4899; }
        .node.formula { border-left: 4px solid #a855f7; }

        .node-title {
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .node-content {
            font-size: 11px;
            color: #6b7280;
            word-break: break-word;
        }

        /* ç›¸å…³ç—‡çŠ¶æ ·å¼ */
        .related-symptoms {
            margin-top: 8px;
            padding: 6px 8px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 4px;
            border-left: 3px solid #3b82f6;
        }

        .symptoms-label {
            font-size: 10px;
            color: #3b82f6;
            font-weight: 500;
            margin-bottom: 3px;
        }

        .symptoms-list {
            font-size: 10px;
            color: #1e40af;
            line-height: 1.3;
        }

        .node-desc {
            margin-top: 5px;
            font-size: 10px;
            color: #9ca3af;
            font-style: italic;
        }

        .empty-canvas {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #9ca3af;
            text-align: center;
        }

        .loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-content {
            text-align: center;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f4f6;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .result-panel {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .result-title {
            font-weight: 600;
            color: #1e40af;
            margin-bottom: 10px;
        }

        .auth-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, #3b82f6, #1e40af);
            color: white;
            padding: 10px 20px;
            font-size: 12px;
            z-index: 10000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .container.with-auth {
            margin-top: 45px;
            height: calc(100vh - 45px);
        }

        .suggestion-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .suggestion-item:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
        }

        .suggestion-content {
            font-weight: 500;
            color: #1e40af;
            margin-bottom: 4px;
        }

        .suggestion-desc {
            font-size: 12px;
            color: #6b7280;
        }

        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            min-width: 150px;
        }

        .context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #f1f5f9;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:last-child {
            border-bottom: none;
        }

        .context-menu-item:hover {
            background: #f8fafc;
        }

        .context-menu-item.danger {
            color: #ef4444;
        }

        .context-menu-item.danger:hover {
            background: #fef2f2;
        }

        .delete-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 12px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }

        .node:hover .delete-btn {
            display: flex;
        }

        .formula-analysis-panel {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .herb-item {
            display: inline-block;
            background: white;
            border: 1px solid #0ea5e9;
            border-radius: 15px;
            padding: 4px 8px;
            margin: 2px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .herb-item:hover {
            background: #0ea5e9;
            color: white;
        }

        .apply-formula-btn {
            background: #22c55e;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 12px;
            cursor: pointer;
            margin-top: 10px;
        }

        .apply-formula-btn:hover {
            background: #16a34a;
        }

        .auto-analysis-panel {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .pathway-step {
            background: white;
            border-left: 4px solid #3b82f6;
            padding: 10px;
            margin: 8px 0;
            border-radius: 0 6px 6px 0;
        }

        .add-pathway-btn {
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 11px;
            cursor: pointer;
            margin-left: 10px;
        }
        
        /* AIæ¨¡å¼åˆ‡æ¢å¼€å…³æ ·å¼ */
        .toggle-switch {
            position: relative;
            display: inline-block;
        }
        
        .toggle-switch input[type="checkbox"] {
            display: none;
        }
        
        .toggle-label {
            display: block;
            width: 50px;
            height: 24px;
            background-color: #cbd5e0;
            border-radius: 12px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .toggle-switch input[type="checkbox"]:checked + .toggle-label {
            background-color: #3b82f6;
        }
        
        .toggle-switch input[type="checkbox"]:checked + .toggle-label .toggle-slider {
            transform: translateX(26px);
        }
        
        /* æ•°æ®æ¥æºæ ‡è¯†æ ·å¼ */
        .data-source-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .data-source-ai {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .data-source-template {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        
        .data-source-fallback {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            color: #8b4513;
        }
        
        /* ç”ŸæˆçŠ¶æ€æŒ‡ç¤ºå™¨ */
        .generation-status {
            margin-top: 10px;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            display: none;
        }
        
        .generation-status.ai-mode {
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            color: #1e40af;
        }
        
        .generation-status.template-mode {
            background: #fef3f2;
            border: 1px solid #fecaca;
            color: #dc2626;
        }
    </style>
</head>
<body>
    <div id="authBar"></div>
    <div class="container" id="mainContainer">
        <!-- å·¦ä¾§å·¥å…·æ  -->
        <div class="sidebar">
            <!-- åŸºæœ¬ä¿¡æ¯ -->
            <div class="section-title">ğŸ¥ åŸºæœ¬ä¿¡æ¯</div>
            <div class="form-group">
                <label class="form-label">ç–¾ç—…åç§°</label>
                <input type="text" class="form-input" id="diseaseName" placeholder="å¦‚ï¼šå¤±çœ ã€èƒƒç—›ã€å¤´ç—›">
            </div>
            <div class="form-group">
                <label class="form-label">è¯Šç–—æ€è·¯</label>
                <textarea class="form-input form-textarea" id="doctorThought" placeholder="ç®€è¿°æ‚¨çš„è¯Šç–—æ€è·¯..."></textarea>
            </div>

            <!-- AIåŠŸèƒ½ -->
            <div class="section-title">ğŸ¤– æ™ºèƒ½åŠŸèƒ½</div>
            
            <!-- AIæ¨¡å¼é€‰æ‹© -->
            <div class="ai-mode-selector" style="margin-bottom: 15px; padding: 12px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <span style="font-weight: 500; color: #374151;">ç”Ÿæˆæ¨¡å¼:</span>
                    <div class="toggle-switch">
                        <input type="checkbox" id="aiModeToggle" checked>
                        <label for="aiModeToggle" class="toggle-label">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <span id="aiModeText" style="font-size: 12px; color: #6b7280;">AIæ™ºèƒ½æ¨¡å¼</span>
                </div>
                <div id="aiStatusInfo" style="font-size: 11px; color: #9ca3af;">
                    <span id="aiStatusIndicator">â³ æ£€æŸ¥AIçŠ¶æ€ä¸­...</span>
                </div>
            </div>
            
            <div class="btn-group">
                <button class="btn btn-primary" id="generateBtn">
                    <span id="generateBtnIcon">ğŸ¤–</span> 
                    <span id="generateBtnText">æ™ºèƒ½ç”Ÿæˆå†³ç­–æ ‘</span>
                </button>
                <button class="btn btn-warning" id="analyzeBtn">ğŸ§  ç†è®ºåˆ†æ</button>
                <button class="btn btn-success" id="suggestBtn">ğŸ’¡ é—æ¼æ£€æµ‹</button>
            </div>
            <div class="btn-group">
                <button class="btn btn-warning" id="symptomDetectBtn" style="background: #f59e0b;">ğŸ” ç—‡çŠ¶é—æ¼æ£€æµ‹</button>
                <button class="btn btn-primary" id="formulaAnalyzeBtn" style="background: #a855f7;">ğŸ’Š æ–¹å‰‚AIåˆ†æ</button>
            </div>
            <div class="btn-group">
                <button class="btn btn-success" id="autoPathwayBtn" style="background: #059669;">ğŸ¤– æ™ºèƒ½è¯Šç–—è·¯å¾„</button>
                <button class="btn btn-warning" id="syndromeAnalyzeBtn" style="background: #d97706;">ğŸ¯ è¯å‹æ™ºèƒ½è¯†åˆ«</button>
            </div>

            <!-- å¿«é€Ÿæ“ä½œ -->
            <div class="section-title">âš¡ å¿«é€Ÿæ“ä½œ</div>
            <div class="btn-group">
                <button class="btn btn-primary" id="addPathBtn">ğŸ“‹ æ ‡å‡†è·¯å¾„</button>
                <button class="btn btn-success" id="arrangeBtn">ğŸ“ è‡ªåŠ¨æ’åˆ—</button>
                <button class="btn btn-danger" id="clearBtn">ğŸ—‘ï¸ æ¸…ç©ºç”»å¸ƒ</button>
            </div>

            <!-- ä¿å­˜å¯¼å‡º -->
            <div class="section-title">ğŸ’¾ ä¿å­˜å¯¼å‡º</div>
            <div class="btn-group">
                <button class="btn btn-success" id="saveBtn">ğŸ’¾ ä¿å­˜å†³ç­–æ ‘</button>
                <button class="btn btn-primary" id="exportBtn">ğŸ“„ å¯¼å‡ºJSON</button>
            </div>

            <!-- é€‰ä¸­èŠ‚ç‚¹ä¿¡æ¯ -->
            <div id="selectedNodeInfo" style="display: none;">
                <div class="section-title">ğŸ“ é€‰ä¸­èŠ‚ç‚¹</div>
                <div class="result-panel">
                    <div id="nodeInfoContent"></div>
                </div>
            </div>
        </div>

        <!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
        <div class="main-content">
            <div class="header">
                <h1 style="color: #1e40af; margin-bottom: 10px;">ğŸŒ³ å¯è§†åŒ–å†³ç­–æ ‘æ„å»ºå™¨</h1>
                <p style="color: #6b7280; font-size: 14px;">æ„å»ºä¸­åŒ»æ™ºèƒ½è¯Šç–—å†³ç­–æ ‘ï¼Œæ”¯æŒAIç”Ÿæˆå’Œå¯è§†åŒ–ç¼–è¾‘</p>
            </div>

            <!-- ç”ŸæˆçŠ¶æ€å’Œæ•°æ®æ¥æºæ˜¾ç¤º -->
            <div id="generationStatusPanel" class="generation-status" style="display: none;">
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span id="dataSourceBadge" class="data-source-badge data-source-template">Template</span>
                        <span id="generationInfo">å·²ä½¿ç”¨æ ‡å‡†æ¨¡æ¿ç”Ÿæˆ</span>
                    </div>
                    <div style="font-size: 10px; color: #6b7280;">
                        <span id="generationTime">å³æ—¶</span>
                    </div>
                </div>
            </div>

            <div class="canvas-area">
                <div class="canvas" id="canvas">
                    <svg id="branchSvg">
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#3b82f6" />
                            </marker>
                        </defs>
                    </svg>
                    <div class="empty-canvas" id="emptyHint">
                        <div style="font-size: 48px; margin-bottom: 20px;">ğŸŒ³</div>
                        <h3>å¼€å§‹æ„å»ºæ‚¨çš„å†³ç­–æ ‘</h3>
                        <p style="margin: 10px 0;">è¾“å…¥ç–¾ç—…åç§°ï¼Œç„¶åç‚¹å‡»"AIç”Ÿæˆå†³ç­–æ ‘"</p>
                        <p style="color: #9ca3af; font-size: 12px;">æˆ–ç‚¹å‡»"æ ‡å‡†è·¯å¾„"å¿«é€Ÿå¼€å§‹</p>
                    </div>
                </div>
                <div class="loading" id="loading" style="display: none;">
                    <div class="loading-content">
                        <div class="spinner"></div>
                        <div id="loadingText">åŠ è½½ä¸­...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- å³ä¾§åˆ†æç»“æœé¢æ¿ -->
        <div class="right-panel">
            <!-- ä¸­åŒ»è¾¨è¯æ€ç»´æŒ‡å¯¼ -->
            <div class="section-title">ğŸ¯ ä¸­åŒ»è¾¨è¯æ€ç»´æŒ‡å¯¼</div>
            <div class="tcm-guide-panel" style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                <h4 style="color: #0284c7; margin-bottom: 10px;">æ ‡å‡†è¯Šç–—æµç¨‹</h4>
                <ol style="font-size: 12px; color: #374151; line-height: 1.6; margin: 0; padding-left: 20px;">
                    <li><strong>ç—…ç§è¯†åˆ«</strong>: ç¡®å®šç–¾ç—…çš„ä¸­åŒ»ç—…å</li>
                    <li><strong>å››è¯Šæ”¶é›†</strong>: æœ›é—»é—®åˆ‡ï¼Œæ”¶é›†å…¨é¢ä¿¡æ¯</li>
                    <li><strong>ä¸»è¦ç—‡çŠ¶</strong>: ä¸»ç—‡ã€å…¼ç—‡çš„å½’çº³åˆ†æ</li>
                    <li><strong>ç—…å› ç—…æœº</strong>: åˆ†æå‘ç—…åŸå› å’Œç—…ç†æœºåˆ¶</li>
                    <li><strong>è¯å€™åˆ¤æ–­</strong>: è¾¨è¯åˆ†å‹ï¼ˆæ”¯æŒå¤šç§è¯å‹ï¼‰</li>
                    <li><strong>æ²»åˆ™æ²»æ³•</strong>: ç¡®å®šæ²»ç–—åŸåˆ™å’Œæ–¹æ³•</li>
                    <li><strong>æ–¹å‰‚å¤„æ–¹</strong>: é€‰æ–¹ç”¨è¯ï¼Œå›è‡£ä½ä½¿</li>
                    <li><strong>éšç—‡åŠ å‡</strong>: æ ¹æ®å…·ä½“ç—‡çŠ¶è°ƒæ•´ç”¨è¯</li>
                    <li><strong>é¢„åè°ƒç†</strong>: å…»ç”Ÿå»ºè®®å’Œæ³¨æ„äº‹é¡¹</li>
                </ol>
                
                <div style="margin-top: 15px; padding: 10px; background: #fef3c7; border-radius: 6px;">
                    <h5 style="color: #f59e0b; margin-bottom: 5px;">ğŸ’¡ æ„å»ºæŠ€å·§</h5>
                    <ul style="font-size: 11px; color: #78716c; margin: 0; padding-left: 20px;">
                        <li>å³é”®ç‚¹å‡»èŠ‚ç‚¹å¯æ·»åŠ åˆ†æ”¯æˆ–ç¼–è¾‘</li>
                        <li>åŒå‡»èŠ‚ç‚¹å†…å®¹å¯ç›´æ¥ç¼–è¾‘</li>
                        <li>è¯å€™åˆ¤æ–­æ”¯æŒå¤šåˆ†æ”¯ï¼ˆä¸åŒè¯å‹ï¼‰</li>
                        <li>ä½¿ç”¨AIåŠŸèƒ½å¯å¿«é€Ÿç”Ÿæˆæ¡†æ¶</li>
                        <li>ç‚¹å‡»"è‡ªåŠ¨æ’åˆ—"ä¼˜åŒ–å¸ƒå±€</li>
                    </ul>
                </div>
                
                <div style="margin-top: 10px; text-align: center;">
                    <button onclick="showTCMExample()" style="background: #0ea5e9; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 11px; cursor: pointer;">
                        æŸ¥çœ‹ç¤ºä¾‹å†³ç­–æ ‘
                    </button>
                </div>
            </div>
            
            <div class="section-title">ğŸ“Š åˆ†æç»“æœ</div>
            <div id="analysisResults"></div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let nodes = [];
        let selectedNode = null;
        let nodeCounter = 1;
        let isAuthenticated = false;
        let currentUser = null;
        let connections = [];
        let symptomClusters = new Map(); // ç—‡çŠ¶ç¾¤å­˜å‚¨
        
        // ç—‡çŠ¶ç¾¤æ•°æ®ç»“æ„
        const SYMPTOM_CLUSTER_TEMPLATES = {
            'å¤±çœ ç¾¤': {
                mainDisease: 'å¤±çœ ',
                icon: 'ğŸ˜´',
                color: '#8b5cf6',
                relatedSymptoms: ['æ—©é†’', 'å¤šæ¢¦', 'å…¥ç¡å›°éš¾', 'ç¡çœ æµ…', 'æ˜“æƒŠé†’'],
                accompanyingSymptoms: ['å¿ƒçƒ¦', 'å¥å¿˜', 'å¤´æ™•', 'ç–²ä¹']
            },
            'èƒƒç—›ç¾¤': {
                mainDisease: 'èƒƒç—›',
                icon: 'ğŸ¤¢',
                color: '#f59e0b',
                relatedSymptoms: ['èƒƒèƒ€', 'åé…¸', 'å—³æ°”', 'æ¶å¿ƒ', 'èƒƒè„ç–¼ç—›'],
                accompanyingSymptoms: ['é£Ÿæ¬²ä¸æŒ¯', 'ä¹åŠ›', 'è…¹èƒ€', 'ä¾¿ç§˜']
            }
        };

        // è¾…åŠ©å‡½æ•°ï¼šè·å–ç–¾ç—…åç§°
        function getCurrentDiseaseName() {
            const value = document.getElementById('diseaseName')?.value?.trim() || '';
            // æ¼”ç¤ºï¼šæ·»åŠ è¾“å…¥éªŒè¯
            if (value && value.length < 2) {
                console.warn('ç–¾ç—…åç§°è¿‡çŸ­ï¼Œå»ºè®®è‡³å°‘2ä¸ªå­—ç¬¦');
                return '';
            }
            return value;
        }

        // å…¨å±€AIçŠ¶æ€å˜é‡
        let aiStatus = {
            ai_enabled: false,
            available: false,
            model: 'unknown',
            features: {
                decision_tree_generation: false,
                theory_analysis: false,
                hybrid_mode: false
            }
        };
        
        // ç”¨æˆ·æ¨¡å¼åå¥½
        let userPreferences = {
            aiModePreferred: true,
            complexityLevel: 'standard'
        };

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ğŸš€ é¡µé¢åˆå§‹åŒ–å¼€å§‹...');
            
            // åˆå§‹åŒ–AIçŠ¶æ€æ£€æŸ¥
            initializeAIStatus();
            
            // åˆå§‹åŒ–æ¨¡å¼åˆ‡æ¢
            initializeModeToggle();
            
            console.log('æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨:');
            console.log('generateBtn:', document.getElementById('generateBtn'));
            console.log('analyzeBtn:', document.getElementById('analyzeBtn'));
            console.log('diseaseName:', document.getElementById('diseaseName'));
            
            // ç®€å•æµ‹è¯•ï¼šç›´æ¥ç»‘å®šä¸€ä¸ªç®€å•çš„ç‚¹å‡»äº‹ä»¶
            const testBtn = document.getElementById('generateBtn');
            if (testBtn) {
                console.log('å°è¯•ç»‘å®šç®€å•æµ‹è¯•äº‹ä»¶...');
                testBtn.onclick = function() {
                    console.log('ç®€å•ç‚¹å‡»äº‹ä»¶å·¥ä½œæ­£å¸¸!');
                    alert('æŒ‰é’®ç‚¹å‡»æˆåŠŸ!');
                    return false;
                };
            }
            
            try {
                initializeAuth();
                initializeEventListeners();
                checkURLParameters();
                console.log('é¡µé¢åˆå§‹åŒ–å®Œæˆ');
            } catch (error) {
                console.error('é¡µé¢åˆå§‹åŒ–å‡ºé”™:', error);
            }
        });

        // åˆå§‹åŒ–è®¤è¯çŠ¶æ€
        async function initializeAuth() {
            const urlParams = new URLSearchParams(window.location.search);
            
            if (urlParams.get('auto_auth') === '1') {
                const doctorToken = urlParams.get('doctor_token');
                const doctorName = decodeURIComponent(urlParams.get('doctor_name') || '');
                
                if (doctorToken && doctorName) {
                    localStorage.setItem('token', doctorToken);
                    localStorage.setItem('doctorToken', doctorToken);
                    localStorage.setItem('doctorName', doctorName);
                    
                    showAuthStatus(doctorName, true);
                    
                    // æ¸…ç†URLå‚æ•°
                    const cleanUrl = window.location.pathname;
                    window.history.replaceState({}, document.title, cleanUrl);
                }
            } else {
                await checkExistingAuth();
            }
        }

        // æ£€æŸ¥ç°æœ‰è®¤è¯çŠ¶æ€
        async function checkExistingAuth() {
            const token = localStorage.getItem('token');
            if (!token) return;

            try {
                const response = await fetch('/api/doctor/current', {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    showAuthStatus(data.name, true);
                    isAuthenticated = true;
                    currentUser = data;
                }
            } catch (error) {
                console.log('è®¤è¯æ£€æŸ¥å¤±è´¥:', error);
            }
        }

        // æ˜¾ç¤ºè®¤è¯çŠ¶æ€
        function showAuthStatus(doctorName, isLoggedIn) {
            const authBar = document.getElementById('authBar');
            const container = document.getElementById('mainContainer');
            
            if (isLoggedIn) {
                authBar.className = 'auth-bar';
                authBar.innerHTML = `
                    âœ… å·²ç™»å½•åŒ»ç”Ÿ: ${doctorName} | å†³ç­–æ ‘å°†è‡ªåŠ¨ä¿å­˜åˆ°æ‚¨çš„è´¦æˆ·
                    <button onclick="logout()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 4px 12px; border-radius: 4px; margin-left: 20px; cursor: pointer; font-size: 12px;">é€€å‡ºç™»å½•</button>
                `;
                container.classList.add('with-auth');
                isAuthenticated = true;
            }
        }

        // é€€å‡ºç™»å½•
        function logout() {
            localStorage.removeItem('token');
            localStorage.removeItem('doctorToken');
            localStorage.removeItem('doctorName');
            document.getElementById('authBar').innerHTML = '';
            document.getElementById('mainContainer').classList.remove('with-auth');
            isAuthenticated = false;
            currentUser = null;
        }

        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
        function initializeEventListeners() {
            try {
                // AIåŠŸèƒ½æŒ‰é’®
                document.getElementById('generateBtn').addEventListener('click', generateAITree);
                document.getElementById('analyzeBtn').addEventListener('click', analyzeCurrentTree);
                document.getElementById('suggestBtn').addEventListener('click', suggestMissingLogic);
                
                // ä¸“ä¸šåŠŸèƒ½æŒ‰é’®
                document.getElementById('symptomDetectBtn').addEventListener('click', detectMissingSymptoms);
                document.getElementById('formulaAnalyzeBtn').addEventListener('click', analyzeFormula);
                
                // å¿«é€Ÿæ“ä½œæŒ‰é’®
                const autoPathwayBtn = document.getElementById('autoPathwayBtn');
                if (autoPathwayBtn) autoPathwayBtn.addEventListener('click', generateAutoPathway);
                
                const syndromeAnalyzeBtn = document.getElementById('syndromeAnalyzeBtn');
                if (syndromeAnalyzeBtn) syndromeAnalyzeBtn.addEventListener('click', analyzeSyndrome);
                
                // å¿«é€Ÿæ“ä½œæŒ‰é’®
                const addPathBtn = document.getElementById('addPathBtn');
                if (addPathBtn) addPathBtn.addEventListener('click', addStandardPath);
                
                const arrangeBtn = document.getElementById('arrangeBtn');
                if (arrangeBtn) {
                    arrangeBtn.onclick = function(e) {
                        e.preventDefault();
                        console.log('arrangeBtnè¢«ç‚¹å‡»äº†!');
                        autoArrangeNodes();
                        return false;
                    };
                }
                
                const clearBtn = document.getElementById('clearBtn');
                if (clearBtn) {
                    clearBtn.onclick = function(e) {
                        e.preventDefault();
                        console.log('clearBtnè¢«ç‚¹å‡»äº†!');
                        clearCanvas();
                        return false;
                    };
                }
            
                // ä¿å­˜å¯¼å‡ºæŒ‰é’®
                const saveBtn = document.getElementById('saveBtn');
                if (saveBtn) saveBtn.addEventListener('click', saveDecisionTree);
                
                const exportBtn = document.getElementById('exportBtn');
                if (exportBtn) exportBtn.addEventListener('click', exportJSON);

                // å…¨å±€äº‹ä»¶
                document.addEventListener('contextmenu', hideContextMenu);
                document.addEventListener('click', hideContextMenu);
                
                console.log('äº‹ä»¶ç›‘å¬å™¨åˆå§‹åŒ–å®Œæˆ');
            } catch (error) {
                console.error('äº‹ä»¶ç›‘å¬å™¨åˆå§‹åŒ–å¤±è´¥:', error);
            }
        }

        // åˆå§‹åŒ–AIçŠ¶æ€æ£€æŸ¥
        async function initializeAIStatus() {
            try {
                console.log('ğŸ” æ£€æŸ¥AIçŠ¶æ€...');
                const response = await fetch('/api/ai_status');
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        aiStatus = data.data;
                        updateAIStatusDisplay();
                        console.log('âœ… AIçŠ¶æ€è·å–æˆåŠŸ:', aiStatus);
                    } else {
                        console.warn('âš ï¸ AIçŠ¶æ€è·å–å¤±è´¥:', data.message);
                        updateAIStatusDisplay(false, data.message);
                    }
                } else {
                    console.warn('âš ï¸ AIçŠ¶æ€APIä¸å¯ç”¨ (404)ï¼Œä½¿ç”¨é™çº§æ¨¡å¼');
                    // é™çº§å¤„ç†ï¼šå‡è®¾AIå¯ç”¨ï¼Œè®©ç”¨æˆ·è‡ªå·±é€‰æ‹©
                    aiStatus.ai_enabled = true;
                    updateAIStatusDisplay(true, '');
                    
                    // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
                    const statusIndicator = document.getElementById('aiStatusIndicator');
                    if (statusIndicator) {
                        statusIndicator.innerHTML = 'âš¡ æ··åˆæ¨¡å¼ (APIé™çº§)';
                        statusIndicator.style.color = '#f59e0b';
                    }
                }
            } catch (error) {
                console.error('âŒ AIçŠ¶æ€æ£€æŸ¥ç½‘ç»œå¤±è´¥:', error);
                console.log('ğŸ”„ å¯ç”¨é™çº§æ¨¡å¼ï¼Œå…è®¸ç”¨æˆ·é€‰æ‹©');
                
                // ç½‘ç»œé”™è¯¯ä¹Ÿå¯ç”¨é™çº§æ¨¡å¼
                aiStatus.ai_enabled = true;
                updateAIStatusDisplay(true, '');
                
                const statusIndicator = document.getElementById('aiStatusIndicator');
                if (statusIndicator) {
                    statusIndicator.innerHTML = 'âš¡ æ··åˆæ¨¡å¼ (ç½‘ç»œé™çº§)';
                    statusIndicator.style.color = '#f59e0b';
                }
            }
        }
        
        // æ›´æ–°AIçŠ¶æ€æ˜¾ç¤º
        function updateAIStatusDisplay(success = true, errorMessage = '') {
            const statusIndicator = document.getElementById('aiStatusIndicator');
            const aiModeToggle = document.getElementById('aiModeToggle');
            const aiModeText = document.getElementById('aiModeText');
            
            if (success && aiStatus.ai_enabled) {
                // AIå¯ç”¨æˆ–é™çº§æ¨¡å¼
                if (!statusIndicator.innerHTML.includes('æ··åˆæ¨¡å¼')) {
                    statusIndicator.innerHTML = `âœ… AIå·²å°±ç»ª (${aiStatus.model || 'qwen-max'})`;
                    statusIndicator.style.color = '#059669';
                }
                aiModeToggle.disabled = false;
                
                console.log('ğŸ›ï¸ AIæ¨¡å¼åˆ‡æ¢å·²å¯ç”¨');
            } else if (errorMessage && !errorMessage.includes('é™çº§')) {
                // åªæœ‰åœ¨çœŸæ­£é”™è¯¯æ—¶æ‰ç¦ç”¨
                const message = errorMessage || 'AIæœåŠ¡ä¸å¯ç”¨ï¼Œå°†ä½¿ç”¨æ¨¡æ¿æ¨¡å¼';
                statusIndicator.innerHTML = `âš ï¸ ${message}`;
                statusIndicator.style.color = '#d97706';
                aiModeToggle.checked = false;
                aiModeToggle.disabled = true;
                updateModeDisplay(false);
                
                console.log('ğŸš« AIæ¨¡å¼åˆ‡æ¢å·²ç¦ç”¨');
            } else {
                // é™çº§æ¨¡å¼ï¼šä¿æŒåˆ‡æ¢å¯ç”¨
                aiModeToggle.disabled = false;
                console.log('âš¡ é™çº§æ¨¡å¼ï¼šAIåˆ‡æ¢ä¿æŒå¯ç”¨');
            }
        }
        
        // åˆå§‹åŒ–æ¨¡å¼åˆ‡æ¢
        function initializeModeToggle() {
            const aiModeToggle = document.getElementById('aiModeToggle');
            
            console.log('ğŸ”§ åˆå§‹åŒ–æ¨¡å¼åˆ‡æ¢...');
            console.log('  - Toggleå…ƒç´ :', aiModeToggle);
            console.log('  - AIçŠ¶æ€:', aiStatus);
            
            if (aiModeToggle) {
                // ç§»é™¤å¯èƒ½å­˜åœ¨çš„æ—§äº‹ä»¶ç›‘å¬å™¨
                aiModeToggle.removeEventListener('change', handleModeToggle);
                
                // æ·»åŠ æ–°çš„äº‹ä»¶ç›‘å¬å™¨
                aiModeToggle.addEventListener('change', handleModeToggle);
                
                // åˆå§‹åŒ–æ˜¾ç¤ºçŠ¶æ€
                const initialUseAI = aiModeToggle.checked && aiStatus.ai_enabled;
                updateModeDisplay(initialUseAI);
                
                console.log('âœ… æ¨¡å¼åˆ‡æ¢åˆå§‹åŒ–å®Œæˆ');
            } else {
                console.error('âŒ æ‰¾ä¸åˆ°aiModeToggleå…ƒç´ ');
            }
        }
        
        // æ¨¡å¼åˆ‡æ¢å¤„ç†å‡½æ•°
        function handleModeToggle() {
            const useAI = this.checked && aiStatus.ai_enabled;
            console.log('ğŸ”„ æ¨¡å¼åˆ‡æ¢äº‹ä»¶è§¦å‘:');
            console.log('  - Toggleé€‰ä¸­:', this.checked);
            console.log('  - AIå¯ç”¨:', aiStatus.ai_enabled);
            console.log('  - æœ€ç»ˆæ¨¡å¼:', useAI ? 'AIæ¨¡å¼' : 'æ¨¡æ¿æ¨¡å¼');
            
            updateModeDisplay(useAI);
            
            // å¯é€‰ï¼šä¿å­˜ç”¨æˆ·åå¥½
            if (typeof userPreferences !== 'undefined') {
                userPreferences.aiModePreferred = useAI;
            }
        }
        
        // æ›´æ–°æ¨¡å¼æ˜¾ç¤º
        function updateModeDisplay(useAI) {
            const aiModeText = document.getElementById('aiModeText');
            const generateBtnIcon = document.getElementById('generateBtnIcon');
            const generateBtnText = document.getElementById('generateBtnText');
            
            if (useAI) {
                aiModeText.textContent = 'AIæ™ºèƒ½æ¨¡å¼';
                aiModeText.style.color = '#3b82f6';
                generateBtnIcon.textContent = 'ğŸ¤–';
                generateBtnText.textContent = 'AIæ™ºèƒ½ç”Ÿæˆ';
            } else {
                aiModeText.textContent = 'æ ‡å‡†æ¨¡æ¿æ¨¡å¼';
                aiModeText.style.color = '#6b7280';
                generateBtnIcon.textContent = 'ğŸ“‹';
                generateBtnText.textContent = 'æ ‡å‡†æ¨¡æ¿ç”Ÿæˆ';
            }
            
            userPreferences.aiModePreferred = useAI;
        }
        
        // æ˜¾ç¤ºç”ŸæˆçŠ¶æ€å’Œæ•°æ®æ¥æº
        function showGenerationStatus(source, info, time) {
            const statusPanel = document.getElementById('generationStatusPanel');
            const dataSourceBadge = document.getElementById('dataSourceBadge');
            const generationInfo = document.getElementById('generationInfo');
            const generationTime = document.getElementById('generationTime');
            
            // æ›´æ–°æ•°æ®æ¥æºæ ‡è¯†
            dataSourceBadge.className = `data-source-badge data-source-${source}`;
            switch (source) {
                case 'ai':
                    dataSourceBadge.textContent = 'ğŸ¤– AI Generated';
                    generationInfo.textContent = info || 'å·²ä½¿ç”¨AIæ™ºèƒ½ç”Ÿæˆ';
                    break;
                case 'template':
                    dataSourceBadge.textContent = 'ğŸ“‹ Template';
                    generationInfo.textContent = info || 'å·²ä½¿ç”¨æ ‡å‡†æ¨¡æ¿ç”Ÿæˆ';
                    break;
                case 'template_fallback':
                    dataSourceBadge.textContent = 'âš ï¸ Fallback';
                    generationInfo.textContent = info || 'AIå¤±è´¥ï¼Œä½¿ç”¨æ¨¡æ¿å¤‡ç”¨';
                    break;
            }
            
            generationTime.textContent = time || 'å³æ—¶';
            
            // æ˜¾ç¤ºçŠ¶æ€é¢æ¿
            statusPanel.style.display = 'block';
            statusPanel.className = `generation-status ${source === 'ai' ? 'ai-mode' : 'template-mode'}`;
        }

        // AIç”Ÿæˆå†³ç­–æ ‘ï¼ˆå‡çº§ç‰ˆï¼‰
        async function generateAITree() {
            console.log('ğŸš€ æ™ºèƒ½ç”Ÿæˆå†³ç­–æ ‘è¢«è°ƒç”¨');
            
            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            if (!getCurrentDiseaseName()) {
                alert('è¯·å…ˆè¾“å…¥ç–¾ç—…åç§°');
                return;
            }

            const doctorThought = document.getElementById('doctorThought').value.trim();
            const useAI = document.getElementById('aiModeToggle').checked && aiStatus.ai_enabled;
            
            // æ ¹æ®æ¨¡å¼æ˜¾ç¤ºä¸åŒçš„loadingä¿¡æ¯
            const loadingMessage = useAI ? 
                (doctorThought ? 'AIæ­£åœ¨æ ¹æ®æ‚¨çš„æ€è·¯ç”Ÿæˆå†³ç­–æ ‘...' : 'AIæ­£åœ¨ç”Ÿæˆæ ‡å‡†å†³ç­–æ ‘...') :
                'æ­£åœ¨åŠ è½½æ ‡å‡†æ¨¡æ¿...';
            
            showLoading(loadingMessage);

            try {
                const response = await fetch('/api/generate_visual_decision_tree', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        disease_name: getCurrentDiseaseName(),
                        thinking_process: doctorThought,
                        use_ai: useAI,
                        include_tcm_analysis: true,
                        complexity_level: userPreferences.complexityLevel
                    })
                });

                const result = await response.json();
                
                if (result.success && result.data && result.data.paths) {
                    const pathsData = result.data.paths;
                    const source = result.data.source || 'template';
                    const generationTime = result.data.generation_time || 'å³æ—¶';
                    
                    generateNodesFromPaths(pathsData);
                    hideLoading();
                    
                    // æ˜¾ç¤ºç”ŸæˆçŠ¶æ€
                    showGenerationStatus(
                        source, 
                        result.message,
                        generationTime
                    );
                    
                    showResult('æˆåŠŸ', `âœ… æˆåŠŸç”Ÿæˆäº†${pathsData.length}æ¡è¯Šç–—è·¯å¾„ï¼`, 'success');
                    console.log('ğŸ“Š ç”Ÿæˆç»Ÿè®¡:', {
                        source: source,
                        pathCount: pathsData.length,
                        aiEnabled: aiStatus.ai_enabled,
                        userThinking: !!doctorThought
                    });
                } else {
                    throw new Error(result.message || 'ç”Ÿæˆå¤±è´¥');
                }
            } catch (error) {
                console.error('âŒ ç”Ÿæˆå¤±è´¥:', error);
                hideLoading();
                showResult('é”™è¯¯', `âŒ ç”Ÿæˆå¤±è´¥: ${error.message}`, 'error');
            }
        }

        // ä»AIè·¯å¾„æ•°æ®ç”ŸæˆèŠ‚ç‚¹ï¼ˆä¼˜åŒ–ç‰ˆï¼šæ”¯æŒä¸­åŒ»è¯Šç–—æµç¨‹ï¼‰
        function generateNodesFromPaths(paths) {
            clearCanvas();
            
            // é‡æ–°ç»„ç»‡è·¯å¾„æ•°æ®ä»¥ç¬¦åˆä¸­åŒ»è¯Šç–—æµç¨‹
            const tcmFlowPaths = organizeTCMFlow(paths);
            
            let baseX = 50, baseY = 100;
            const stepWidth = 250;
            const branchHeight = 150;
            
            // ç”Ÿæˆä¸»è¯Šç–—æµç¨‹
            let previousMainNode = null;
            tcmFlowPaths.mainFlow.forEach((step, index) => {
                const node = {
                    id: `main_${index}`,
                    type: step.type,
                    name: step.name,
                    description: step.description || step.content,
                    x: baseX + (index * stepWidth),
                    y: baseY
                };
                
                nodes.push(node);
                renderNode(node);
                
                if (previousMainNode) {
                    connections.push({
                        from: previousMainNode.id,
                        to: node.id
                    });
                }
                
                previousMainNode = node;
                
                // å¤„ç†åˆ†æ”¯ï¼ˆå¦‚è¯å€™åˆ†å‹ï¼‰
                if (step.branches && step.branches.length > 0) {
                    step.branches.forEach((branch, branchIndex) => {
                        const branchNode = {
                            id: `branch_${index}_${branchIndex}`,
                            type: branch.type,
                            name: branch.name,
                            description: branch.description,
                            x: node.x + stepWidth,
                            y: baseY + (branchIndex - (step.branches.length - 1) / 2) * branchHeight
                        };
                        
                        nodes.push(branchNode);
                        renderNode(branchNode);
                        
                        connections.push({
                            from: node.id,
                            to: branchNode.id
                        });
                        
                        // ä¸ºæ¯ä¸ªåˆ†æ”¯æ·»åŠ åç»­èŠ‚ç‚¹
                        if (branch.followUp) {
                            branch.followUp.forEach((followStep, followIndex) => {
                                const followNode = {
                                    id: `follow_${index}_${branchIndex}_${followIndex}`,
                                    type: followStep.type,
                                    name: followStep.name,
                                    description: followStep.description,
                                    x: branchNode.x + (followIndex + 1) * stepWidth,
                                    y: branchNode.y
                                };
                                
                                nodes.push(followNode);
                                renderNode(followNode);
                                
                                const prevNode = followIndex === 0 ? branchNode : 
                                    nodes.find(n => n.id === `follow_${index}_${branchIndex}_${followIndex-1}`);
                                
                                connections.push({
                                    from: prevNode.id,
                                    to: followNode.id
                                });
                            });
                        }
                    });
                }
            });
            
            updateCanvas();
            drawConnections();
            
            // è‡ªåŠ¨æ’åˆ—ä¼˜åŒ–
            setTimeout(() => autoArrangeNodes(), 100);
        }
        
        // ç»„ç»‡ä¸­åŒ»è¯Šç–—æµç¨‹
        function organizeTCMFlow(paths) {
            // å®šä¹‰ä¸­åŒ»è¯Šç–—æ ‡å‡†æµç¨‹
            const tcmStages = [
                'disease',        // ç—…ç§
                'four_diagnosis', // å››è¯Š
                'symptom',        // ç—‡çŠ¶
                'pathogenesis',   // ç—…å› ç—…æœº
                'syndrome',       // è¯å€™
                'principle',      // æ²»åˆ™
                'prescription',   // å¤„æ–¹
                'modification',   // åŠ å‡
                'prognosis'       // é¢„å
            ];
            
            const mainFlow = [];
            const diseaseInfo = getCurrentDiseaseName();
            
            // æ„å»ºä¸»æµç¨‹
            if (diseaseInfo) {
                mainFlow.push({
                    type: 'disease',
                    name: diseaseInfo,
                    description: 'ç—…ç§è¯†åˆ«å’Œç¡®è®¤'
                });
            }
            
            // ä»åŸå§‹è·¯å¾„ä¸­æå–å’Œç»„ç»‡ä¿¡æ¯
            paths.forEach(path => {
                path.steps.forEach(step => {
                    const stageIndex = tcmStages.indexOf(step.type);
                    if (stageIndex !== -1) {
                        // å°†æ­¥éª¤æŒ‰ç…§ä¸­åŒ»æµç¨‹é¡ºåºç»„ç»‡
                        const existingStage = mainFlow.find(s => s.type === step.type);
                        if (!existingStage) {
                            mainFlow.push({
                                type: step.type,
                                name: step.content || getDefaultNodeName(step.type),
                                description: step.description || '',
                                branches: []
                            });
                        } else if (step.type === 'syndrome' || step.type === 'prescription') {
                            // å¯¹äºè¯å€™å’Œå¤„æ–¹ï¼Œæ”¯æŒå¤šåˆ†æ”¯
                            existingStage.branches.push({
                                type: step.type,
                                name: step.content,
                                description: step.description || ''
                            });
                        }
                    }
                });
            });
            
            // æŒ‰ç…§ä¸­åŒ»æµç¨‹é¡ºåºæ’åº
            mainFlow.sort((a, b) => {
                const aIndex = tcmStages.indexOf(a.type);
                const bIndex = tcmStages.indexOf(b.type);
                return aIndex - bIndex;
            });
            
            return { mainFlow };
        }

        // åˆ†æå½“å‰å†³ç­–æ ‘
        async function analyzeCurrentTree() {
            console.log('åˆ†æå½“å‰å†³ç­–æ ‘è¢«è°ƒç”¨');
            
            if (nodes.length === 0) {
                alert('è¯·å…ˆåˆ›å»ºæˆ–ç”Ÿæˆå†³ç­–æ ‘');
                return;
            }

            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            if (!getCurrentDiseaseName()) {
                alert('è¯·å…ˆè¾“å…¥ç–¾ç—…åç§°');
                return;
            }

            showLoading('æ­£åœ¨è¿›è¡Œä¸­åŒ»ç†è®ºåˆ†æ...');

            try {
                const treeData = {
                    disease_name: getCurrentDiseaseName(),
                    nodes: nodes
                };

                const response = await fetch('/api/analyze_tree_tcm_theory', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        tree_data: treeData,
                        disease_name: getCurrentDiseaseName()
                    })
                });

                const data = await response.json();
                
                if (data.success && data.data) {
                    hideLoading();
                    showAnalysisResult(data.data.analysis || 'åˆ†æå®Œæˆ');
                } else {
                    throw new Error(data.message || 'åˆ†æå¤±è´¥');
                }
            } catch (error) {
                console.error('ç†è®ºåˆ†æå¤±è´¥:', error);
                hideLoading();
                showResult('é”™è¯¯', `âŒ åˆ†æå¤±è´¥: ${error.message}`, 'error');
            }
        }

        // å»ºè®®é—æ¼é€»è¾‘
        async function suggestMissingLogic() {
            console.log('å»ºè®®é—æ¼é€»è¾‘è¢«è°ƒç”¨');
            
            if (nodes.length === 0) {
                alert('è¯·å…ˆåˆ›å»ºæˆ–ç”Ÿæˆå†³ç­–æ ‘');
                return;
            }

            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            if (!getCurrentDiseaseName()) {
                alert('è¯·å…ˆè¾“å…¥ç–¾ç—…åç§°');
                return;
            }

            showLoading('æ­£åœ¨æ£€æµ‹é—æ¼é€»è¾‘...');

            try {
                const response = await fetch('/api/detect_missing_logic', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        disease_name: getCurrentDiseaseName(),
                        current_paths: [],
                        existing_nodes: nodes
                    })
                });

                const data = await response.json();
                
                if (data.success && data.data) {
                    hideLoading();
                    showMissingLogicResult(data.data);
                } else {
                    throw new Error(data.message || 'æ£€æµ‹å¤±è´¥');
                }
            } catch (error) {
                console.error('é—æ¼é€»è¾‘æ£€æµ‹å¤±è´¥:', error);
                hideLoading();
                showResult('é”™è¯¯', `âŒ æ£€æµ‹å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ·»åŠ æ ‡å‡†è·¯å¾„
        function addStandardPath() {
            console.log('æ·»åŠ æ ‡å‡†è·¯å¾„è¢«è°ƒç”¨');
            
            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            
            clearCanvas();
            
            // æ£€æŸ¥æ˜¯å¦åº”è¯¥åˆ›å»ºç—‡çŠ¶ç¾¤
            const template = SYMPTOM_CLUSTER_TEMPLATES[`${getCurrentDiseaseName()}ç¾¤`];
            if (template) {
                // åˆ›å»ºç—‡çŠ¶ç¾¤æ¨¡å¼
                // TODO: ä¼˜åŒ–åæ·»åŠ ç—‡çŠ¶ç¾¤åŠŸèƒ½
                
                // åˆ›å»ºåç»­èŠ‚ç‚¹
                const followUpNodes = [
                    { type: 'diagnosis', name: 'ä¸­åŒ»è¯Šæ–­', description: 'è¾¨è¯åˆ†å‹', x: 400, y: 150 },
                    { type: 'treatment', name: 'æ²»ç–—æ–¹æ³•', description: 'æ²»åˆ™æ²»æ³•', x: 650, y: 150 },
                    { type: 'formula', name: 'æ–¹å‰‚é€‰æ‹©', description: 'å…·ä½“æ–¹è¯', x: 900, y: 150 }
                ];
                
                let previousNode = null;
                followUpNodes.forEach((nodeData, index) => {
                    const node = {
                        id: `std_${index + 2}`,
                        ...nodeData
                    };
                    nodes.push(node);
                    renderNode(node);
                    previousNode = node;
                });
            } else {
                // ä¼ ç»Ÿæ¨¡å¼ - åˆ›å»ºç¬¦åˆä¸­åŒ»è¯Šç–—æµç¨‹çš„æ ‡å‡†è·¯å¾„èŠ‚ç‚¹
                const standardNodes = [
                    { type: 'disease', name: `${getCurrentDiseaseName()}`, description: 'ç—…ç§è¯†åˆ«', x: 50, y: 100 },
                    { type: 'four_diagnosis', name: 'å››è¯Šæ”¶é›†', description: 'æœ›é—»é—®åˆ‡', x: 250, y: 100 },
                    { type: 'symptom', name: 'ä¸»è¦ç—‡çŠ¶', description: 'ç—‡çŠ¶åˆ†æ', x: 450, y: 100 },
                    { type: 'pathogenesis', name: 'ç—…å› ç—…æœº', description: 'ç—…ç†åˆ†æ', x: 650, y: 100 },
                    { type: 'syndrome', name: 'è¯å€™åˆ¤æ–­', description: 'è¾¨è¯åˆ†å‹', x: 850, y: 100 },
                    { type: 'principle', name: 'æ²»åˆ™æ²»æ³•', description: 'ç¡®å®šæ²»ç–—åŸåˆ™', x: 1050, y: 100 },
                    { type: 'prescription', name: 'æ–¹å‰‚å¤„æ–¹', description: 'é€‰æ–¹ç”¨è¯', x: 1250, y: 100 },
                    { type: 'formula', name: 'æ–¹å‰‚é€‰æ‹©', description: 'å…·ä½“æ–¹è¯', x: 1050, y: 100 }
                ];
                
                let previousNode = null;
                standardNodes.forEach((nodeData, index) => {
                    const node = {
                        id: `std_${index + 1}`,
                        ...nodeData
                    };
                    nodes.push(node);
                    renderNode(node);
                    
                    // åˆ›å»ºè¿æ¥
                    if (previousNode) {
                        connections.push({
                            from: previousNode.id,
                            to: node.id
                        });
                    }
                    
                    previousNode = node;
                });
            }
            
            let previousNode = null;
            standardNodes.forEach((nodeData, index) => {
                const node = {
                    id: `std_${index + 1}`,
                    ...nodeData
                };
                nodes.push(node);
                renderNode(node);
                
                // åˆ›å»ºè¿æ¥
                if (previousNode) {
                    connections.push({
                        from: previousNode.id,
                        to: node.id
                    });
                }
                
                previousNode = node;
            });
            
            updateCanvas();
            drawConnections();
            showResult('æˆåŠŸ', 'âœ… æ ‡å‡†è¯Šç–—è·¯å¾„å·²æ·»åŠ ', 'success');
        }

        // è‡ªåŠ¨æ’åˆ—èŠ‚ç‚¹
        function autoArrangeNodes() {
            console.log('è‡ªåŠ¨æ’åˆ—èŠ‚ç‚¹è¢«è°ƒç”¨');
            
            if (nodes.length === 0) {
                showResult('æç¤º', 'æ²¡æœ‰èŠ‚ç‚¹éœ€è¦æ’åˆ—', 'info');
                return;
            }
            
            // åŸºäºä¸­åŒ»è¯Šç–—æµç¨‹çš„æ™ºèƒ½æ’åˆ—
            const nodeHierarchy = buildNodeHierarchy();
            
            // è®¡ç®—å¸ƒå±€
            const baseX = 50;
            const baseY = 300;
            const horizontalGap = 280;
            const verticalGap = 150;
            
            // æŒ‰å±‚çº§æ’åˆ—
            Object.keys(nodeHierarchy).forEach((level, levelIndex) => {
                const levelNodes = nodeHierarchy[level];
                const levelX = baseX + levelIndex * horizontalGap;
                
                levelNodes.forEach((node, nodeIndex) => {
                    // è®¡ç®—å‚ç›´ä½ç½®ï¼Œä½¿åŒå±‚èŠ‚ç‚¹å±…ä¸­åˆ†å¸ƒ
                    const totalHeight = (levelNodes.length - 1) * verticalGap;
                    const startY = baseY - (totalHeight / 2);
                    node.x = levelX;
                    node.y = startY + (nodeIndex * verticalGap);
                    
                    updateNodePosition(node);
                });
            });
            
            // é‡ç»˜è¿æ¥çº¿
            setTimeout(() => {
                drawConnections();
                showResult('æˆåŠŸ', `âœ… å·²æŒ‰ä¸­åŒ»è¯Šç–—æµç¨‹æ™ºèƒ½æ’åˆ—${nodes.length}ä¸ªèŠ‚ç‚¹`, 'success');
            }, 50);
        }
        
        // æ„å»ºèŠ‚ç‚¹å±‚çº§å…³ç³»
        function buildNodeHierarchy() {
            const hierarchy = {};
            const visited = new Set();
            
            // æŸ¥æ‰¾æ ¹èŠ‚ç‚¹ï¼ˆæ²¡æœ‰å…¥è¾¹çš„èŠ‚ç‚¹ï¼‰
            const rootNodes = nodes.filter(node => {
                return !connections.some(conn => conn.to === node.id);
            });
            
            // å¦‚æœæ²¡æœ‰æ˜ç¡®çš„æ ¹èŠ‚ç‚¹ï¼Œé€‰æ‹©ç—…ç§ç±»å‹çš„èŠ‚ç‚¹ä½œä¸ºæ ¹
            if (rootNodes.length === 0) {
                const diseaseNodes = nodes.filter(n => n.type === 'disease');
                if (diseaseNodes.length > 0) {
                    rootNodes.push(...diseaseNodes);
                } else if (nodes.length > 0) {
                    rootNodes.push(nodes[0]);
                }
            }
            
            // å¹¿åº¦ä¼˜å…ˆéå†æ„å»ºå±‚çº§
            let currentLevel = 0;
            let currentLevelNodes = rootNodes;
            
            while (currentLevelNodes.length > 0 && currentLevel < 10) {
                hierarchy[currentLevel] = [...currentLevelNodes];
                currentLevelNodes.forEach(n => visited.add(n.id));
                
                // è·å–ä¸‹ä¸€å±‚èŠ‚ç‚¹
                const nextLevelNodes = [];
                currentLevelNodes.forEach(node => {
                    const childConnections = connections.filter(conn => conn.from === node.id);
                    childConnections.forEach(conn => {
                        const childNode = nodes.find(n => n.id === conn.to);
                        if (childNode && !visited.has(childNode.id)) {
                            nextLevelNodes.push(childNode);
                            visited.add(childNode.id);
                        }
                    });
                });
                
                currentLevelNodes = nextLevelNodes;
                currentLevel++;
            }
            
            return hierarchy;
        }

        // æ¸…ç©ºç”»å¸ƒ
        function clearCanvas() {
            console.log('æ¸…ç©ºç”»å¸ƒè¢«è°ƒç”¨');
            
            nodes = [];
            selectedNode = null;
            connections = [];
            
            const canvas = document.getElementById('canvas');
            canvas.innerHTML = `
                <svg id="branchSvg">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#3b82f6" />
                        </marker>
                    </defs>
                </svg>
                <div class="empty-canvas" id="emptyHint">
                    <div style="font-size: 48px; margin-bottom: 20px;">ğŸŒ³</div>
                    <h3>å¼€å§‹æ„å»ºæ‚¨çš„å†³ç­–æ ‘</h3>
                    <p style="margin: 10px 0;">è¾“å…¥ç–¾ç—…åç§°ï¼Œç„¶åç‚¹å‡»"AIç”Ÿæˆå†³ç­–æ ‘"</p>
                    <p style="color: #9ca3af; font-size: 12px;">æˆ–ç‚¹å‡»"æ ‡å‡†è·¯å¾„"å¿«é€Ÿå¼€å§‹</p>
                </div>
            `;
            
            clearResults();
            hideSelectedNodeInfo();
            showResult('æˆåŠŸ', 'âœ… ç”»å¸ƒå·²æ¸…ç©º', 'success');
        }

        // ä¿å­˜å†³ç­–æ ‘
        async function saveDecisionTree() {
            console.log('ä¿å­˜å†³ç­–æ ‘è¢«è°ƒç”¨');
            
            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            if (!getCurrentDiseaseName()) {
                alert('è¯·å…ˆè¾“å…¥ç–¾ç—…åç§°');
                return;
            }

            if (nodes.length === 0) {
                alert('è¯·å…ˆæ„å»ºå†³ç­–æ ‘');
                return;
            }

            if (!isAuthenticated) {
                alert('è¯·å…ˆç™»å½•åŒ»ç”Ÿè´¦æˆ·');
                return;
            }

            showLoading('æ­£åœ¨ä¿å­˜å†³ç­–æ ‘...');

            try {
                const saveData = {
                    disease_name: getCurrentDiseaseName(),
                    paths: convertNodesToPaths(),
                    integration_enabled: true
                };

                const response = await fetch('/api/save_decision_tree_v3', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify(saveData)
                });

                const data = await response.json();
                
                if (data.success) {
                    hideLoading();
                    showResult('æˆåŠŸ', `âœ… å†³ç­–æ ‘å·²ä¿å­˜ï¼åŒ…å«${nodes.length}ä¸ªèŠ‚ç‚¹`, 'success');
                } else {
                    throw new Error(data.message || 'ä¿å­˜å¤±è´¥');
                }
            } catch (error) {
                console.error('ä¿å­˜å¤±è´¥:', error);
                hideLoading();
                showResult('é”™è¯¯', `âŒ ä¿å­˜å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // å¯¼å‡ºJSON
        function exportJSON() {
            console.log('å¯¼å‡ºJSONè¢«è°ƒç”¨');
            
            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            
            const exportData = {
                disease_name: getCurrentDiseaseName() || 'æœªå‘½åç–¾ç—…',
                nodes: nodes,
                exported_at: new Date().toISOString(),
                version: '2.0'
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `å†³ç­–æ ‘_${getCurrentDiseaseName() || 'æœªå‘½å'}_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
            showResult('æˆåŠŸ', 'âœ… JSONæ–‡ä»¶å·²ä¸‹è½½', 'success');
        }

        // æ¸²æŸ“èŠ‚ç‚¹
        function renderNode(node) {
            const canvas = document.getElementById('canvas');
            const emptyHint = document.getElementById('emptyHint');
            
            if (emptyHint) {
                emptyHint.remove();
            }

            const nodeElement = document.createElement('div');
            nodeElement.className = `node ${node.type}`;
            nodeElement.id = node.id;
            nodeElement.style.left = `${node.x}px`;
            nodeElement.style.top = `${node.y}px`;
            
            // æ„å»ºèŠ‚ç‚¹å†…å®¹ï¼Œæ”¯æŒç›¸å…³ç—‡çŠ¶æ˜¾ç¤º
            let nodeContent = node.description || '';
            if (node.relatedSymptoms && node.relatedSymptoms.length > 0) {
                nodeContent = `${nodeContent}
                    <div class="related-symptoms">
                        <div class="symptoms-label">ç›¸å…³ç—‡çŠ¶:</div>
                        <div class="symptoms-list">${node.relatedSymptoms.join(', ')}</div>
                    </div>`;
            }
            
            nodeElement.innerHTML = `
                <button class="delete-btn" onclick="deleteNodeById('${node.id}')">Ã—</button>
                <div class="node-title">${node.name}</div>
                <div class="node-content">${nodeContent}</div>
            `;
            
            // æ·»åŠ ç‚¹å‡»äº‹ä»¶
            nodeElement.addEventListener('click', function(e) {
                e.stopPropagation();
                selectNode(node);
            });
            
            // æ·»åŠ å³é”®èœå•äº‹ä»¶
            nodeElement.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                e.stopPropagation();
                showContextMenu(e, node);
            });
            
            // ä½¿ç”¨ç»Ÿä¸€çš„ç¼–è¾‘åŠŸèƒ½ç»‘å®š
            ensureNodeEditability(nodeElement, node);
            
            // æ·»åŠ æ‹–æ‹½
            makeNodeDraggable(nodeElement, node);
            
            canvas.appendChild(nodeElement);
        }

        // ç¼–è¾‘èŠ‚ç‚¹å†…å®¹
        function editNodeContent(node) {
            const nodeElement = document.getElementById(node.id);
            const contentDiv = nodeElement.querySelector('.node-content');
            const originalContent = node.description || '';
            
            // åˆ›å»ºç¼–è¾‘è¾“å…¥æ¡†
            const textarea = document.createElement('textarea');
            textarea.className = 'node-edit-input';
            textarea.value = originalContent;
            textarea.style.cssText = `
                width: 100%;
                height: 60px;
                border: 2px solid #007bff;
                border-radius: 4px;
                padding: 5px;
                font-size: 12px;
                font-family: inherit;
                resize: vertical;
                background: #fff;
                z-index: 1000;
            `;
            
            // æ›¿æ¢å†…å®¹
            contentDiv.innerHTML = '';
            contentDiv.appendChild(textarea);
            textarea.focus();
            textarea.select();
            
            // ä¿å­˜ç¼–è¾‘
            function saveEdit() {
                const newContent = textarea.value.trim();
                if (newContent !== originalContent) {
                    node.description = newContent;
                    updateNodeDisplay(node);
                    // å¦‚æœå½“å‰èŠ‚ç‚¹è¢«é€‰ä¸­ï¼Œæ›´æ–°ä¾§è¾¹æ ä¿¡æ¯
                    if (selectedNode && selectedNode.id === node.id) {
                        showSelectedNodeInfo(node);
                    }
                }
                restoreContent();
            }
            
            // æ¢å¤å†…å®¹æ˜¾ç¤º
            function restoreContent() {
                updateNodeDisplay(node);
            }
            
            // ç›‘å¬äº‹ä»¶
            textarea.addEventListener('blur', saveEdit);
            textarea.addEventListener('keydown', function(e) {
                e.stopPropagation();
                if (e.key === 'Enter' && e.ctrlKey) {
                    saveEdit();
                } else if (e.key === 'Escape') {
                    restoreContent();
                }
            });
        }
        

        // é€‰æ‹©èŠ‚ç‚¹
        function selectNode(node) {
            // æ¸…é™¤å…¶ä»–é€‰æ‹©
            document.querySelectorAll('.node').forEach(el => {
                el.classList.remove('selected');
            });
            
            // é€‰æ‹©å½“å‰èŠ‚ç‚¹
            document.getElementById(node.id).classList.add('selected');
            selectedNode = node;
            
            showSelectedNodeInfo(node);
            console.log('é€‰æ‹©äº†èŠ‚ç‚¹:', node.name);
        }

        // ä½¿èŠ‚ç‚¹å¯æ‹–æ‹½
        function makeNodeDraggable(element, node) {
            let isDragging = false;
            let startX, startY, startNodeX, startNodeY;

            element.addEventListener('mousedown', function(e) {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startNodeX = node.x;
                startNodeY = node.y;
                
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            });

            function handleMouseMove(e) {
                if (!isDragging) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                node.x = Math.max(0, startNodeX + deltaX);
                node.y = Math.max(0, startNodeY + deltaY);
                
                updateNodePosition(node);
            }

            function handleMouseUp() {
                isDragging = false;
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            }
        }

        // æ›´æ–°èŠ‚ç‚¹ä½ç½®
        function updateNodePosition(node) {
            const element = document.getElementById(node.id);
            if (element) {
                element.style.left = `${node.x}px`;
                element.style.top = `${node.y}px`;
            }
        }

        // è½¬æ¢èŠ‚ç‚¹ä¸ºè·¯å¾„æ ¼å¼
        function convertNodesToPaths() {
            if (nodes.length === 0) return [];
            
            return [{
                id: 'path_1',
                steps: nodes.map(node => ({
                    type: node.type,
                    content: node.name
                })),
                keywords: [document.getElementById('diseaseName').value.trim()],
                created_by: currentUser?.name || 'åŒ¿åç”¨æˆ·'
            }];
        }

        // æ›´æ–°ç”»å¸ƒçŠ¶æ€
        function updateCanvas() {
            const canvas = document.getElementById('canvas');
            const emptyHint = document.getElementById('emptyHint');
            
            if (nodes.length === 0 && !emptyHint) {
                canvas.innerHTML = `
                    <div class="empty-canvas" id="emptyHint">
                        <div style="font-size: 48px; margin-bottom: 20px;">ğŸŒ³</div>
                        <h3>å¼€å§‹æ„å»ºæ‚¨çš„å†³ç­–æ ‘</h3>
                        <p style="margin: 10px 0;">è¾“å…¥ç–¾ç—…åç§°ï¼Œç„¶åç‚¹å‡»"AIç”Ÿæˆå†³ç­–æ ‘"</p>
                        <p style="color: #9ca3af; font-size: 12px;">æˆ–ç‚¹å‡»"æ ‡å‡†è·¯å¾„"å¿«é€Ÿå¼€å§‹</p>
                    </div>
                `;
            }
        }

        // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        function showLoading(message) {
            const loading = document.getElementById('loading');
            const loadingText = document.getElementById('loadingText');
            
            loadingText.textContent = message;
            loading.style.display = 'flex';
        }

        // éšè—åŠ è½½çŠ¶æ€
        function hideLoading() {
            const loading = document.getElementById('loading');
            loading.style.display = 'none';
        }

        // æ˜¾ç¤ºç»“æœ
        function showResult(title, message, type) {
            const resultsDiv = document.getElementById('analysisResults');
            
            const typeColors = {
                success: '#22c55e',
                error: '#ef4444',
                warning: '#f59e0b',
                info: '#3b82f6'
            };
            
            const color = typeColors[type] || typeColors.info;
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = `
                <div class="result-title" style="color: ${color};">${title}</div>
                <div style="font-size: 13px; color: #374151;">${message}</div>
            `;
            
            resultsDiv.appendChild(resultElement);
            
            // 5ç§’åè‡ªåŠ¨ç§»é™¤æˆåŠŸæ¶ˆæ¯
            if (type === 'success') {
                setTimeout(() => {
                    resultElement.remove();
                }, 5000);
            }
        }

        // æ˜¾ç¤ºåˆ†æç»“æœ
        function showAnalysisResult(analysisHtml) {
            // æ¸…é™¤ä¹‹å‰çš„ç»“æœï¼Œé¿å…é‡å¤
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = `
                <div class="result-title">ğŸ§  ä¸­åŒ»ç†è®ºåˆ†æç»“æœ</div>
                <div style="font-size: 13px;">${analysisHtml}</div>
            `;
            
            resultsDiv.appendChild(resultElement);
        }

        // æ˜¾ç¤ºé—æ¼é€»è¾‘ç»“æœ
        function showMissingLogicResult(data) {
            // æ¸…é™¤ä¹‹å‰çš„ç»“æœï¼Œé¿å…é‡å¤
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            let html = '<div class="result-title">ğŸ’¡ é—æ¼é€»è¾‘æ£€æµ‹ç»“æœ</div>';
            
            if (data.missing_analyses && data.missing_analyses.length > 0) {
                data.missing_analyses.forEach(analysis => {
                    html += `<div style="margin: 15px 0;"><strong>${analysis.category}:</strong><br>`;
                    analysis.items.forEach(item => {
                        html += `
                            <div class="suggestion-item" onclick="addSuggestionToTree('${item.suggested_addition.step_type}', '${item.content}', '${item.description}')">
                                <div class="suggestion-content">${item.content}</div>
                                <div class="suggestion-desc">${item.description}</div>
                            </div>
                        `;
                    });
                    html += `</div>`;
                });
            } else {
                html += '<div style="color: #22c55e;">âœ… å½“å‰å†³ç­–æ ‘é€»è¾‘å®Œæ•´ï¼Œæœªå‘ç°æ˜æ˜¾é—æ¼</div>';
            }
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = html;
            
            resultsDiv.appendChild(resultElement);
        }

        // æ¸…é™¤ç»“æœ
        function clearResults() {
            const resultsDiv = document.getElementById('analysisResults');
            resultsDiv.innerHTML = '';
        }

        // ç”»å¸ƒç‚¹å‡»äº‹ä»¶
        document.addEventListener('click', function(e) {
            if (e.target.id === 'canvas') {
                // æ¸…é™¤é€‰æ‹©
                document.querySelectorAll('.node').forEach(el => {
                    el.classList.remove('selected');
                });
                selectedNode = null;
            }
        });

        // ç»˜åˆ¶è¿æ¥çº¿
        function drawConnections() {
            const svg = document.getElementById('branchSvg');
            
            // æ¸…é™¤ç°æœ‰è¿æ¥çº¿
            const existingPaths = svg.querySelectorAll('.branch-line, .branch-path');
            existingPaths.forEach(path => path.remove());
            
            connections.forEach(conn => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);
                
                if (fromNode && toNode) {
                    const fromElement = document.getElementById(fromNode.id);
                    const toElement = document.getElementById(toNode.id);
                    
                    if (fromElement && toElement) {
                        const fromRect = fromElement.getBoundingClientRect();
                        const toRect = toElement.getBoundingClientRect();
                        const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                        
                        // è®¡ç®—è¿æ¥ç‚¹ä½ç½®
                        const x1 = fromRect.left - canvasRect.left + fromRect.width;
                        const y1 = fromRect.top - canvasRect.top + fromRect.height / 2;
                        const x2 = toRect.left - canvasRect.left;
                        const y2 = toRect.top - canvasRect.top + toRect.height / 2;
                        
                        // ä½¿ç”¨è´å¡å°”æ›²çº¿åˆ›å»ºå¹³æ»‘è¿æ¥
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const midX = (x1 + x2) / 2;
                        
                        // åˆ›å»ºå¹³æ»‘çš„æ›²çº¿è·¯å¾„
                        const d = `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`;
                        
                        path.setAttribute('d', d);
                        path.setAttribute('class', 'branch-path');
                        path.setAttribute('fill', 'none');
                        path.setAttribute('stroke', '#3b82f6');
                        path.setAttribute('stroke-width', '2');
                        path.setAttribute('marker-end', 'url(#arrowhead)');
                        
                        // æ·»åŠ è¿æ¥æ ‡ç­¾ï¼ˆå¦‚æœéœ€è¦ï¼‰
                        if (conn.label) {
                            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            text.setAttribute('x', midX);
                            text.setAttribute('y', (y1 + y2) / 2 - 10);
                            text.setAttribute('text-anchor', 'middle');
                            text.setAttribute('font-size', '12');
                            text.setAttribute('fill', '#6b7280');
                            text.textContent = conn.label;
                            svg.appendChild(text);
                        }
                        
                        svg.appendChild(path);
                    }
                }
            });
        }

        // æ˜¾ç¤ºé€‰ä¸­èŠ‚ç‚¹ä¿¡æ¯
        function showSelectedNodeInfo(node) {
            const infoDiv = document.getElementById('selectedNodeInfo');
            const contentDiv = document.getElementById('nodeInfoContent');
            
            contentDiv.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 8px;">${node.name}</div>
                <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">ç±»å‹: ${getNodeTypeText(node.type)}</div>
                <div style="font-size: 12px; color: #374151;">${node.description}</div>
                ${selectedNode ? '<div style="margin-top: 10px; font-size: 11px; color: #059669;">ğŸ’¡ ç‚¹å‡»é—æ¼é€»è¾‘æ£€æµ‹ç»“æœä¸­çš„å»ºè®®å¯æ·»åŠ åˆ°æ­¤èŠ‚ç‚¹</div>' : ''}
            `;
            
            infoDiv.style.display = 'block';
        }

        // éšè—é€‰ä¸­èŠ‚ç‚¹ä¿¡æ¯
        function hideSelectedNodeInfo() {
            const infoDiv = document.getElementById('selectedNodeInfo');
            infoDiv.style.display = 'none';
        }

        // è·å–èŠ‚ç‚¹ç±»å‹æ–‡æœ¬
        function getNodeTypeText(type) {
            const typeMap = {
                'symptom': 'ç—‡çŠ¶',
                'condition': 'åˆ¤æ–­æ¡ä»¶',
                'diagnosis': 'è¯Šæ–­',
                'treatment': 'æ²»ç–—',
                'formula': 'æ–¹å‰‚'
            };
            return typeMap[type] || type;
        }

        // æ·»åŠ å»ºè®®åˆ°å†³ç­–æ ‘ (æ”¯æŒå¼‚æ­¥æ•°æ®åº“æŸ¥è¯¢)
        async function addSuggestionToTree(nodeType, nodeName, description) {
            if (!selectedNode) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºæ·»åŠ ä½ç½®');
                return;
            }
            
            // æ™ºèƒ½ç—‡çŠ¶åˆå¹¶ï¼šæ£€æŸ¥æ˜¯å¦åº”è¯¥åˆå¹¶åˆ°ç°æœ‰ç—‡çŠ¶ç¾¤
            if (nodeType === 'symptom') {
                console.log(`å¼€å§‹æ™ºèƒ½ç—‡çŠ¶åˆ†æ: ${nodeName}`);
                const mergeTarget = await findSymptomMergeTarget(nodeName);
                if (mergeTarget) {
                    // ç»™ç”¨æˆ·ä¸€ä¸ªç¡®è®¤æç¤º
                    const isSelectedNode = mergeTarget === selectedNode;
                    const targetDescription = isSelectedNode ? 
                        `å½“å‰é€‰ä¸­çš„"${mergeTarget.name}"` : 
                        `ç°æœ‰çš„"${mergeTarget.name}"`;
                    
                    console.log(`å‡†å¤‡åˆå¹¶ç—‡çŠ¶"${nodeName}"åˆ°${targetDescription}èŠ‚ç‚¹`);
                    mergeSymptomToNode(mergeTarget, nodeName, description);
                    return;
                }
            }
            
            // å¦‚æœä¸éœ€è¦åˆå¹¶ï¼Œåˆ›å»ºæ–°çš„ç‹¬ç«‹èŠ‚ç‚¹
            const newX = selectedNode.x + 250;
            const newY = selectedNode.y + (Math.random() - 0.5) * 100; // ç¨å¾®éšæœºåç§»
            
            const newNode = {
                id: `suggested_${nodeCounter++}`,
                type: nodeType,
                name: nodeName,
                description: description,
                x: newX,
                y: newY
            };
            
            nodes.push(newNode);
            renderNode(newNode);
            
            // åˆ›å»ºè¿æ¥
            connections.push({
                from: selectedNode.id,
                to: newNode.id
            });
            
            drawConnections();
            updateCanvas();
            
            // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            showResult('æˆåŠŸ', `âœ… å·²æ·»åŠ "${nodeName}"åˆ°å†³ç­–æ ‘`, 'success');
        }

        // æ™ºèƒ½ç—‡çŠ¶åˆå¹¶ï¼šæŸ¥æ‰¾åº”è¯¥åˆå¹¶çš„ç›®æ ‡èŠ‚ç‚¹ (æ•°æ®åº“ç‰ˆæœ¬)
        async function findSymptomMergeTarget(newSymptom) {
            console.log(`\n=== æ™ºèƒ½ç—‡çŠ¶åˆå¹¶åˆ†æ ===`);
            console.log(`æ–°ç—‡çŠ¶: ${newSymptom}`);
            console.log(`å½“å‰é€‰ä¸­èŠ‚ç‚¹:`, selectedNode);
            console.log(`å½“å‰é€‰ä¸­èŠ‚ç‚¹çš„ç›¸å…³ç—‡çŠ¶:`, selectedNode?.relatedSymptoms);
            
            // ç¬¬ä¸€ä¼˜å…ˆçº§ï¼šå¦‚æœå½“å‰é€‰ä¸­çš„èŠ‚ç‚¹æ˜¯ç—‡çŠ¶ç±»å‹ï¼Œä¼˜å…ˆæ£€æŸ¥æ•°æ®åº“å…³ç³»
            if (selectedNode && selectedNode.type === 'symptom') {
                console.log(`æ£€æŸ¥é€‰ä¸­èŠ‚ç‚¹ä¸æ–°ç—‡çŠ¶çš„æ•°æ®åº“å…³ç³»...`);
                
                try {
                    // è°ƒç”¨ç—‡çŠ¶å…³ç³»æ•°æ®åº“API
                    const response = await fetch(`/api/symptom/quick_analyze/${encodeURIComponent(selectedNode.name)}`);
                    const data = await response.json();
                    
                    if (data.success) {
                        const allRelatedSymptoms = [
                            ...data.data.related_symptoms,
                            ...data.data.accompanying_symptoms
                        ];
                        
                        console.log(`æ•°æ®åº“æŸ¥è¯¢æˆåŠŸï¼Œæ‰¾åˆ°ç›¸å…³ç—‡çŠ¶:`, allRelatedSymptoms);
                        
                        if (allRelatedSymptoms.includes(newSymptom)) {
                            console.log(`âœ… æ•°æ®åº“ç¡®è®¤å…³ç³»ï¼Œä¼˜å…ˆåˆå¹¶åˆ°é€‰ä¸­èŠ‚ç‚¹: ${newSymptom} -> ${selectedNode.name}`);
                            return selectedNode;
                        }
                        
                        // æ£€æŸ¥æ¨¡ç³ŠåŒ¹é…
                        const fuzzyMatch = allRelatedSymptoms.find(symptom => 
                            symptom.includes(newSymptom) || newSymptom.includes(symptom)
                        );
                        if (fuzzyMatch) {
                            console.log(`âœ… æ•°æ®åº“æ¨¡ç³ŠåŒ¹é…æˆåŠŸ: ${newSymptom} â‰ˆ ${fuzzyMatch} -> ${selectedNode.name}`);
                            return selectedNode;
                        }
                    }
                } catch (error) {
                    console.warn(`æ•°æ®åº“æŸ¥è¯¢å¤±è´¥ï¼Œå›é€€åˆ°æœ¬åœ°é€»è¾‘:`, error);
                }
                
                // å›é€€åˆ°åŸæœ‰çš„æœ¬åœ°å…³ç³»æ£€æŸ¥
                if (isSymptomRelated(selectedNode.name, newSymptom)) {
                    console.log(`âœ… æœ¬åœ°å…³ç³»æ£€æŸ¥é€šè¿‡ï¼Œåˆå¹¶åˆ°é€‰ä¸­èŠ‚ç‚¹: ${newSymptom} -> ${selectedNode.name}`);
                    return selectedNode;
                }
                
                console.log(`âŒ é€‰ä¸­èŠ‚ç‚¹ä¸æ–°ç—‡çŠ¶ä¸ç›¸å…³`);
            }
            
            // ç¬¬äºŒä¼˜å…ˆçº§ï¼šæŸ¥æ‰¾å…¶ä»–ç°æœ‰ç—‡çŠ¶èŠ‚ç‚¹çš„æ•°æ®åº“å…³ç³»
            console.log(`æ£€æŸ¥å…¶ä»–ç—‡çŠ¶èŠ‚ç‚¹çš„æ•°æ®åº“å…³ç³»...`);
            const existingSymptomNodes = nodes.filter(node => 
                node.type === 'symptom' && node !== selectedNode
            );
            
            for (const node of existingSymptomNodes) {
                try {
                    const response = await fetch(`/api/symptom/quick_analyze/${encodeURIComponent(node.name)}`);
                    const data = await response.json();
                    
                    if (data.success) {
                        const allRelatedSymptoms = [
                            ...data.data.related_symptoms,
                            ...data.data.accompanying_symptoms
                        ];
                        
                        if (allRelatedSymptoms.includes(newSymptom)) {
                            console.log(`âœ… æ•°æ®åº“æ‰¾åˆ°åˆå¹¶ç›®æ ‡: ${newSymptom} -> ${node.name}`);
                            return node;
                        }
                    }
                } catch (error) {
                    console.warn(`èŠ‚ç‚¹ ${node.name} æ•°æ®åº“æŸ¥è¯¢å¤±è´¥:`, error);
                    // ç»§ç»­ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
                }
                
                // æœ¬åœ°å…³ç³»æ£€æŸ¥ä½œä¸ºåå¤‡
                if (isSymptomRelated(node.name, newSymptom)) {
                    console.log(`âœ… æœ¬åœ°å…³ç³»æ‰¾åˆ°åˆå¹¶ç›®æ ‡: ${newSymptom} -> ${node.name}`);
                    return node;
                }
            }
            
            console.log(`âŒ æœªæ‰¾åˆ°ä»»ä½•åˆå¹¶ç›®æ ‡ï¼Œå°†åˆ›å»ºæ–°èŠ‚ç‚¹: ${newSymptom}`);
            return null; // æ²¡æ‰¾åˆ°åˆå¹¶ç›®æ ‡ï¼Œéœ€è¦åˆ›å»ºæ–°èŠ‚ç‚¹
        }

        // åˆ¤æ–­ä¸¤ä¸ªç—‡çŠ¶æ˜¯å¦ç›¸å…³
        function isSymptomRelated(existingSymptom, newSymptom) {
            console.log(`  æ£€æŸ¥ç—‡çŠ¶å…³è”æ€§: "${existingSymptom}" vs "${newSymptom}"`);
            
            const relationshipMap = {
                'å¤±çœ ': ['æ—©é†’', 'å¤šæ¢¦', 'å…¥ç¡å›°éš¾', 'ç¡çœ æµ…', 'æ˜“æƒŠé†’', 'å¤œé†’', 'å¿ƒçƒ¦', 'å¥å¿˜', 'å¤´æ™•', 'ç–²ä¹', 'ç²¾ç¥ä¸æŒ¯'],
                'å¤´ç—›': ['å¤´èƒ€', 'å¤´æ™•', 'åå¤´ç—›', 'å¤ªé˜³ç©´ç—›', 'åè„‘ç—›', 'é¢ˆé¡¹å¼ºç›´', 'æ¶å¿ƒ'],
                'èƒƒç—›': ['èƒƒèƒ€', 'èƒƒé…¸', 'åé…¸', 'å—³æ°”', 'èƒƒè„˜ç—›', 'èƒƒéƒ¨ä¸é€‚', 'é£Ÿæ¬²ä¸æŒ¯', 'æ¶å¿ƒ', 'å‘•å'],
                'ä¾¿ç§˜': ['å¤§ä¾¿å¹²ç‡¥', 'æ’ä¾¿å›°éš¾', 'å¤§ä¾¿å¹²ç»“', 'ä¾¿å¹²å¦‚æ —', 'è…¹èƒ€', 'å£å¹²'],
                'è…¹æ³»': ['ä¾¿æº', 'æ³„æ³»', 'æ°´æ³»', 'å¤§ä¾¿ç¨€è–„', 'è…¹ç—›', 'è‚ é¸£', 'é‡Œæ€¥åé‡'],
                'å’³å—½': ['å’³ç—°', 'å¹²å’³', 'å’³å–˜', 'ç—°å¤š', 'å–‰ç—’', 'èƒ¸é—·', 'æ°”çŸ­']
            };
            
            // æ£€æŸ¥åŒå‘å…³ç³»
            for (const [mainSymptom, relatedList] of Object.entries(relationshipMap)) {
                const condition1 = existingSymptom.includes(mainSymptom) && relatedList.includes(newSymptom);
                const condition2 = newSymptom.includes(mainSymptom) && relatedList.includes(existingSymptom);
                
                if (condition1 || condition2) {
                    console.log(`    âœ… æ‰¾åˆ°å…³è”: ${mainSymptom} -> [${relatedList.join(', ')}]`);
                    console.log(`    æ¡ä»¶1 (${existingSymptom} åŒ…å« ${mainSymptom} ä¸” ${newSymptom} åœ¨åˆ—è¡¨ä¸­): ${condition1}`);
                    console.log(`    æ¡ä»¶2 (${newSymptom} åŒ…å« ${mainSymptom} ä¸” ${existingSymptom} åœ¨åˆ—è¡¨ä¸­): ${condition2}`);
                    return true;
                }
            }
            
            console.log(`    âŒ æœªæ‰¾åˆ°å…³è”å…³ç³»`);
            return false;
        }

        // å°†ç—‡çŠ¶åˆå¹¶åˆ°ç°æœ‰èŠ‚ç‚¹
        function mergeSymptomToNode(targetNode, newSymptom, description) {
            console.log(`å¼€å§‹åˆå¹¶ç—‡çŠ¶: ${newSymptom} -> ${targetNode.name}`);
            
            // æ›´æ–°èŠ‚ç‚¹å†…å®¹ï¼Œå°†æ–°ç—‡çŠ¶æ·»åŠ åˆ°æè¿°ä¸­
            if (!targetNode.relatedSymptoms) {
                targetNode.relatedSymptoms = [];
            }
            
            // é¿å…é‡å¤æ·»åŠ 
            if (!targetNode.relatedSymptoms.includes(newSymptom)) {
                targetNode.relatedSymptoms.push(newSymptom);
                
                console.log(`ç—‡çŠ¶åˆå¹¶æˆåŠŸï¼Œå½“å‰ç›¸å…³ç—‡çŠ¶:`, targetNode.relatedSymptoms);
                
                // æ›´æ–°èŠ‚ç‚¹æ˜¾ç¤º
                updateNodeDisplay(targetNode);
                
                // æ˜¾ç¤ºåˆå¹¶æˆåŠŸæ¶ˆæ¯ï¼ŒåŒºåˆ†æ˜¯å¦ä¸ºé€‰ä¸­èŠ‚ç‚¹
                const isSelectedNode = targetNode === selectedNode;
                const message = isSelectedNode ? 
                    `âœ… å·²å°†"${newSymptom}"åˆå¹¶åˆ°æ‚¨é€‰ä¸­çš„"${targetNode.name}"ç—‡çŠ¶ç¾¤` :
                    `âœ… å·²å°†"${newSymptom}"åˆå¹¶åˆ°ç›¸å…³çš„"${targetNode.name}"ç—‡çŠ¶ç¾¤`;
                showResult('æˆåŠŸ', message, 'success');
                
                console.log(`èŠ‚ç‚¹æ˜¾ç¤ºæ›´æ–°å®Œæˆï¼Œç›®æ ‡èŠ‚ç‚¹:`, targetNode);
            } else {
                showResult('æç¤º', `"${newSymptom}"å·²å­˜åœ¨äº"${targetNode.name}"ç—‡çŠ¶ç¾¤ä¸­`, 'info');
            }
        }

        // æ›´æ–°èŠ‚ç‚¹æ˜¾ç¤ºä»¥æ˜¾ç¤ºç›¸å…³ç—‡çŠ¶
        function updateNodeDisplay(node) {
            const nodeElement = document.getElementById(node.id);
            if (!nodeElement) return;
            
            const contentDiv = nodeElement.querySelector('.node-content');
            if (!contentDiv) return;
            
            // ä½¿ç”¨ä¸renderNodeç›¸åŒçš„é€»è¾‘
            let nodeContent = node.description || '';
            if (node.relatedSymptoms && node.relatedSymptoms.length > 0) {
                nodeContent = `${nodeContent}
                    <div class="related-symptoms">
                        <div class="symptoms-label">ç›¸å…³ç—‡çŠ¶:</div>
                        <div class="symptoms-list">${node.relatedSymptoms.join(', ')}</div>
                    </div>`;
            }
            
            contentDiv.innerHTML = nodeContent;
            
            // å…³é”®ä¿®å¤ï¼šç¡®ä¿ä¼ é€’çš„æ˜¯nodesæ•°ç»„ä¸­çš„å®é™…èŠ‚ç‚¹å¯¹è±¡
            const actualNode = nodes.find(n => n.id === node.id);
            if (actualNode) {
                ensureNodeEditability(nodeElement, actualNode);
            } else {
                // ä½œä¸ºåå¤‡ï¼Œä½¿ç”¨ä¼ å…¥çš„nodeå¯¹è±¡
                ensureNodeEditability(nodeElement, node);
            }
        }
        
        // ç¡®ä¿èŠ‚ç‚¹å…·æœ‰ç¼–è¾‘åŠŸèƒ½ï¼ˆé˜²å¾¡æ€§ç¼–ç¨‹ï¼‰
        function ensureNodeEditability(nodeElement, node) {
            // ç§»é™¤æ—§çš„åŒå‡»äº‹ä»¶ç›‘å¬å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            const existingHandler = nodeElement._editHandler;
            if (existingHandler) {
                nodeElement.removeEventListener('dblclick', existingHandler);
            }
            
            // åˆ›å»ºæ–°çš„äº‹ä»¶å¤„ç†å‡½æ•°
            const newHandler = function(e) {
                e.stopPropagation();
                e.preventDefault();
                // ç›´æ¥æŸ¥æ‰¾æœ€æ–°çš„èŠ‚ç‚¹æ•°æ®
                const currentNode = nodes.find(n => n.id === node.id) || node;
                editNodeContent(currentNode);
            };
            
            // ä¿å­˜äº‹ä»¶å¤„ç†å™¨å¼•ç”¨ä»¥ä¾¿åç»­ç§»é™¤
            nodeElement._editHandler = newHandler;
            
            // æ·»åŠ åŒå‡»ç¼–è¾‘åŠŸèƒ½
            nodeElement.addEventListener('dblclick', newHandler);
            
            // æ ‡è®°ä¸ºå·²ç»‘å®šç¼–è¾‘äº‹ä»¶
            nodeElement.setAttribute('data-editable', 'true');
        }

        // æ›´æ–°èŠ‚ç‚¹æ‹–æ‹½åé‡ç»˜è¿æ¥çº¿
        function updateNodePosition(node) {
            const element = document.getElementById(node.id);
            if (element) {
                element.style.left = `${node.x}px`;
                element.style.top = `${node.y}px`;
                
                // é‡ç»˜è¿æ¥çº¿
                setTimeout(drawConnections, 10);
            }
        }

        // åˆ é™¤èŠ‚ç‚¹
        function deleteNodeById(nodeId) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªèŠ‚ç‚¹å—ï¼Ÿ')) {
                // ä»æ•°ç»„ä¸­ç§»é™¤èŠ‚ç‚¹
                nodes = nodes.filter(node => node.id !== nodeId);
                
                // ç§»é™¤ç›¸å…³è¿æ¥
                connections = connections.filter(conn => 
                    conn.from !== nodeId && conn.to !== nodeId
                );
                
                // ä»DOMä¸­ç§»é™¤èŠ‚ç‚¹
                const element = document.getElementById(nodeId);
                if (element) {
                    element.remove();
                }
                
                // å¦‚æœåˆ é™¤çš„æ˜¯é€‰ä¸­èŠ‚ç‚¹ï¼Œæ¸…é™¤é€‰æ‹©
                if (selectedNode && selectedNode.id === nodeId) {
                    selectedNode = null;
                    hideSelectedNodeInfo();
                }
                
                // é‡ç»˜è¿æ¥çº¿
                drawConnections();
                updateCanvas();
                
                showResult('æˆåŠŸ', 'âœ… èŠ‚ç‚¹å·²åˆ é™¤', 'success');
            }
        }
        
        // æ·»åŠ åˆ†æ”¯èŠ‚ç‚¹ï¼ˆæ”¯æŒå¤šåˆ†æ”¯è¯Šæ–­ï¼‰
        function addBranchNode(parentNode) {
            const nodeType = getNextNodeType(parentNode.type);
            const newNode = {
                id: `branch_${nodeCounter++}`,
                type: nodeType,
                name: getDefaultNodeName(nodeType),
                description: '',
                x: parentNode.x + 200,
                y: parentNode.y + 150
            };
            
            nodes.push(newNode);
            renderNode(newNode);
            
            // åˆ›å»ºè¿æ¥
            connections.push({
                from: parentNode.id,
                to: newNode.id
            });
            
            drawConnections();
            updateCanvas();
            
            // è‡ªåŠ¨é€‰ä¸­æ–°èŠ‚ç‚¹ä»¥ä¾¿ç¼–è¾‘
            selectNode(newNode);
            editNodeContent(newNode);
        }
        
        // æ·»åŠ å­èŠ‚ç‚¹ï¼ˆé¡ºåºæµç¨‹ï¼‰
        function addChildNode(parentNode) {
            const nodeType = getNextNodeType(parentNode.type);
            const newNode = {
                id: `child_${nodeCounter++}`,
                type: nodeType,
                name: getDefaultNodeName(nodeType),
                description: '',
                x: parentNode.x + 250,
                y: parentNode.y
            };
            
            nodes.push(newNode);
            renderNode(newNode);
            
            // åˆ›å»ºè¿æ¥
            connections.push({
                from: parentNode.id,
                to: newNode.id
            });
            
            drawConnections();
            updateCanvas();
            
            // è‡ªåŠ¨é€‰ä¸­æ–°èŠ‚ç‚¹ä»¥ä¾¿ç¼–è¾‘
            selectNode(newNode);
            editNodeContent(newNode);
        }
        
        // æ·»åŠ è¯å€™åˆ†å‹ï¼ˆæ”¯æŒå¤šç§è¯å‹ï¼‰
        function addSyndromeTypes(syndromeNode) {
            const syndromeTypes = [
                { name: 'è¯å‹1', desc: 'è¯·ç¼–è¾‘è¯å‹åç§°å’Œæè¿°' },
                { name: 'è¯å‹2', desc: 'è¯·ç¼–è¾‘è¯å‹åç§°å’Œæè¿°' }
            ];
            
            syndromeTypes.forEach((type, index) => {
                const newNode = {
                    id: `syndrome_type_${nodeCounter++}`,
                    type: 'syndrome',
                    name: type.name,
                    description: type.desc,
                    x: syndromeNode.x + 200,
                    y: syndromeNode.y + (index - 0.5) * 120
                };
                
                nodes.push(newNode);
                renderNode(newNode);
                
                connections.push({
                    from: syndromeNode.id,
                    to: newNode.id
                });
            });
            
            drawConnections();
            updateCanvas();
            showResult('æˆåŠŸ', 'âœ… å·²æ·»åŠ è¯å€™åˆ†å‹æ¨¡æ¿ï¼Œè¯·ç¼–è¾‘å…·ä½“å†…å®¹', 'success');
        }
        
        // ç¼–è¾‘èŠ‚ç‚¹ï¼ˆå¢å¼ºç‰ˆï¼‰
        function editNode(node) {
            // åˆ›å»ºç¼–è¾‘å¯¹è¯æ¡†
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.2);
                z-index: 10000;
                width: 400px;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-bottom: 15px;">ç¼–è¾‘èŠ‚ç‚¹</h3>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px;">èŠ‚ç‚¹åç§°:</label>
                    <input type="text" id="editNodeName" value="${node.name}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px;">èŠ‚ç‚¹ç±»å‹:</label>
                    <select id="editNodeType" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <option value="disease" ${node.type === 'disease' ? 'selected' : ''}>ç—…ç§</option>
                        <option value="four_diagnosis" ${node.type === 'four_diagnosis' ? 'selected' : ''}>å››è¯Šä¿¡æ¯</option>
                        <option value="symptom" ${node.type === 'symptom' ? 'selected' : ''}>ä¸»è¦ç—‡çŠ¶</option>
                        <option value="pathogenesis" ${node.type === 'pathogenesis' ? 'selected' : ''}>ç—…å› ç—…æœº</option>
                        <option value="syndrome" ${node.type === 'syndrome' ? 'selected' : ''}>è¯å€™åˆ¤æ–­</option>
                        <option value="principle" ${node.type === 'principle' ? 'selected' : ''}>æ²»åˆ™æ²»æ³•</option>
                        <option value="prescription" ${node.type === 'prescription' ? 'selected' : ''}>æ–¹å‰‚å¤„æ–¹</option>
                        <option value="modification" ${node.type === 'modification' ? 'selected' : ''}>éšç—‡åŠ å‡</option>
                        <option value="prognosis" ${node.type === 'prognosis' ? 'selected' : ''}>é¢„åè°ƒç†</option>
                    </select>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px;">è¯¦ç»†æè¿°:</label>
                    <textarea id="editNodeDesc" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; min-height: 80px;">${node.description || ''}</textarea>
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="this.parentElement.parentElement.remove()" style="padding: 8px 16px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">å–æ¶ˆ</button>
                    <button id="saveNodeEdit" style="padding: 8px 16px; border: none; background: #3b82f6; color: white; border-radius: 4px; cursor: pointer;">ä¿å­˜</button>
                </div>
            `;
            
            document.body.appendChild(dialog);
            
            // ä¿å­˜ç¼–è¾‘
            document.getElementById('saveNodeEdit').onclick = function() {
                node.name = document.getElementById('editNodeName').value;
                node.type = document.getElementById('editNodeType').value;
                node.description = document.getElementById('editNodeDesc').value;
                
                // æ›´æ–°æ˜¾ç¤º
                const nodeElement = document.getElementById(node.id);
                nodeElement.className = `node ${node.type}`;
                updateNodeDisplay(node);
                
                dialog.remove();
                showResult('æˆåŠŸ', 'âœ… èŠ‚ç‚¹å·²æ›´æ–°', 'success');
            };
        }
        
        // è·å–ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„é»˜è®¤ç±»å‹
        function getNextNodeType(currentType) {
            const typeFlow = {
                'disease': 'four_diagnosis',
                'four_diagnosis': 'symptom',
                'symptom': 'pathogenesis',
                'pathogenesis': 'syndrome',
                'syndrome': 'principle',
                'principle': 'prescription',
                'prescription': 'modification',
                'modification': 'prognosis'
            };
            return typeFlow[currentType] || 'symptom';
        }
        
        // è·å–èŠ‚ç‚¹é»˜è®¤åç§°
        function getDefaultNodeName(nodeType) {
            const defaultNames = {
                'disease': 'ç—…ç§åç§°',
                'four_diagnosis': 'å››è¯Šä¿¡æ¯',
                'symptom': 'ä¸»è¦ç—‡çŠ¶',
                'pathogenesis': 'ç—…å› ç—…æœº',
                'syndrome': 'è¯å€™ç±»å‹',
                'principle': 'æ²»åˆ™æ²»æ³•',
                'prescription': 'æ–¹å‰‚åç§°',
                'modification': 'åŠ å‡æ–¹æ¡ˆ',
                'prognosis': 'é¢„åå»ºè®®'
            };
            return defaultNames[nodeType] || 'æ–°èŠ‚ç‚¹';
        }

        // æ˜¾ç¤ºå³é”®èœå•
        function showContextMenu(e, node) {
            hideContextMenu();
            
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.id = 'contextMenu';
            menu.style.left = `${e.clientX}px`;
            menu.style.top = `${e.clientY}px`;
            
            const menuItems = [
                { text: 'ğŸ” åˆ†ææ­¤èŠ‚ç‚¹', action: () => analyzeSelectedNode(node) },
                { text: 'ğŸ“ ç¼–è¾‘èŠ‚ç‚¹', action: () => editNode(node) },
                { text: 'â• æ·»åŠ å­èŠ‚ç‚¹', action: () => addChildNode(node) },
                { text: 'ğŸŒ¿ æ·»åŠ åˆ†æ”¯', action: () => addBranchNode(node) }
            ];
            
            if (node.type === 'prescription') {
                menuItems.push({ text: 'ğŸ’Š AIæ–¹å‰‚åˆ†æ', action: () => analyzeFormulaNode(node) });
            }
            
            if (node.type === 'syndrome') {
                menuItems.push({ text: 'ğŸ“‹ æ·»åŠ è¯å€™åˆ†å‹', action: () => addSyndromeTypes(node) });
            }
            
            menuItems.push({ text: 'ğŸ—‘ï¸ åˆ é™¤èŠ‚ç‚¹', action: () => deleteNodeById(node.id), danger: true });
            
            menuItems.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.className = `context-menu-item ${item.danger ? 'danger' : ''}`;
                menuItem.innerHTML = item.text;
                menuItem.onclick = () => {
                    item.action();
                    hideContextMenu();
                };
                menu.appendChild(menuItem);
            });
            
            document.body.appendChild(menu);
        }

        // éšè—å³é”®èœå•
        function hideContextMenu() {
            const menu = document.getElementById('contextMenu');
            if (menu) {
                menu.remove();
            }
        }

        // ç—‡çŠ¶é—æ¼æ£€æµ‹
        async function detectMissingSymptoms() {
            console.log('ç—‡çŠ¶é—æ¼æ£€æµ‹è¢«è°ƒç”¨');
            
            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            if (!getCurrentDiseaseName()) {
                alert('è¯·å…ˆè¾“å…¥ç–¾ç—…åç§°');
                return;
            }

            // æ”¶é›†ç°æœ‰ç—‡çŠ¶èŠ‚ç‚¹
            const symptomNodes = nodes.filter(node => node.type === 'symptom');
            const existingSymptoms = symptomNodes.map(node => node.name);
            
            showLoading('æ­£åœ¨æ£€æµ‹ç—‡çŠ¶é—æ¼...');

            try {
                // ä½¿ç”¨ç°æœ‰çš„APIï¼Œä½†ä¸“æ³¨äºç—‡çŠ¶æ£€æµ‹
                const response = await fetch('/api/detect_missing_logic', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        disease_name: getCurrentDiseaseName(),
                        current_paths: [],
                        existing_nodes: nodes.filter(node => node.type === 'symptom')
                    })
                });

                const data = await response.json();
                
                if (data.success && data.data) {
                    hideLoading();
                    showSymptomDetectionResult(data.data, existingSymptoms);
                } else {
                    throw new Error(data.message || 'æ£€æµ‹å¤±è´¥');
                }
            } catch (error) {
                console.error('ç—‡çŠ¶é—æ¼æ£€æµ‹å¤±è´¥:', error);
                hideLoading();
                showResult('é”™è¯¯', `âŒ æ£€æµ‹å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ˜¾ç¤ºç—‡çŠ¶æ£€æµ‹ç»“æœ
        function showSymptomDetectionResult(data, existingSymptoms) {
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            // ç”Ÿæˆå¸¸è§ç—‡çŠ¶å»ºè®®
            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            const commonSymptoms = getCommonSymptomsForDisease(getCurrentDiseaseName());
            const missingSymptoms = commonSymptoms.filter(symptom => 
                !existingSymptoms.some(existing => existing.includes(symptom))
            );
            
            let html = '<div class="result-title">ğŸ” ç—‡çŠ¶é—æ¼æ£€æµ‹ç»“æœ</div>';
            
            if (missingSymptoms.length > 0) {
                html += '<div style="margin: 15px 0;"><strong>å»ºè®®è¡¥å……çš„ç—‡çŠ¶:</strong><br>';
                missingSymptoms.forEach(symptom => {
                    html += `
                        <div class="suggestion-item" onclick="addSuggestionToTree('symptom', '${symptom}', '${getCurrentDiseaseName()}çš„å¸¸è§ç—‡çŠ¶')">
                            <div class="suggestion-content">${symptom}</div>
                            <div class="suggestion-desc">${getCurrentDiseaseName()}çš„å¸¸è§ç—‡çŠ¶è¡¨ç°</div>
                        </div>
                    `;
                });
                html += '</div>';
            } else {
                html += '<div style="color: #22c55e;">âœ… ç—‡çŠ¶è¦†ç›–è¾ƒä¸ºå®Œæ•´</div>';
            }
            
            // æ·»åŠ ç°æœ‰ç—‡çŠ¶åˆ†æ
            if (existingSymptoms.length > 0) {
                html += '<div style="margin: 15px 0;"><strong>ç°æœ‰ç—‡çŠ¶:</strong><br>';
                html += `<div style="font-size: 12px; color: #6b7280;">${existingSymptoms.join('ã€')}</div></div>`;
            }
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = html;
            
            resultsDiv.appendChild(resultElement);
        }

        // è·å–ç–¾ç—…å¸¸è§ç—‡çŠ¶
        function getCommonSymptomsForDisease(diseaseName) {
            const symptomDatabase = {
                'å¤±çœ ': ['éš¾ä»¥å…¥ç¡', 'æ—©é†’', 'å¤šæ¢¦', 'ç¡çœ æµ…', 'å¿ƒçƒ¦', 'å¥å¿˜', 'å¤´æ™•', 'ç–²ä¹'],
                'èƒƒç—›': ['èƒƒè„˜ç–¼ç—›', 'èƒƒèƒ€', 'åé…¸', 'å—³æ°”', 'æ¶å¿ƒ', 'é£Ÿæ¬²ä¸æŒ¯', 'è…¹èƒ€', 'ä¾¿ç§˜'],
                'å¤´ç—›': ['å¤´éƒ¨ç–¼ç—›', 'çœ©æ™•', 'æ¶å¿ƒå‘•å', 'ç•å…‰', 'é¢ˆé¡¹å¼ºç›´', 'è€³é¸£', 'è§†ç‰©æ¨¡ç³Š'],
                'å’³å—½': ['å¹²å’³', 'å’³ç—°', 'æ°”çŸ­', 'èƒ¸é—·', 'å’½ç—’', 'å£°å˜¶', 'å‘çƒ­', 'ä¹åŠ›'],
                'è…¹æ³»': ['å¤§ä¾¿ç¨€æº', 'è…¹ç—›', 'è…¹èƒ€', 'è‚ é¸£', 'é‡Œæ€¥åé‡', 'å‘çƒ­', 'æ¶å¿ƒ', 'é£Ÿæ¬²å‡é€€']
            };
            
            return symptomDatabase[diseaseName] || ['ç›¸å…³ç—‡çŠ¶1', 'ç›¸å…³ç—‡çŠ¶2', 'ç›¸å…³ç—‡çŠ¶3'];
        }

        // æ–¹å‰‚AIåˆ†æ
        async function analyzeFormula() {
            console.log('æ–¹å‰‚AIåˆ†æè¢«è°ƒç”¨');
            
            const formulaNodes = nodes.filter(node => node.type === 'formula');
            if (formulaNodes.length === 0) {
                alert('è¯·å…ˆæ·»åŠ æ–¹å‰‚èŠ‚ç‚¹');
                return;
            }

            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            if (!getCurrentDiseaseName()) {
                alert('è¯·å…ˆè¾“å…¥ç–¾ç—…åç§°');
                return;
            }

            showLoading('æ­£åœ¨è¿›è¡ŒAIæ–¹å‰‚åˆ†æ...');

            try {
                const response = await fetch('/api/analyze_formula_composition', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        disease_name: getCurrentDiseaseName(),
                        formulas: formulaNodes.map(node => ({
                            name: node.name,
                            description: node.description
                        })),
                        patient_symptoms: nodes.filter(n => n.type === 'symptom').map(n => n.name)
                    })
                });

                const data = await response.json();
                
                if (data.success) {
                    hideLoading();
                    showFormulaAnalysisResult(data.data || {});
                } else {
                    // å¦‚æœAPIä¸å­˜åœ¨ï¼Œä½¿ç”¨æœ¬åœ°åˆ†æ
                    hideLoading();
                    showLocalFormulaAnalysis(formulaNodes, getCurrentDiseaseName());
                }
            } catch (error) {
                console.error('æ–¹å‰‚åˆ†æå¤±è´¥:', error);
                hideLoading();
                // ä½¿ç”¨æœ¬åœ°åˆ†æä½œä¸ºåå¤‡
                showLocalFormulaAnalysis(formulaNodes, getCurrentDiseaseName());
            }
        }

        // æœ¬åœ°æ–¹å‰‚åˆ†æ
        function showLocalFormulaAnalysis(formulaNodes, diseaseName) {
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            let html = '<div class="result-title">ğŸ’Š æ–¹å‰‚AIåˆ†æç»“æœ</div>';
            
            formulaNodes.forEach(formulaNode => {
                const analysis = analyzeFormulaLocally(formulaNode.name, getCurrentDiseaseName());
                html += `
                    <div class="formula-analysis-panel">
                        <div style="font-weight: 600; margin-bottom: 10px;">ğŸ“‹ ${formulaNode.name}</div>
                        <div style="margin-bottom: 10px;">
                            <strong>å»ºè®®è¯æç»„æˆ:</strong><br>
                            <div style="margin-top: 5px;">
                                ${analysis.herbs.map(herb => 
                                    `<span class="herb-item" onclick="addHerbToFormula('${formulaNode.id}', '${herb.name}', '${herb.dosage}')" title="ç‚¹å‡»æ·»åŠ åˆ°æ–¹å‰‚">${herb.name} ${herb.dosage}</span>`
                                ).join('')}
                            </div>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <strong>åŠ å‡å»ºè®®:</strong><br>
                            <div style="font-size: 12px; color: #059669;">${analysis.modifications}</div>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <strong>åŠŸæ•ˆ:</strong><br>
                            <div style="font-size: 12px; color: #6b7280;">${analysis.effects}</div>
                        </div>
                        <button class="apply-formula-btn" onclick="applyFullFormulaToNode('${formulaNode.id}', '${JSON.stringify(analysis.herbs).replace(/"/g, "&quot;")}')">
                            âœ¨ åº”ç”¨å®Œæ•´æ–¹å‰‚
                        </button>
                    </div>
                `;
            });
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = html;
            
            resultsDiv.appendChild(resultElement);
        }

        // å®Œæ•´çš„æ–¹å‰‚æ•°æ®åº“ï¼ŒåŒ…å«å…·ä½“è¯æä¿¡æ¯
        function analyzeFormulaLocally(formulaName, diseaseName) {
            const formulaDatabase = {
                'é€é¥æ•£': {
                    herbs: [
                        { name: 'æŸ´èƒ¡', dosage: '10g' },
                        { name: 'å½“å½’', dosage: '10g' },
                        { name: 'ç™½èŠ', dosage: '10g' },
                        { name: 'ç™½æœ¯', dosage: '10g' },
                        { name: 'èŒ¯è‹“', dosage: '15g' },
                        { name: 'ç‚™ç”˜è‰', dosage: '6g' },
                        { name: 'è–„è·', dosage: '6g' },
                        { name: 'ç”Ÿå§œ', dosage: '3ç‰‡' }
                    ],
                    effects: 'ç–è‚è§£éƒï¼Œå¥è„¾å…»è¡€',
                    modifications: 'è‚éƒé‡è€…åŠ é¦™é™„12gï¼Œéƒé‡‘10gï¼›è„¾è™šé‡è€…åŠ å…šå‚12g'
                },
                'ç”˜éº¦å¤§æ£æ±¤': {
                    herbs: [
                        { name: 'æ·®å°éº¦', dosage: '30g' },
                        { name: 'ç‚™ç”˜è‰', dosage: '10g' },
                        { name: 'å¤§æ£', dosage: '10æš' }
                    ],
                    effects: 'å…»å¿ƒå®‰ç¥ï¼Œç¼“æ€¥æ­¢ç—›',
                    modifications: 'å¿ƒç¥ä¸å®‰é‡è€…åŠ é…¸æ£ä»15gï¼Œè¿œå¿—10g'
                },
                'é€é¥æ•£åˆç”˜éº¦å¤§æ£æ±¤': {
                    herbs: [
                        { name: 'æŸ´èƒ¡', dosage: '10g' },
                        { name: 'å½“å½’', dosage: '10g' },
                        { name: 'ç™½èŠ', dosage: '10g' },
                        { name: 'ç™½æœ¯', dosage: '10g' },
                        { name: 'èŒ¯è‹“', dosage: '15g' },
                        { name: 'ç‚™ç”˜è‰', dosage: '10g' },
                        { name: 'è–„è·', dosage: '6g' },
                        { name: 'ç”Ÿå§œ', dosage: '3ç‰‡' },
                        { name: 'æ·®å°éº¦', dosage: '30g' },
                        { name: 'å¤§æ£', dosage: '10æš' }
                    ],
                    effects: 'ç–è‚è§£éƒï¼Œå¥è„¾å…»è¡€ï¼Œå…»å¿ƒå®‰ç¥',
                    modifications: 'æƒ…å¿—æŠ‘éƒé‡è€…åŠ åˆæ¬¢çš®12gï¼›å¿ƒç¥ä¸å®‰é‡è€…åŠ é…¸æ£ä»15gï¼Œé¾™éª¨20g'
                },
                'é»„è¿é˜¿èƒ¶æ±¤': {
                    herbs: [
                        { name: 'é»„è¿', dosage: '6g' },
                        { name: 'é˜¿èƒ¶', dosage: '9g' },
                        { name: 'é»„èŠ©', dosage: '6g' },
                        { name: 'ç™½èŠ', dosage: '9g' },
                        { name: 'é¸¡å­é»„', dosage: '2æš' }
                    ],
                    effects: 'æ¸…å¿ƒç«ï¼Œå…»å¿ƒé˜´ï¼Œå®‰ç¥å¿—',
                    modifications: 'å¿ƒç«åç››åŠ æ €å­6gï¼›é˜´è™šæ˜æ˜¾åŠ éº¦å†¬12g'
                },
                'å½’è„¾æ±¤': {
                    herbs: [
                        { name: 'å…šå‚', dosage: '12g' },
                        { name: 'ç™½æœ¯', dosage: '10g' },
                        { name: 'èŒ¯è‹“', dosage: '12g' },
                        { name: 'å½“å½’', dosage: '9g' },
                        { name: 'é¾™çœ¼è‚‰', dosage: '12g' },
                        { name: 'é…¸æ£ä»', dosage: '15g' },
                        { name: 'æœ¨é¦™', dosage: '6g' },
                        { name: 'ç‚™ç”˜è‰', dosage: '6g' }
                    ],
                    effects: 'è¡¥ç›Šå¿ƒè„¾ï¼Œå…»è¡€å®‰ç¥',
                    modifications: 'æ°”è™šæ˜æ˜¾åŠ é»„èŠª15gï¼›è¡€è™šç”šè€…åŠ ç†Ÿåœ°12g'
                },
                'ç†ä¸­æ±¤': {
                    herbs: [
                        { name: 'äººå‚', dosage: '9g' },
                        { name: 'ç™½æœ¯', dosage: '9g' },
                        { name: 'å¹²å§œ', dosage: '9g' },
                        { name: 'ç‚™ç”˜è‰', dosage: '6g' }
                    ],
                    effects: 'æ¸©ä¸­æ•£å¯’ï¼Œè¡¥æ°”å¥è„¾',
                    modifications: 'å¯’ç››åŠ é™„å­6gï¼›æ°”è™šç”šåŠ é»„èŠª15g'
                }
            };
            
            return formulaDatabase[formulaName] || {
                herbs: [
                    { name: 'ä¸»è¯', dosage: '10-15g' },
                    { name: 'è¾…è¯', dosage: '6-12g' },
                    { name: 'ä½è¯', dosage: '3-9g' }
                ],
                effects: `æ²»ç–—${getCurrentDiseaseName()}çš„æœ‰æ•ˆæ–¹å‰‚`,
                modifications: 'è¯·æ ¹æ®å…·ä½“ç—‡çŠ¶è¿›è¡ŒåŠ å‡'
            };
        }

        // æ˜¾ç¤ºæ–¹å‰‚åˆ†æç»“æœ
        function showFormulaAnalysisResult(data) {
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = `
                <div class="result-title">ğŸ’Š æ–¹å‰‚AIåˆ†æç»“æœ</div>
                <div style="font-size: 13px;">${data.analysis || 'åˆ†æå®Œæˆï¼Œè¯·æŸ¥çœ‹å…·ä½“å»ºè®®'}</div>
            `;
            
            resultsDiv.appendChild(resultElement);
        }

        // åˆ†æé€‰ä¸­èŠ‚ç‚¹
        function analyzeSelectedNode(node) {
            if (node.type === 'formula') {
                analyzeFormulaNode(node);
            } else {
                showResult('æç¤º', `æ­£åœ¨åˆ†æ${getNodeTypeText(node.type)}èŠ‚ç‚¹: ${node.name}`, 'info');
            }
        }

        // åˆ†ææ–¹å‰‚èŠ‚ç‚¹
        function analyzeFormulaNode(node) {
            const analysis = analyzeFormulaLocally(node.name, getCurrentDiseaseName());
            
            clearResults();
            const resultsDiv = document.getElementById('analysisResults');
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = `
                <div class="result-title">ğŸ’Š ${node.name} è¯¦ç»†åˆ†æ</div>
                <div class="formula-analysis-panel">
                    <div style="margin-bottom: 10px;">
                        <strong>è¯æç»„æˆ:</strong><br>
                        <div style="font-size: 12px; margin-top: 5px;">
                            ${analysis.herbs.map(herb => `${herb.name} ${herb.dosage}`).join('ã€')}
                        </div>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>åŠŸæ•ˆä¸»æ²»:</strong><br>
                        <div style="font-size: 12px; color: #6b7280;">${analysis.effects}</div>
                    </div>
                    <div>
                        <strong>åŠ å‡åŒ–è£:</strong><br>
                        <div style="font-size: 12px; color: #059669;">${analysis.modifications}</div>
                    </div>
                </div>
            `;
            
            resultsDiv.appendChild(resultElement);
        }

        // ç¼–è¾‘èŠ‚ç‚¹
        function editNode(node) {
            const newName = prompt('è¯·è¾“å…¥æ–°çš„èŠ‚ç‚¹åç§°:', node.name);
            if (newName && newName.trim() && newName !== node.name) {
                node.name = newName.trim();
                
                const element = document.getElementById(node.id);
                const titleElement = element.querySelector('.node-title');
                if (titleElement) {
                    titleElement.textContent = node.name;
                }
                
                showResult('æˆåŠŸ', 'âœ… èŠ‚ç‚¹å·²æ›´æ–°', 'success');
            }
        }

        // æ·»åŠ å­èŠ‚ç‚¹
        function addChildNode(parentNode) {
            const nodeType = prompt('è¯·è¾“å…¥èŠ‚ç‚¹ç±»å‹ (symptom/condition/diagnosis/treatment/formula):', 'condition');
            if (!nodeType) return;
            
            const nodeName = prompt('è¯·è¾“å…¥èŠ‚ç‚¹åç§°:', 'æ–°èŠ‚ç‚¹');
            if (!nodeName) return;
            
            const newNode = {
                id: `child_${nodeCounter++}`,
                type: nodeType,
                name: nodeName,
                description: `${parentNode.name}çš„ç›¸å…³èŠ‚ç‚¹`,
                x: parentNode.x + 250,
                y: parentNode.y + (Math.random() - 0.5) * 100
            };
            
            nodes.push(newNode);
            renderNode(newNode);
            
            connections.push({
                from: parentNode.id,
                to: newNode.id
            });
            
            drawConnections();
            showResult('æˆåŠŸ', `âœ… å·²æ·»åŠ å­èŠ‚ç‚¹"${nodeName}"`, 'success');
        }

        // æ·»åŠ è¯æåˆ°æ–¹å‰‚èŠ‚ç‚¹
        function addHerbToFormula(formulaNodeId, herbName, dosage) {
            const formulaNode = nodes.find(node => node.id === formulaNodeId);
            if (!formulaNode) {
                showResult('é”™è¯¯', 'æ‰¾ä¸åˆ°æ–¹å‰‚èŠ‚ç‚¹', 'error');
                return;
            }
            
            // åˆå§‹åŒ– herbs æ•°ç»„
            if (!formulaNode.herbs) {
                formulaNode.herbs = [];
            }
            
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨è¯¥è¯æ
            const existingHerb = formulaNode.herbs.find(h => h.name === herbName);
            if (existingHerb) {
                existingHerb.dosage = dosage;
                showResult('æˆåŠŸ', `âœ… å·²æ›´æ–° ${herbName} ç”¨é‡ä¸º ${dosage}`, 'success');
            } else {
                formulaNode.herbs.push({ name: herbName, dosage: dosage });
                showResult('æˆåŠŸ', `âœ… å·²æ·»åŠ  ${herbName} ${dosage} åˆ°æ–¹å‰‚`, 'success');
            }
            
            // æ›´æ–°èŠ‚ç‚¹æ˜¾ç¤º
            updateFormulaNodeDisplay(formulaNode);
        }

        // åº”ç”¨å®Œæ•´æ–¹å‰‚åˆ°èŠ‚ç‚¹
        function applyFullFormulaToNode(formulaNodeId, herbsJsonStr) {
            const formulaNode = nodes.find(node => node.id === formulaNodeId);
            if (!formulaNode) {
                showResult('é”™è¯¯', 'æ‰¾ä¸åˆ°æ–¹å‰‚èŠ‚ç‚¹', 'error');
                return;
            }
            
            try {
                const herbs = JSON.parse(herbsJsonStr.replace(/&quot;/g, '"'));
                formulaNode.herbs = herbs;
                
                updateFormulaNodeDisplay(formulaNode);
                showResult('æˆåŠŸ', `âœ… å·²åº”ç”¨å®Œæ•´æ–¹å‰‚åˆ° ${formulaNode.name}ï¼ŒåŒ…å« ${herbs.length} å‘³è¯æ`, 'success');
            } catch (error) {
                showResult('é”™è¯¯', 'æ–¹å‰‚æ•°æ®è§£æå¤±è´¥', 'error');
            }
        }

        // æ›´æ–°æ–¹å‰‚èŠ‚ç‚¹æ˜¾ç¤º
        function updateFormulaNodeDisplay(formulaNode) {
            const element = document.getElementById(formulaNode.id);
            if (!element) return;
            
            const contentDiv = element.querySelector('.node-content');
            if (contentDiv && formulaNode.herbs && formulaNode.herbs.length > 0) {
                const herbsList = formulaNode.herbs.map(h => `${h.name} ${h.dosage}`).join('ã€');
                contentDiv.innerHTML = `${formulaNode.description || ''}<br><small style="color: #059669;">è¯æ: ${herbsList}</small>`;
            }
        }

        // å¢å¼ºçš„è¯å‹æ™ºèƒ½è¯†åˆ«
        async function analyzeSyndrome() {
            console.log('è¯å‹æ™ºèƒ½è¯†åˆ«è¢«è°ƒç”¨');
            
            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            if (!getCurrentDiseaseName()) {
                alert('è¯·å…ˆè¾“å…¥ç–¾ç—…åç§°');
                return;
            }
            
            // æ”¶é›†æ‰€æœ‰ç—‡çŠ¶ï¼ˆä»èŠ‚ç‚¹å’Œç—‡çŠ¶ç¾¤ï¼‰
            const symptomNodes = nodes.filter(node => node.type === 'symptom');
            const allSymptoms = symptomNodes.map(n => n.name);
            
            // å³ä½¿æ²¡æœ‰ç—‡çŠ¶ä¹Ÿè¿›è¡Œåˆ†æï¼ˆä½¿ç”¨ç–¾ç—…åç§°ï¼‰
            const symptomsForAnalysis = allSymptoms.length > 0 ? allSymptoms : [getCurrentDiseaseName()];

            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            if (!getCurrentDiseaseName()) {
                alert('è¯·å…ˆè¾“å…¥ç–¾ç—…åç§°');
                return;
            }

            showLoading('æ­£åœ¨è¿›è¡Œè¯å‹æ™ºèƒ½è¯†åˆ«...');

            try {
                    const syndromeAnalysis = analyzeSyndromeLocally(getCurrentDiseaseName(), symptomsForAnalysis || []);
                
                hideLoading();
                showSyndromeAnalysisResult(syndromeAnalysis);
                
            } catch (error) {
                console.error('è¯å‹è¯†åˆ«å¤±è´¥:', error);
                hideLoading();
                showResult('é”™è¯¯', `âŒ è¯†åˆ«å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // å¢å¼ºçš„è¯å‹åˆ†ææ•°æ®åº“
        function analyzeSyndromeLocally(diseaseName, symptoms) {
            const syndromeDatabase = {
                'å¤±çœ ': {
                    'å¿ƒç«æ—ºç››è¯': {
                        keywords: ['å¿ƒçƒ¦', 'å¤šæ¢¦', 'å£å¹²', 'èˆŒçº¢', 'è‹”é»„', 'å¤±çœ ', 'éš¾ä»¥å…¥ç¡'],
                        description: 'å¿ƒç«äº¢ç››ï¼Œæ‰°ä¹±ç¥æ˜',
                        treatment: 'æ¸…å¿ƒç«ï¼Œå®‰ç¥å¿—',
                        formula: 'é»„è¿é˜¿èƒ¶æ±¤',
                        weight: 0.8
                    },
                    'å¿ƒè„¾ä¸¤è™šè¯': {
                        keywords: ['å¥å¿˜', 'å¿ƒæ‚¸', 'é¢è‰²èé»„', 'èˆŒæ·¡', 'è„‰å¼±', 'å¤±çœ ', 'ç–²ä¹', 'é£Ÿæ¬²ä¸æŒ¯'],
                        description: 'å¿ƒè„¾æ°”è¡€ä¸è¶³ï¼Œç¥å¤±æ‰€å…»',
                        treatment: 'è¡¥ç›Šå¿ƒè„¾ï¼Œå…»è¡€å®‰ç¥',
                        formula: 'å½’è„¾æ±¤',
                        weight: 0.7
                    },
                    'è‚éƒåŒ–ç«è¯': {
                        keywords: ['æ˜“æ€’', 'èƒ¸èƒèƒ€æ»¡', 'å£è‹¦', 'è„‰å¼¦', 'å¤±çœ ', 'çƒ¦èº', 'å¤´ç—›'],
                        description: 'è‚éƒåŒ–ç«ï¼Œä¸Šæ‰°ç¥æ˜',
                        treatment: 'ç–è‚è§£éƒï¼Œæ¸…çƒ­å®‰ç¥',
                        formula: 'é€é¥æ•£åˆç”˜éº¦å¤§æ£æ±¤',
                        weight: 0.8
                    },
                    'é˜´è™šç«æ—ºè¯': {
                        keywords: ['å¤±çœ ', 'æ—©é†’', 'äº”å¿ƒçƒ¦çƒ­', 'ç›—æ±—', 'å£å¹²', 'èˆŒçº¢å°‘è‹”'],
                        description: 'è‚¾é˜´ä¸è¶³ï¼Œè™šç«ä¸Šç‚',
                        treatment: 'æ»‹é˜´é™ç«ï¼Œå…»å¿ƒå®‰ç¥',
                        formula: 'é»„è¿é˜¿èƒ¶æ±¤',
                        weight: 0.7
                    }
                },
                'èƒƒç—›': {
                    'è„¾èƒƒè™šå¯’è¯': {
                        keywords: ['å–œæ¸©å–œæŒ‰', 'é¢è‰²èç™½', 'èˆŒæ·¡è‹”ç™½', 'è„‰ç»†å¼±', 'èƒƒç—›', 'èƒƒèƒ€'],
                        description: 'è„¾èƒƒé˜³æ°”ä¸è¶³ï¼Œå¤±äºæ¸©ç…¦',
                        treatment: 'æ¸©ä¸­æ•£å¯’ï¼Œè¡¥æ°”å¥è„¾',
                        formula: 'ç†ä¸­æ±¤',
                        weight: 0.8
                    },
                    'è‚æ°”çŠ¯èƒƒè¯': {
                        keywords: ['èƒ€ç—›æ‹’æŒ‰', 'å—³æ°”', 'æƒ…å¿—ä¸é‚', 'è„‰å¼¦', 'èƒƒç—›', 'åé…¸'],
                        description: 'è‚æ°”éƒç»“ï¼Œæ¨ªé€†çŠ¯èƒƒ',
                        treatment: 'ç–è‚ç†æ°”ï¼Œå’Œèƒƒæ­¢ç—›',
                        formula: 'æŸ´èƒ¡ç–è‚æ•£',
                        weight: 0.7
                    }
                },
                // é€šç”¨ç—‡çŠ¶åŒ¹é…ï¼ˆé™ä½é˜ˆå€¼ï¼‰
                'é€šç”¨': {
                    'æ°”è¡€ä¸è¶³è¯': {
                        keywords: ['ç–²ä¹', 'ä¹åŠ›', 'é¢è‰²èé»„', 'å¤´æ™•', 'å¿ƒæ‚¸'],
                        description: 'æ°”è¡€äºè™šï¼Œè„è…‘å¤±å…»',
                        treatment: 'ç›Šæ°”å…»è¡€',
                        formula: 'å…«çæ±¤',
                        weight: 0.4
                    },
                    'ç—°æ¹¿å†…é˜»è¯': {
                        keywords: ['èƒ¸é—·', 'æ¶å¿ƒ', 'é£Ÿæ¬²ä¸æŒ¯', 'èˆŒè‹”åšè…»', 'å¤´é‡'],
                        description: 'ç—°æ¹¿å†…ç”Ÿï¼Œé˜»æ»æ°”æœº',
                        treatment: 'åŒ–ç—°é™¤æ¹¿ï¼Œç†æ°”å’Œä¸­',
                        formula: 'äºŒé™ˆæ±¤',
                        weight: 0.4
                    }
                }
            };

            const diseaseSymptoms = syndromeDatabase[diseaseName] || {};
            const matchedSyndromes = [];

            // æ£€æŸ¥ç–¾ç—…ç‰¹å®šè¯å‹
            Object.keys(diseaseSymptoms).forEach(syndromeName => {
                const syndrome = diseaseSymptoms[syndromeName];
                const matchCount = syndrome.keywords.filter(keyword => 
                    symptoms.some(symptom => symptom.includes(keyword) || keyword.includes(symptom))
                ).length;
                
                const baseMatchRate = matchCount / syndrome.keywords.length;
                const weightedMatchRate = baseMatchRate * (syndrome.weight || 0.5);
                
                // é™ä½åŒ¹é…é˜ˆå€¼åˆ°15%ï¼Œè®©æ›´å¤šè¯å‹èƒ½è¢«è¯†åˆ«
                if (weightedMatchRate > 0.15) {
                    matchedSyndromes.push({
                        name: syndromeName,
                        matchRate: weightedMatchRate,
                        confidence: Math.min(weightedMatchRate * 1.5, 1.0),
                        ...syndrome
                    });
                }
            });
            
            // æ£€æŸ¥é€šç”¨è¯å‹ï¼ˆå½“ç–¾ç—…ç‰¹å®šè¯å‹åŒ¹é…åº¦ä½æ—¶ï¼‰
            if (matchedSyndromes.length === 0 && syndromeDatabase['é€šç”¨']) {
                Object.keys(syndromeDatabase['é€šç”¨']).forEach(syndromeName => {
                    const syndrome = syndromeDatabase['é€šç”¨'][syndromeName];
                    const matchCount = syndrome.keywords.filter(keyword => 
                        symptoms.some(symptom => symptom.includes(keyword) || keyword.includes(symptom))
                    ).length;
                    
                    const matchRate = matchCount / syndrome.keywords.length;
                    
                    if (matchRate > 0.2) { // é€šç”¨è¯å‹é˜ˆå€¼ç¨é«˜
                        matchedSyndromes.push({
                            name: syndromeName,
                            matchRate: matchRate,
                            confidence: matchRate * 0.8, // é€šç”¨è¯å‹ç½®ä¿¡åº¦ç¨ä½
                            isGeneric: true,
                            ...syndrome
                        });
                    }
                });
            }

            // æŒ‰åŒ¹é…åº¦æ’åº
            matchedSyndromes.sort((a, b) => b.matchRate - a.matchRate);

            return {
                matchedSyndromes,
                recommendation: matchedSyndromes.length > 0 ? matchedSyndromes[0] : null
            };
        }

        // æ˜¾ç¤ºè¯å‹åˆ†æç»“æœ
        function showSyndromeAnalysisResult(analysis) {
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            let html = '<div class="result-title">ğŸ¯ è¯å‹æ™ºèƒ½è¯†åˆ«ç»“æœ</div>';
            
            if (analysis.recommendation) {
                html += `
                    <div class="auto-analysis-panel">
                        <div style="font-weight: 600; margin-bottom: 10px; color: #d97706;">
                            ğŸ† æ¨èè¯å‹: ${analysis.recommendation.name} 
                            <span style="font-size: 12px; color: #6b7280;">(åŒ¹é…åº¦: ${Math.round(analysis.recommendation.matchRate * 100)}%)</span>
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>ç—…æœº:</strong> ${analysis.recommendation.description}
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>æ²»æ³•:</strong> ${analysis.recommendation.treatment}
                        </div>
                        <div style="margin-bottom: 10px;">
                            <strong>æ¨èæ–¹å‰‚:</strong> ${analysis.recommendation.formula}
                        </div>
                        <button class="add-pathway-btn" onclick="addSyndromeToTree('${analysis.recommendation.name}', '${analysis.recommendation.description}')">
                            â• æ·»åŠ è¯å‹åˆ°å†³ç­–æ ‘
                        </button>
                        <button class="add-pathway-btn" onclick="addTreatmentToTree('${analysis.recommendation.treatment}', '${analysis.recommendation.formula}')">
                            â• æ·»åŠ æ²»ç–—æ–¹æ¡ˆ
                        </button>
                    </div>
                `;
            }

            if (analysis.matchedSyndromes.length > 1) {
                html += '<div style="margin-top: 15px;"><strong>å…¶ä»–å¯èƒ½è¯å‹:</strong><br>';
                analysis.matchedSyndromes.slice(1, 3).forEach(syndrome => {
                    html += `
                        <div class="suggestion-item" onclick="addSyndromeToTree('${syndrome.name}', '${syndrome.description}')">
                            <div class="suggestion-content">${syndrome.name}</div>
                            <div class="suggestion-desc">åŒ¹é…åº¦: ${Math.round(syndrome.matchRate * 100)}% - ${syndrome.description}</div>
                        </div>
                    `;
                });
                html += '</div>';
            }

            if (analysis.matchedSyndromes.length === 0) {
                // æä¾›æ›´å¤šå¸®åŠ©ä¿¡æ¯
                // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
                html += `
                    <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 8px; padding: 12px; color: #92400e;">
                        <div style="font-weight: 600; margin-bottom: 8px;">âš ï¸ è¯å‹è¯†åˆ«å»ºè®®</div>
                        <div style="font-size: 12px; margin-bottom: 8px;">
                            å½“å‰${diseaseName}çš„ç—‡çŠ¶ä¿¡æ¯ä¸è¶³ï¼Œå»ºè®®è¡¥å……ä»¥ä¸‹ä¿¡æ¯ï¼š
                        </div>
                        <div style="font-size: 11px; line-height: 1.4;">
                            â€¢ è¯¦ç»†æè¿°ç—‡çŠ¶ç‰¹ç‚¹ï¼ˆå¦‚ç—›ç—›æ€§è´¨ã€å‘ä½œæ—¶é—´ï¼‰<br>
                            â€¢ æ·»åŠ ä¼´éšç—‡çŠ¶ï¼ˆå¦‚ç¡çœ ã€é¥®é£Ÿã€å¤§å°ä¾¿ï¼‰<br>
                            â€¢ æä¾›èˆŒè±¡è„‰è±¡ä¿¡æ¯<br>
                            â€¢ è®°å½•æƒ…å¿—å› ç´ å’Œèµ·ç—…åŸå› 
                        </div>
                        <div style="margin-top: 10px;">
                            <button onclick="showSymptomGuidance('${diseaseName}')" style="
                                background: #f59e0b; color: white; border: none; border-radius: 6px; 
                                padding: 6px 12px; font-size: 11px; cursor: pointer;
                            ">
                                ğŸ“ è·å–ç—‡çŠ¶æŒ‡å¯¼
                            </button>
                        </div>
                    </div>
                `;
            }
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = html;
            
            resultsDiv.appendChild(resultElement);
        }

        // æ·»åŠ è¯å‹åˆ°å†³ç­–æ ‘
        function addSyndromeToTree(syndromeName, description) {
            if (!selectedNode) {
                // è‡ªåŠ¨é€‰æ‹©æœ€åä¸€ä¸ªconditionèŠ‚ç‚¹æˆ–åˆ›å»ºæ–°ä½ç½®
                const conditionNodes = nodes.filter(n => n.type === 'condition');
                if (conditionNodes.length > 0) {
                    selectedNode = conditionNodes[conditionNodes.length - 1];
                } else {
                    showResult('æç¤º', 'è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºæ·»åŠ ä½ç½®', 'info');
                    return;
                }
            }

            const newNode = {
                id: `syndrome_${nodeCounter++}`,
                type: 'diagnosis',
                name: syndromeName,
                description: description,
                x: selectedNode.x + 250,
                y: selectedNode.y
            };
            
            nodes.push(newNode);
            renderNode(newNode);
            
            connections.push({
                from: selectedNode.id,
                to: newNode.id
            });
            
            drawConnections();
            showResult('æˆåŠŸ', `âœ… å·²æ·»åŠ è¯å‹"${syndromeName}"åˆ°å†³ç­–æ ‘`, 'success');
        }

        // æ·»åŠ æ²»ç–—æ–¹æ¡ˆåˆ°å†³ç­–æ ‘
        function addTreatmentToTree(treatmentMethod, formulaName) {
            const diagnosisNodes = nodes.filter(n => n.type === 'diagnosis');
            if (diagnosisNodes.length === 0) {
                showResult('æç¤º', 'è¯·å…ˆæ·»åŠ è¯Šæ–­èŠ‚ç‚¹', 'info');
                return;
            }

            const lastDiagnosisNode = diagnosisNodes[diagnosisNodes.length - 1];
            
            // æ·»åŠ æ²»ç–—èŠ‚ç‚¹
            const treatmentNode = {
                id: `treatment_${nodeCounter++}`,
                type: 'treatment',
                name: 'æ²»ç–—æ–¹æ¡ˆ',
                description: treatmentMethod,
                x: lastDiagnosisNode.x + 250,
                y: lastDiagnosisNode.y
            };
            
            nodes.push(treatmentNode);
            renderNode(treatmentNode);
            
            connections.push({
                from: lastDiagnosisNode.id,
                to: treatmentNode.id
            });

            // æ·»åŠ æ–¹å‰‚èŠ‚ç‚¹
            const formulaNode = {
                id: `formula_${nodeCounter++}`,
                type: 'formula',
                name: formulaName,
                description: 'æ¨èæ–¹å‰‚',
                x: treatmentNode.x + 250,
                y: treatmentNode.y
            };
            
            nodes.push(formulaNode);
            renderNode(formulaNode);
            
            connections.push({
                from: treatmentNode.id,
                to: formulaNode.id
            });
            
            drawConnections();
            showResult('æˆåŠŸ', `âœ… å·²æ·»åŠ æ²»ç–—æ–¹æ¡ˆå’Œæ–¹å‰‚åˆ°å†³ç­–æ ‘`, 'success');
        }

        // ç”ŸæˆåŸºç¡€è¯Šç–—è·¯å¾„ï¼ˆæ— ç—‡çŠ¶æ—¶ï¼‰
        function generateBasicPathway(diseaseName) {
            const basicSteps = [
                {
                    type: 'inquiry',
                    title: 'é—®è¯Šé‡‡é›†',
                    content: `è¯¦ç»†äº†è§£${diseaseName}ç›¸å…³ç—‡çŠ¶`,
                    action: 'collect_symptoms'
                },
                {
                    type: 'examination',
                    title: 'ä½“æ ¼æ£€æŸ¥',
                    content: 'æœ›é—»é—®åˆ‡å››è¯Šåˆå‚',
                    action: 'physical_exam'
                },
                {
                    type: 'analysis',
                    title: 'è¾¨è¯åˆ†æ',
                    content: `æ ¹æ®ç—‡çŠ¶ç‰¹ç‚¹è¿›è¡Œ${diseaseName}çš„è¯å‹åˆ¤æ–­`,
                    action: 'syndrome_analysis'
                },
                {
                    type: 'treatment',
                    title: 'æ²»ç–—æ–¹æ¡ˆ',
                    content: 'åˆ¶å®šé’ˆå¯¹æ€§çš„ä¸­åŒ»æ²»ç–—æ–¹æ¡ˆ',
                    action: 'treatment_plan'
                }
            ];
            
            return {
                pathway: basicSteps,
                message: `ä¸º${diseaseName}ç”Ÿæˆçš„åŸºç¡€è¯Šç–—è·¯å¾„`
            };
        }
        
        // ç”Ÿæˆé€šç”¨è¯Šç–—è·¯å¾„ï¼ˆæœ‰ç—‡çŠ¶ä½†æ— æ˜ç¡®è¯å‹ï¼‰
        function generateGenericPathway(diseaseName, symptoms) {
            const genericSteps = [
                {
                    type: 'analysis',
                    title: 'ç—‡çŠ¶åˆ†æ',
                    content: `å½“å‰ç—‡çŠ¶: ${symptoms.join('ã€')}ï¼Œéœ€è¿›ä¸€æ­¥åˆ†æè¾¨è¯`,
                    action: 'symptom_analysis'
                },
                {
                    type: 'differential',
                    title: 'é‰´åˆ«è¯Šæ–­',
                    content: `æ’é™¤${diseaseName}çš„å…¶ä»–å¯èƒ½è¯å‹`,
                    action: 'differential_diagnosis'
                },
                {
                    type: 'supplementary',
                    title: 'è¡¥å……æ£€æŸ¥',
                    content: 'å®Œå–„å››è¯Šä¿¡æ¯ï¼Œæ˜ç¡®è¯å‹',
                    action: 'supplementary_exam'
                },
                {
                    type: 'treatment',
                    title: 'åˆ†å‹æ²»ç–—',
                    content: 'æ ¹æ®æœ€ç»ˆè¯å‹é€‰æ‹©åˆé€‚æ²»æ³•',
                    action: 'targeted_treatment'
                }
            ];
            
            return {
                pathway: genericSteps,
                syndrome: null,
                message: `åŸºäºç°æœ‰ç—‡çŠ¶ç”Ÿæˆçš„${diseaseName}é€šç”¨è¯Šç–—è·¯å¾„`
            };
        }
        
        // å¢å¼ºçš„æ™ºèƒ½è¯Šç–—è·¯å¾„ç”Ÿæˆ
        async function generateAutoPathway() {
            console.log('æ™ºèƒ½è¯Šç–—è·¯å¾„è¢«è°ƒç”¨');
            
            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            if (!getCurrentDiseaseName()) {
                alert('è¯·å…ˆè¾“å…¥ç–¾ç—…åç§°');
                return;
            }
            
            showLoading('æ­£åœ¨ç”Ÿæˆæ™ºèƒ½è¯Šç–—è·¯å¾„...');

            try {
                // æ”¶é›†ç—‡çŠ¶ï¼ˆä»èŠ‚ç‚¹å’Œç—‡çŠ¶ç¾¤ï¼‰
                const symptomNodes = nodes.filter(node => node.type === 'symptom');
                const allSymptoms = symptomNodes.map(n => n.name);
                
                // åŸºäºç°æœ‰ç—‡çŠ¶ç”Ÿæˆå®Œæ•´è·¯å¾„
                const pathwayData = generatePathwayFromSymptoms(diseaseName, allSymptoms || []);
                
                hideLoading();
                showPathwayGenerationResult(pathwayData);
                
            } catch (error) {
                console.error('è·¯å¾„ç”Ÿæˆå¤±è´¥:', error);
                hideLoading();
                showResult('é”™è¯¯', `âŒ ç”Ÿæˆå¤±è´¥: ${error.message}`, 'error');
            }
        }

        // å¢å¼ºçš„è¯Šç–—è·¯å¾„ç”Ÿæˆ
        function generatePathwayFromSymptoms(diseaseName, symptoms) {
            // å…ˆè¿›è¡Œè¯å‹åˆ†æ
            const syndromeAnalysis = analyzeSyndromeLocally(diseaseName, symptoms);
            const recommendedSyndrome = syndromeAnalysis.recommendation;
            
            // é™ä½é˜ˆå€¼ï¼Œå³ä½¿æ²¡æœ‰æ˜ç¡®è¯å‹ä¹Ÿç”ŸæˆåŸºç¡€è·¯å¾„
            if (!recommendedSyndrome && symptoms.length === 0) {
                // å®Œå…¨æ²¡æœ‰ç—‡çŠ¶æ—¶çš„é»˜è®¤è·¯å¾„
                return generateBasicPathway(diseaseName);
            }
            
            if (!recommendedSyndrome && symptoms.length > 0) {
                // æœ‰ç—‡çŠ¶ä½†æ²¡æœ‰åŒ¹é…è¯å‹æ—¶çš„é€šç”¨è·¯å¾„
                return generateGenericPathway(diseaseName, symptoms);
            }

            // ç”Ÿæˆå®Œæ•´è·¯å¾„æ­¥éª¤
            const pathway = [
                {
                    type: 'analysis',
                    title: 'ç—‡çŠ¶åˆ†æ',
                    content: `å½“å‰ç—‡çŠ¶: ${symptoms.join('ã€')}`,
                    action: 'review_symptoms'
                },
                {
                    type: 'syndrome',
                    title: 'è¯å‹è¯Šæ–­',
                    content: `${recommendedSyndrome.name} (åŒ¹é…åº¦: ${Math.round(recommendedSyndrome.matchRate * 100)}%)`,
                    description: recommendedSyndrome.description,
                    action: 'add_syndrome'
                },
                {
                    type: 'treatment',
                    title: 'æ²»ç–—åŸåˆ™',
                    content: recommendedSyndrome.treatment,
                    action: 'add_treatment'
                },
                {
                    type: 'formula',
                    title: 'æ–¹è¯é€‰æ‹©',
                    content: recommendedSyndrome.formula,
                    action: 'add_formula'
                }
            ];

            return {
                pathway: pathway,
                syndrome: recommendedSyndrome,
                message: 'åŸºäºç°æœ‰ç—‡çŠ¶ç”Ÿæˆçš„æ™ºèƒ½è¯Šç–—è·¯å¾„'
            };
        }

        // æ˜¾ç¤ºè·¯å¾„ç”Ÿæˆç»“æœ
        function showPathwayGenerationResult(pathwayData) {
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            let html = '<div class="result-title">ğŸ¤– æ™ºèƒ½è¯Šç–—è·¯å¾„</div>';
            
            if (pathwayData.pathway.length > 0) {
                html += `<div style="margin-bottom: 15px; color: #059669; font-size: 12px;">${pathwayData.message}</div>`;
                
                pathwayData.pathway.forEach((step, index) => {
                    html += `
                        <div class="pathway-step">
                            <div style="font-weight: 600; color: #1e40af; margin-bottom: 5px;">
                                ${index + 1}. ${step.title}
                            </div>
                            <div style="font-size: 13px; margin-bottom: 8px;">${step.content}</div>
                            ${step.description ? `<div style="font-size: 11px; color: #6b7280; margin-bottom: 8px;">${step.description}</div>` : ''}
                            <button class="add-pathway-btn" onclick="executePathwayStep('${step.action}', '${step.title}', '${step.content.replace(/'/g, "\\'")}')">
                                â• æ·»åŠ åˆ°å†³ç­–æ ‘
                            </button>
                        </div>
                    `;
                });

                html += `
                    <div style="margin-top: 15px; padding: 10px; background: #f0f9ff; border-radius: 6px;">
                        <button class="apply-formula-btn" onclick="applyFullPathway('${JSON.stringify(pathwayData).replace(/"/g, "&quot;")}')">
                            ğŸš€ åº”ç”¨å®Œæ•´è·¯å¾„
                        </button>
                    </div>
                `;
            } else {
                html += `<div style="color: #f59e0b;">${pathwayData.message}</div>`;
            }
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = html;
            
            resultsDiv.appendChild(resultElement);
        }

        // æ‰§è¡Œè·¯å¾„æ­¥éª¤
        function executePathwayStep(action, title, content) {
            const lastNode = nodes.length > 0 ? nodes[nodes.length - 1] : null;
            const baseX = lastNode ? lastNode.x + 250 : 50;
            const baseY = lastNode ? lastNode.y : 100;

            let nodeType, nodeName, nodeDescription;

            switch (action) {
                case 'add_syndrome':
                    nodeType = 'diagnosis';
                    nodeName = content.split(' (')[0]; // ç§»é™¤åŒ¹é…åº¦ä¿¡æ¯
                    nodeDescription = title;
                    break;
                case 'add_treatment':
                    nodeType = 'treatment';
                    nodeName = title;
                    nodeDescription = content;
                    break;
                case 'add_formula':
                    nodeType = 'formula';
                    nodeName = content;
                    nodeDescription = title;
                    break;
                default:
                    showResult('æç¤º', `å·²è®°å½•: ${title}`, 'info');
                    return;
            }

            const newNode = {
                id: `pathway_${nodeCounter++}`,
                type: nodeType,
                name: nodeName,
                description: nodeDescription,
                x: baseX,
                y: baseY + (Math.random() - 0.5) * 50
            };
            
            nodes.push(newNode);
            renderNode(newNode);
            
            if (lastNode) {
                connections.push({
                    from: lastNode.id,
                    to: newNode.id
                });
                drawConnections();
            }
            
            showResult('æˆåŠŸ', `âœ… å·²æ·»åŠ ${title}åˆ°å†³ç­–æ ‘`, 'success');
        }

        // åº”ç”¨å®Œæ•´è·¯å¾„
        function applyFullPathway(pathwayJsonStr) {
            try {
                const pathwayData = JSON.parse(pathwayJsonStr.replace(/&quot;/g, '"'));
                
                let previousNode = nodes.length > 0 ? nodes[nodes.length - 1] : null;
                let x = previousNode ? previousNode.x + 250 : 300;
                const baseY = previousNode ? previousNode.y : 100;
                
                pathwayData.pathway.forEach((step, index) => {
                    let nodeType, nodeName, nodeDescription;

                    switch (step.action) {
                        case 'add_syndrome':
                            nodeType = 'diagnosis';
                            nodeName = step.content.split(' (')[0];
                            nodeDescription = step.description || step.title;
                            break;
                        case 'add_treatment':
                            nodeType = 'treatment';
                            nodeName = step.title;
                            nodeDescription = step.content;
                            break;
                        case 'add_formula':
                            nodeType = 'formula';
                            nodeName = step.content;
                            nodeDescription = step.title;
                            break;
                        default:
                            return;
                    }

                    const newNode = {
                        id: `full_pathway_${nodeCounter++}`,
                        type: nodeType,
                        name: nodeName,
                        description: nodeDescription,
                        x: x,
                        y: baseY + (index * 20) - 40
                    };
                    
                    nodes.push(newNode);
                    renderNode(newNode);
                    
                    if (previousNode) {
                        connections.push({
                            from: previousNode.id,
                            to: newNode.id
                        });
                    }
                    
                    previousNode = newNode;
                    x += 250;
                });
                
                drawConnections();
                showResult('æˆåŠŸ', `âœ… å·²åº”ç”¨å®Œæ•´è¯Šç–—è·¯å¾„ï¼ŒåŒ…å«${pathwayData.pathway.filter(s => s.action !== 'review_symptoms').length}ä¸ªæ­¥éª¤`, 'success');
                
            } catch (error) {
                showResult('é”™è¯¯', 'è·¯å¾„æ•°æ®è§£æå¤±è´¥', 'error');
            }
        }

        // æ˜¾ç¤ºç—‡çŠ¶æŒ‡å¯¼
        function showSymptomGuidance(diseaseName) {
            const guidance = {
                'å¤±çœ ': [
                    'å…¥ç¡æƒ…å†µï¼šéš¾ä»¥å…¥ç¡ã€è¾—è½¬åä¾§ã€å…¥ç¡æ—¶é—´è¶…è¿‡30åˆ†é’Ÿ',
                    'ç¡çœ ç»´æŒï¼šæ—©é†’ã€å¤šæ¢¦ã€ç¡çœ æµ…ã€æ˜“æƒŠé†’',
                    'ä¼´éšç—‡çŠ¶ï¼šå¿ƒçƒ¦ã€å¤´æ™•ã€å¥å¿˜ã€ç–²ä¹ä¹åŠ›',
                    'æƒ…å¿—å› ç´ ï¼šç„¦è™‘ã€æŠ‘éƒã€å·¥ä½œå‹åŠ›ã€æƒ…ç»ªæ³¢åŠ¨',
                    'èˆŒè±¡è„‰è±¡ï¼šèˆŒè´¨ã€èˆŒè‹”ã€è„‰è±¡ï¼ˆæ•°ã€æœ‰åŠ›ã€æ»‘æ¶©ç­‰ï¼‰'
                ],
                'èƒƒç—›': [
                    'ç—›ç—›ç‰¹ç‚¹ï¼šèƒ€ç—›ã€åˆºç—›ã€éšç—›ã€ç»­ç—›ã€é˜µå‘æ€§ç—›ç—›',
                    'ç—›ç—›è¯±å› ï¼šé£Ÿåç—›ã€ç©ºè…¹ç—›ã€æƒ…ç»ªæ¿€åŠ¨ååŠ é‡',
                    'ä¼´éšç—‡çŠ¶ï¼šèƒƒèƒ€ã€åé…¸ã€å—³æ°”ã€æ¶å¿ƒå‘•å',
                    'é£®é£Ÿæƒ…å†µï¼šé£Ÿæ¬²ä¸æŒ¯ã€å–œæŒ‰å–œæ¸©ã€å–œå‡‰æ‹’æŒ‰',
                    'å¤§å°ä¾¿ï¼šå¤§ä¾¿æƒ…å†µã€å°ä¾¿é¢œè‰²åŠé‡'
                ]
            };
            
            const diseaseGuidance = guidance[diseaseName] || [
                'è¯¦ç»†æè¿°ä¸»è¦ç—‡çŠ¶çš„ç‰¹ç‚¹å’Œå‘ä½œè§„å¾‹',
                'è®°å½•ä¼´éšå‡ºç°çš„å…¶ä»–ä¸é€‚ç—‡çŠ¶',
                'æ³¨æ„è§‚å¯ŸèˆŒè±¡å’Œè„‰è±¡çš„å˜åŒ–',
                'è€ƒè™‘ç–¾ç—…çš„èµ·å› å’Œè¯±å‘å› ç´ '
            ];
            
            alert(`${diseaseName}ç—‡çŠ¶é‡‡é›†æŒ‡å¯¼ï¼š\n\n${diseaseGuidance.map((item, index) => `${index + 1}. ${item}`).join('\n\n')}\n\nè¯·æ ¹æ®ä»¥ä¸ŠæŒ‡å¯¼è¡¥å……ç—‡çŠ¶ä¿¡æ¯ï¼Œæé«˜è¯å‹è¯†åˆ«çš„å‡†ç¡®æ€§ã€‚`);
        }
        
        // URLå‚æ•°æ£€æŸ¥å‡½æ•°ï¼ˆåœ¨ä¸»åˆå§‹åŒ–ä¸­è°ƒç”¨ï¼‰
        function checkURLParameters() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const presetSymptoms = urlParams.get('symptoms');
                const presetDisease = urlParams.get('disease');
                
                if (presetDisease) {
                    const diseaseInput = document.getElementById('diseaseName');
                    if (diseaseInput) {
                        diseaseInput.value = presetDisease;
                        console.log('è®¾ç½®é¢„è®¾ç–¾ç—…:', presetDisease);
                    }
                }
                
                if (presetSymptoms) {
                    console.log('å‘ç°é¢„è®¾ç—‡çŠ¶:', presetSymptoms);
                    // TODO: åç»­å¯ä»¥æ·»åŠ è‡ªåŠ¨ç”Ÿæˆç—‡çŠ¶ç¾¤åŠŸèƒ½
                }
            } catch (error) {
                console.error('URLå‚æ•°æ£€æŸ¥å‡ºé”™:', error);
            }
        }
        
        console.log('å†³ç­–æ ‘æ„å»ºå™¨åŠ è½½å®Œæˆ');
        
        // ç´§æ€¥ä¿®å¤ï¼šå¼ºåˆ¶é‡æ–°ç»‘å®šä¸»è¦æŒ‰é’®äº‹ä»¶
        setTimeout(function() {
            console.log('å¼ºåˆ¶é‡æ–°ç»‘å®šäº‹ä»¶...');
            const generateBtn = document.getElementById('generateBtn');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const clearBtn = document.getElementById('clearBtn');
            const aiModeToggle = document.getElementById('aiModeToggle');
            
            if (generateBtn) {
                generateBtn.onclick = function() {
                    console.log('å¼ºåˆ¶ç»‘å®šçš„generateAITreeè¢«è°ƒç”¨');
                    generateAITree();
                };
                console.log('generateBtné‡æ–°ç»‘å®šæˆåŠŸ');
            }
            
            if (analyzeBtn) {
                analyzeBtn.onclick = function() {
                    console.log('å¼ºåˆ¶ç»‘å®šçš„analyzeCurrentTreeè¢«è°ƒç”¨');
                    analyzeCurrentTree();
                };
                console.log('analyzeBtné‡æ–°ç»‘å®šæˆåŠŸ');
            }
            
            if (clearBtn) {
                clearBtn.onclick = function() {
                    console.log('å¼ºåˆ¶ç»‘å®šçš„clearCanvasè¢«è°ƒç”¨');
                    clearCanvas();
                };
                console.log('clearBtné‡æ–°ç»‘å®šæˆåŠŸ');
            }
            
            // ğŸ”§ å¼ºåˆ¶ä¿®å¤AIæ¨¡å¼åˆ‡æ¢
            if (aiModeToggle) {
                console.log('ğŸ”§ å¼ºåˆ¶ç»‘å®šAIæ¨¡å¼åˆ‡æ¢...');
                console.log('  å½“å‰AIçŠ¶æ€:', aiStatus);
                
                aiModeToggle.onchange = function() {
                    console.log('ğŸ”„ AIæ¨¡å¼åˆ‡æ¢è§¦å‘!');
                    console.log('  - åˆ‡æ¢çŠ¶æ€:', this.checked);
                    console.log('  - AIå¯ç”¨æ€§:', aiStatus.ai_enabled);
                    
                    const useAI = this.checked && aiStatus.ai_enabled;
                    console.log('  - æœ€ç»ˆæ¨¡å¼:', useAI ? 'AIæ¨¡å¼' : 'æ¨¡æ¿æ¨¡å¼');
                    
                    // ç«‹å³æ›´æ–°UIæ˜¾ç¤º
                    const aiModeText = document.getElementById('aiModeText');
                    const generateBtnText = document.getElementById('generateBtnText');
                    const generateBtnIcon = document.getElementById('generateBtnIcon');
                    
                    if (useAI) {
                        aiModeText.textContent = 'AIæ™ºèƒ½æ¨¡å¼';
                        aiModeText.style.color = '#3b82f6';
                        if (generateBtnText) generateBtnText.textContent = 'AIæ™ºèƒ½ç”Ÿæˆ';
                        if (generateBtnIcon) generateBtnIcon.textContent = 'ğŸ¤–';
                    } else {
                        aiModeText.textContent = 'æ ‡å‡†æ¨¡æ¿æ¨¡å¼';
                        aiModeText.style.color = '#6b7280';
                        if (generateBtnText) generateBtnText.textContent = 'æ ‡å‡†æ¨¡æ¿ç”Ÿæˆ';
                        if (generateBtnIcon) generateBtnIcon.textContent = 'ğŸ“‹';
                    }
                    
                    console.log('âœ… UIæ›´æ–°å®Œæˆ');
                };
                
                // è§¦å‘åˆå§‹çŠ¶æ€è®¾ç½®
                const event = new Event('change');
                aiModeToggle.dispatchEvent(event);
                
                console.log('âœ… AIæ¨¡å¼åˆ‡æ¢å¼ºåˆ¶ç»‘å®šå®Œæˆ');
            } else {
                console.error('âŒ æ‰¾ä¸åˆ°aiModeToggleå…ƒç´ ');
            }
        }, 1500);
        
        // å±•ç¤ºä¸­åŒ»å†³ç­–æ ‘ç¤ºä¾‹
        function showTCMExample() {
            // æ¸…ç©ºå½“å‰ç”»å¸ƒ
            clearCanvas();
            
            // è®¾ç½®ç–¾ç—…åç§°
            document.getElementById('diseaseName').value = 'å¤±çœ ç—‡';
            
            // åˆ›å»ºç¤ºä¾‹å†³ç­–æ ‘
            const exampleNodes = [
                // ä¸»æµç¨‹
                { id: 'ex1', type: 'disease', name: 'å¤±çœ ç—‡', description: 'ä¸å¯ç—…ï¼Œç¡çœ éšœç¢', x: 50, y: 300 },
                { id: 'ex2', type: 'four_diagnosis', name: 'å››è¯Šä¿¡æ¯æ”¶é›†', description: 'æœ›ï¼šé¢è‰²æ™¦æš—ã€èˆŒçº¢è‹”è–„\né—»ï¼šè¯­å£°ä½å¾®\né—®ï¼šå…¥ç¡å›°éš¾ã€å¤šæ¢¦æ˜“é†’\nåˆ‡ï¼šè„‰ç»†æ•°', x: 300, y: 300 },
                { id: 'ex3', type: 'symptom', name: 'ä¸»ç—‡åˆ†æ', description: 'ä¸»ç—‡ï¼šå…¥ç¡å›°éš¾ã€æ˜“é†’\nå…¼ç—‡ï¼šå¿ƒçƒ¦ã€å£å¹²ã€å¤´æ™•', x: 550, y: 300 },
                { id: 'ex4', type: 'pathogenesis', name: 'ç—…å› ç—…æœº', description: 'æ€è™‘è¿‡åº¦ï¼Œæš—è€—é˜´è¡€\nå¿ƒè‚¾ä¸äº¤ï¼Œè™šç«ä¸Šç‚', x: 800, y: 300 },
                { id: 'ex5', type: 'syndrome', name: 'è¯å€™åˆ¤æ–­', description: 'ç»¼åˆå››è¯Šï¼Œè¾¨è¯åˆ†å‹', x: 1050, y: 300 },
                
                // è¯å‹åˆ†æ”¯
                { id: 'ex5a', type: 'syndrome', name: 'å¿ƒè‚¾ä¸äº¤è¯', description: 'å¿ƒçƒ¦ä¸å¯ï¼Œå¿ƒæ‚¸å¥å¿˜\nå¤´æ™•è€³é¸£ï¼Œè…°è†é…¸è½¯', x: 1300, y: 200 },
                { id: 'ex5b', type: 'syndrome', name: 'é˜´è™šç«æ—ºè¯', description: 'è™šçƒ¦ä¸çœ ï¼Œäº”å¿ƒçƒ¦çƒ­\nå£å¹²å’½ç‡¥ï¼ŒèˆŒçº¢å°‘è‹”', x: 1300, y: 400 },
                
                // å¿ƒè‚¾ä¸äº¤è¯çš„æ²»ç–—
                { id: 'ex6a', type: 'principle', name: 'æ»‹é˜´é™ç«', description: 'äº¤é€šå¿ƒè‚¾ï¼Œå®å¿ƒå®‰ç¥', x: 1550, y: 200 },
                { id: 'ex7a', type: 'prescription', name: 'äº¤æ³°ä¸¸åŠ å‡', description: 'é»„è¿6g è‚‰æ¡‚3g\né…¸æ£ä»15g é¾™éª¨30g', x: 1800, y: 200 },
                
                // é˜´è™šç«æ—ºè¯çš„æ²»ç–—
                { id: 'ex6b', type: 'principle', name: 'æ»‹é˜´æ¸…çƒ­', description: 'å…»é˜´æ¸…çƒ­ï¼Œå®å¿ƒå®‰ç¥', x: 1550, y: 400 },
                { id: 'ex7b', type: 'prescription', name: 'é»„è¿é˜¿èƒ¶æ±¤', description: 'é»„è¿9g é˜¿èƒ¶9g\né»„èŠ©6g ç™½èŠ12g\né¸¡å­é»„2æš', x: 1800, y: 400 }
            ];
            
            // åˆ›å»ºè¿æ¥å…³ç³»
            const exampleConnections = [
                { from: 'ex1', to: 'ex2' },
                { from: 'ex2', to: 'ex3' },
                { from: 'ex3', to: 'ex4' },
                { from: 'ex4', to: 'ex5' },
                { from: 'ex5', to: 'ex5a' },
                { from: 'ex5', to: 'ex5b' },
                { from: 'ex5a', to: 'ex6a' },
                { from: 'ex6a', to: 'ex7a' },
                { from: 'ex5b', to: 'ex6b' },
                { from: 'ex6b', to: 'ex7b' }
            ];
            
            // æ·»åŠ èŠ‚ç‚¹
            exampleNodes.forEach(node => {
                nodes.push(node);
                renderNode(node);
            });
            
            // æ·»åŠ è¿æ¥
            connections = exampleConnections;
            
            // ç»˜åˆ¶è¿æ¥çº¿
            setTimeout(() => {
                drawConnections();
                showResult('æˆåŠŸ', 'âœ… å·²åŠ è½½å¤±çœ ç—‡çš„ä¸­åŒ»è¯Šç–—å†³ç­–æ ‘ç¤ºä¾‹', 'success');
            }, 100);
        }
    </script>
</body>
</html>