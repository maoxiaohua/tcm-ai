<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¯è§†åŒ–å†³ç­–æ ‘æ„å»ºå™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            display: flex;
            height: 100vh;
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }

        .sidebar {
            width: 300px;
            background: #f8fafc;
            border-right: 1px solid #e2e8f0;
            padding: 20px;
            overflow-y: auto;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .right-panel {
            width: 350px;
            background: #f8fafc;
            border-left: 1px solid #e2e8f0;
            padding: 20px;
            overflow-y: auto;
        }

        .header {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .canvas-area {
            flex: 1;
            background: white;
            border-radius: 8px;
            position: relative;
            overflow: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-height: 500px;
        }

        .section-title {
            font-size: 16px;
            font-weight: 600;
            color: #1e40af;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            color: #374151;
            font-weight: 500;
        }

        .form-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
        }

        .form-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .form-textarea {
            min-height: 80px;
            resize: vertical;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
        }

        .btn-success {
            background: #22c55e;
            color: white;
        }

        .btn-success:hover {
            background: #16a34a;
        }

        .btn-warning {
            background: #f59e0b;
            color: white;
        }

        .btn-warning:hover {
            background: #d97706;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .canvas {
            width: 100%;
            height: 100%;
            position: relative;
            padding: 20px;
            background: #fafbfc;
        }

        .canvas svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        .branch-line {
            stroke: #3b82f6;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }

        .branch-line.selected {
            stroke: #ef4444;
            stroke-width: 3;
        }

        .node {
            position: absolute;
            min-width: 120px;
            min-height: 60px;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 10px;
            cursor: move;
            user-select: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 10;
        }

        .node:hover {
            border-color: #3b82f6;
        }

        .node.selected {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .node.symptom { border-left: 4px solid #f59e0b; }
        .node.condition { border-left: 4px solid #0ea5e9; }
        .node.diagnosis { border-left: 4px solid #22c55e; }
        .node.treatment { border-left: 4px solid #ec4899; }
        .node.formula { border-left: 4px solid #a855f7; }

        .node-title {
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .node-content {
            font-size: 11px;
            color: #6b7280;
            word-break: break-word;
        }

        /* ç›¸å…³ç—‡çŠ¶æ ·å¼ */
        .related-symptoms {
            margin-top: 8px;
            padding: 6px 8px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 4px;
            border-left: 3px solid #3b82f6;
        }

        .symptoms-label {
            font-size: 10px;
            color: #3b82f6;
            font-weight: 500;
            margin-bottom: 3px;
        }

        .symptoms-list {
            font-size: 10px;
            color: #1e40af;
            line-height: 1.3;
        }

        .node-desc {
            margin-top: 5px;
            font-size: 10px;
            color: #9ca3af;
            font-style: italic;
        }

        .empty-canvas {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #9ca3af;
            text-align: center;
        }

        .loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-content {
            text-align: center;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f4f6;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .result-panel {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .result-title {
            font-weight: 600;
            color: #1e40af;
            margin-bottom: 10px;
        }

        .auth-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, #3b82f6, #1e40af);
            color: white;
            padding: 10px 20px;
            font-size: 12px;
            z-index: 10000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .container.with-auth {
            margin-top: 45px;
            height: calc(100vh - 45px);
        }

        .suggestion-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .suggestion-item:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
        }

        .suggestion-content {
            font-weight: 500;
            color: #1e40af;
            margin-bottom: 4px;
        }

        .suggestion-desc {
            font-size: 12px;
            color: #6b7280;
        }

        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            min-width: 150px;
        }

        .context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #f1f5f9;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:last-child {
            border-bottom: none;
        }

        .context-menu-item:hover {
            background: #f8fafc;
        }

        .context-menu-item.danger {
            color: #ef4444;
        }

        .context-menu-item.danger:hover {
            background: #fef2f2;
        }

        .delete-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 12px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }

        .node:hover .delete-btn {
            display: flex;
        }

        .formula-analysis-panel {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .herb-item {
            display: inline-block;
            background: white;
            border: 1px solid #0ea5e9;
            border-radius: 15px;
            padding: 4px 8px;
            margin: 2px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .herb-item:hover {
            background: #0ea5e9;
            color: white;
        }

        .apply-formula-btn {
            background: #22c55e;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 12px;
            cursor: pointer;
            margin-top: 10px;
        }

        .apply-formula-btn:hover {
            background: #16a34a;
        }

        .auto-analysis-panel {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .pathway-step {
            background: white;
            border-left: 4px solid #3b82f6;
            padding: 10px;
            margin: 8px 0;
            border-radius: 0 6px 6px 0;
        }

        .add-pathway-btn {
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 11px;
            cursor: pointer;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div id="authBar"></div>
    <div class="container" id="mainContainer">
        <!-- å·¦ä¾§å·¥å…·æ  -->
        <div class="sidebar">
            <!-- åŸºæœ¬ä¿¡æ¯ -->
            <div class="section-title">ğŸ¥ åŸºæœ¬ä¿¡æ¯</div>
            <div class="form-group">
                <label class="form-label">ç–¾ç—…åç§°</label>
                <input type="text" class="form-input" id="diseaseName" placeholder="å¦‚ï¼šå¤±çœ ã€èƒƒç—›ã€å¤´ç—›">
            </div>
            <div class="form-group">
                <label class="form-label">è¯Šç–—æ€è·¯</label>
                <textarea class="form-input form-textarea" id="doctorThought" placeholder="ç®€è¿°æ‚¨çš„è¯Šç–—æ€è·¯..."></textarea>
            </div>

            <!-- AIåŠŸèƒ½ -->
            <div class="section-title">ğŸ¤– AIåŠŸèƒ½</div>
            <div class="btn-group">
                <button class="btn btn-primary" id="generateBtn">ğŸš€ AIç”Ÿæˆå†³ç­–æ ‘</button>
                <button class="btn btn-warning" id="analyzeBtn">ğŸ§  ç†è®ºåˆ†æ</button>
                <button class="btn btn-success" id="suggestBtn">ğŸ’¡ é—æ¼æ£€æµ‹</button>
            </div>
            <div class="btn-group">
                <button class="btn btn-warning" id="symptomDetectBtn" style="background: #f59e0b;">ğŸ” ç—‡çŠ¶é—æ¼æ£€æµ‹</button>
                <button class="btn btn-primary" id="formulaAnalyzeBtn" style="background: #a855f7;">ğŸ’Š æ–¹å‰‚AIåˆ†æ</button>
            </div>
            <div class="btn-group">
                <button class="btn btn-success" id="autoPathwayBtn" style="background: #059669;">ğŸ¤– æ™ºèƒ½è¯Šç–—è·¯å¾„</button>
                <button class="btn btn-warning" id="syndromeAnalyzeBtn" style="background: #d97706;">ğŸ¯ è¯å‹æ™ºèƒ½è¯†åˆ«</button>
            </div>

            <!-- å¿«é€Ÿæ“ä½œ -->
            <div class="section-title">âš¡ å¿«é€Ÿæ“ä½œ</div>
            <div class="btn-group">
                <button class="btn btn-primary" id="addPathBtn">ğŸ“‹ æ ‡å‡†è·¯å¾„</button>
                <button class="btn btn-success" id="arrangeBtn">ğŸ“ è‡ªåŠ¨æ’åˆ—</button>
                <button class="btn btn-danger" id="clearBtn">ğŸ—‘ï¸ æ¸…ç©ºç”»å¸ƒ</button>
            </div>

            <!-- ä¿å­˜å¯¼å‡º -->
            <div class="section-title">ğŸ’¾ ä¿å­˜å¯¼å‡º</div>
            <div class="btn-group">
                <button class="btn btn-success" id="saveBtn">ğŸ’¾ ä¿å­˜å†³ç­–æ ‘</button>
                <button class="btn btn-primary" id="exportBtn">ğŸ“„ å¯¼å‡ºJSON</button>
            </div>

            <!-- é€‰ä¸­èŠ‚ç‚¹ä¿¡æ¯ -->
            <div id="selectedNodeInfo" style="display: none;">
                <div class="section-title">ğŸ“ é€‰ä¸­èŠ‚ç‚¹</div>
                <div class="result-panel">
                    <div id="nodeInfoContent"></div>
                </div>
            </div>
        </div>

        <!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
        <div class="main-content">
            <div class="header">
                <h1 style="color: #1e40af; margin-bottom: 10px;">ğŸŒ³ å¯è§†åŒ–å†³ç­–æ ‘æ„å»ºå™¨</h1>
                <p style="color: #6b7280; font-size: 14px;">æ„å»ºä¸­åŒ»æ™ºèƒ½è¯Šç–—å†³ç­–æ ‘ï¼Œæ”¯æŒAIç”Ÿæˆå’Œå¯è§†åŒ–ç¼–è¾‘</p>
            </div>

            <div class="canvas-area">
                <div class="canvas" id="canvas">
                    <svg id="branchSvg">
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#3b82f6" />
                            </marker>
                        </defs>
                    </svg>
                    <div class="empty-canvas" id="emptyHint">
                        <div style="font-size: 48px; margin-bottom: 20px;">ğŸŒ³</div>
                        <h3>å¼€å§‹æ„å»ºæ‚¨çš„å†³ç­–æ ‘</h3>
                        <p style="margin: 10px 0;">è¾“å…¥ç–¾ç—…åç§°ï¼Œç„¶åç‚¹å‡»"AIç”Ÿæˆå†³ç­–æ ‘"</p>
                        <p style="color: #9ca3af; font-size: 12px;">æˆ–ç‚¹å‡»"æ ‡å‡†è·¯å¾„"å¿«é€Ÿå¼€å§‹</p>
                    </div>
                </div>
                <div class="loading" id="loading" style="display: none;">
                    <div class="loading-content">
                        <div class="spinner"></div>
                        <div id="loadingText">åŠ è½½ä¸­...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- å³ä¾§åˆ†æç»“æœé¢æ¿ -->
        <div class="right-panel">
            <div class="section-title">ğŸ“Š åˆ†æç»“æœ</div>
            <div id="analysisResults"></div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let nodes = [];
        let selectedNode = null;
        let nodeCounter = 1;
        let isAuthenticated = false;
        let currentUser = null;
        let connections = [];
        let symptomClusters = new Map(); // ç—‡çŠ¶ç¾¤å­˜å‚¨
        
        // ç—‡çŠ¶ç¾¤æ•°æ®ç»“æ„
        const SYMPTOM_CLUSTER_TEMPLATES = {
            'å¤±çœ ç¾¤': {
                mainDisease: 'å¤±çœ ',
                icon: 'ğŸ˜´',
                color: '#8b5cf6',
                relatedSymptoms: ['æ—©é†’', 'å¤šæ¢¦', 'å…¥ç¡å›°éš¾', 'ç¡çœ æµ…', 'æ˜“æƒŠé†’'],
                accompanyingSymptoms: ['å¿ƒçƒ¦', 'å¥å¿˜', 'å¤´æ™•', 'ç–²ä¹']
            },
            'èƒƒç—›ç¾¤': {
                mainDisease: 'èƒƒç—›',
                icon: 'ğŸ¤¢',
                color: '#f59e0b',
                relatedSymptoms: ['èƒƒèƒ€', 'åé…¸', 'å—³æ°”', 'æ¶å¿ƒ', 'èƒƒè„ç–¼ç—›'],
                accompanyingSymptoms: ['é£Ÿæ¬²ä¸æŒ¯', 'ä¹åŠ›', 'è…¹èƒ€', 'ä¾¿ç§˜']
            }
        };

        // è¾…åŠ©å‡½æ•°ï¼šè·å–ç–¾ç—…åç§°
        function getCurrentDiseaseName() {
            const value = document.getElementById('diseaseName')?.value?.trim() || '';
            // æ¼”ç¤ºï¼šæ·»åŠ è¾“å…¥éªŒè¯
            if (value && value.length < 2) {
                console.warn('ç–¾ç—…åç§°è¿‡çŸ­ï¼Œå»ºè®®è‡³å°‘2ä¸ªå­—ç¬¦');
                return '';
            }
            return value;
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            console.log('é¡µé¢åˆå§‹åŒ–å¼€å§‹...');
            console.log('æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨:');
            console.log('generateBtn:', document.getElementById('generateBtn'));
            console.log('analyzeBtn:', document.getElementById('analyzeBtn'));
            console.log('diseaseName:', document.getElementById('diseaseName'));
            
            // ç®€å•æµ‹è¯•ï¼šç›´æ¥ç»‘å®šä¸€ä¸ªç®€å•çš„ç‚¹å‡»äº‹ä»¶
            const testBtn = document.getElementById('generateBtn');
            if (testBtn) {
                console.log('å°è¯•ç»‘å®šç®€å•æµ‹è¯•äº‹ä»¶...');
                testBtn.onclick = function() {
                    console.log('ç®€å•ç‚¹å‡»äº‹ä»¶å·¥ä½œæ­£å¸¸!');
                    alert('æŒ‰é’®ç‚¹å‡»æˆåŠŸ!');
                    return false;
                };
            }
            
            try {
                initializeAuth();
                initializeEventListeners();
                checkURLParameters();
                console.log('é¡µé¢åˆå§‹åŒ–å®Œæˆ');
            } catch (error) {
                console.error('é¡µé¢åˆå§‹åŒ–å‡ºé”™:', error);
            }
        });

        // åˆå§‹åŒ–è®¤è¯çŠ¶æ€
        async function initializeAuth() {
            const urlParams = new URLSearchParams(window.location.search);
            
            if (urlParams.get('auto_auth') === '1') {
                const doctorToken = urlParams.get('doctor_token');
                const doctorName = decodeURIComponent(urlParams.get('doctor_name') || '');
                
                if (doctorToken && doctorName) {
                    localStorage.setItem('token', doctorToken);
                    localStorage.setItem('doctorToken', doctorToken);
                    localStorage.setItem('doctorName', doctorName);
                    
                    showAuthStatus(doctorName, true);
                    
                    // æ¸…ç†URLå‚æ•°
                    const cleanUrl = window.location.pathname;
                    window.history.replaceState({}, document.title, cleanUrl);
                }
            } else {
                await checkExistingAuth();
            }
        }

        // æ£€æŸ¥ç°æœ‰è®¤è¯çŠ¶æ€
        async function checkExistingAuth() {
            const token = localStorage.getItem('token');
            if (!token) return;

            try {
                const response = await fetch('/api/doctor/current', {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    showAuthStatus(data.name, true);
                    isAuthenticated = true;
                    currentUser = data;
                }
            } catch (error) {
                console.log('è®¤è¯æ£€æŸ¥å¤±è´¥:', error);
            }
        }

        // æ˜¾ç¤ºè®¤è¯çŠ¶æ€
        function showAuthStatus(doctorName, isLoggedIn) {
            const authBar = document.getElementById('authBar');
            const container = document.getElementById('mainContainer');
            
            if (isLoggedIn) {
                authBar.className = 'auth-bar';
                authBar.innerHTML = `
                    âœ… å·²ç™»å½•åŒ»ç”Ÿ: ${doctorName} | å†³ç­–æ ‘å°†è‡ªåŠ¨ä¿å­˜åˆ°æ‚¨çš„è´¦æˆ·
                    <button onclick="logout()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 4px 12px; border-radius: 4px; margin-left: 20px; cursor: pointer; font-size: 12px;">é€€å‡ºç™»å½•</button>
                `;
                container.classList.add('with-auth');
                isAuthenticated = true;
            }
        }

        // é€€å‡ºç™»å½•
        function logout() {
            localStorage.removeItem('token');
            localStorage.removeItem('doctorToken');
            localStorage.removeItem('doctorName');
            document.getElementById('authBar').innerHTML = '';
            document.getElementById('mainContainer').classList.remove('with-auth');
            isAuthenticated = false;
            currentUser = null;
        }

        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
        function initializeEventListeners() {
            try {
                // AIåŠŸèƒ½æŒ‰é’®
                document.getElementById('generateBtn').addEventListener('click', generateAITree);
                document.getElementById('analyzeBtn').addEventListener('click', analyzeCurrentTree);
                document.getElementById('suggestBtn').addEventListener('click', suggestMissingLogic);
                
                // ä¸“ä¸šåŠŸèƒ½æŒ‰é’®
                document.getElementById('symptomDetectBtn').addEventListener('click', detectMissingSymptoms);
                document.getElementById('formulaAnalyzeBtn').addEventListener('click', analyzeFormula);
                
                // å¿«é€Ÿæ“ä½œæŒ‰é’®
                const autoPathwayBtn = document.getElementById('autoPathwayBtn');
                if (autoPathwayBtn) autoPathwayBtn.addEventListener('click', generateAutoPathway);
                
                const syndromeAnalyzeBtn = document.getElementById('syndromeAnalyzeBtn');
                if (syndromeAnalyzeBtn) syndromeAnalyzeBtn.addEventListener('click', analyzeSyndrome);
                
                // å¿«é€Ÿæ“ä½œæŒ‰é’®
                const addPathBtn = document.getElementById('addPathBtn');
                if (addPathBtn) addPathBtn.addEventListener('click', addStandardPath);
                
                const arrangeBtn = document.getElementById('arrangeBtn');
                if (arrangeBtn) {
                    arrangeBtn.onclick = function(e) {
                        e.preventDefault();
                        console.log('arrangeBtnè¢«ç‚¹å‡»äº†!');
                        autoArrangeNodes();
                        return false;
                    };
                }
                
                const clearBtn = document.getElementById('clearBtn');
                if (clearBtn) {
                    clearBtn.onclick = function(e) {
                        e.preventDefault();
                        console.log('clearBtnè¢«ç‚¹å‡»äº†!');
                        clearCanvas();
                        return false;
                    };
                }
            
                // ä¿å­˜å¯¼å‡ºæŒ‰é’®
                const saveBtn = document.getElementById('saveBtn');
                if (saveBtn) saveBtn.addEventListener('click', saveDecisionTree);
                
                const exportBtn = document.getElementById('exportBtn');
                if (exportBtn) exportBtn.addEventListener('click', exportJSON);

                // å…¨å±€äº‹ä»¶
                document.addEventListener('contextmenu', hideContextMenu);
                document.addEventListener('click', hideContextMenu);
                
                console.log('äº‹ä»¶ç›‘å¬å™¨åˆå§‹åŒ–å®Œæˆ');
            } catch (error) {
                console.error('äº‹ä»¶ç›‘å¬å™¨åˆå§‹åŒ–å¤±è´¥:', error);
            }
        }

        // AIç”Ÿæˆå†³ç­–æ ‘
        async function generateAITree() {
            console.log('AIç”Ÿæˆå†³ç­–æ ‘è¢«è°ƒç”¨');
            
            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            if (!getCurrentDiseaseName()) {
                alert('è¯·å…ˆè¾“å…¥ç–¾ç—…åç§°');
                return;
            }

            const doctorThought = document.getElementById('doctorThought').value.trim();
            
            showLoading('AIæ­£åœ¨ç”Ÿæˆå†³ç­–æ ‘...');

            try {
                const response = await fetch('/api/generate_visual_decision_tree', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        disease_name: getCurrentDiseaseName(),
                        thinking_process: doctorThought || `è¯·ä¸º${getCurrentDiseaseName()}ç”Ÿæˆæ ‡å‡†çš„ä¸­åŒ»è¯Šç–—å†³ç­–æ ‘`,
                        include_tcm_analysis: true,
                        complexity_level: 'standard'
                    })
                });

                const data = await response.json();
                
                if (data.success && data.data && data.data.paths) {
                    generateNodesFromPaths(data.data.paths);
                    hideLoading();
                    showResult('æˆåŠŸ', `âœ… AIæˆåŠŸç”Ÿæˆäº†${data.data.paths.length}æ¡è¯Šç–—è·¯å¾„ï¼`, 'success');
                } else {
                    throw new Error(data.message || 'ç”Ÿæˆå¤±è´¥');
                }
            } catch (error) {
                console.error('AIç”Ÿæˆå¤±è´¥:', error);
                hideLoading();
                showResult('é”™è¯¯', `âŒ ç”Ÿæˆå¤±è´¥: ${error.message}`, 'error');
            }
        }

        // ä»AIè·¯å¾„æ•°æ®ç”ŸæˆèŠ‚ç‚¹
        function generateNodesFromPaths(paths) {
            clearCanvas();
            
            let x = 50, y = 50;
            const stepWidth = 200;
            const pathHeight = 120;
            
            paths.forEach((path, pathIndex) => {
                let previousNode = null;
                
                path.steps.forEach((step, stepIndex) => {
                    const nodeId = `node_${pathIndex}_${stepIndex}`;
                    const node = {
                        id: nodeId,
                        type: step.type,
                        name: step.content,
                        description: step.content,
                        x: x + (stepIndex * stepWidth),
                        y: y + (pathIndex * pathHeight)
                    };
                    
                    nodes.push(node);
                    renderNode(node);
                    
                    // åˆ›å»ºè¿æ¥
                    if (previousNode) {
                        connections.push({
                            from: previousNode.id,
                            to: nodeId
                        });
                    }
                    
                    previousNode = node;
                });
            });
            
            updateCanvas();
            drawConnections();
        }

        // åˆ†æå½“å‰å†³ç­–æ ‘
        async function analyzeCurrentTree() {
            console.log('åˆ†æå½“å‰å†³ç­–æ ‘è¢«è°ƒç”¨');
            
            if (nodes.length === 0) {
                alert('è¯·å…ˆåˆ›å»ºæˆ–ç”Ÿæˆå†³ç­–æ ‘');
                return;
            }

            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            if (!getCurrentDiseaseName()) {
                alert('è¯·å…ˆè¾“å…¥ç–¾ç—…åç§°');
                return;
            }

            showLoading('æ­£åœ¨è¿›è¡Œä¸­åŒ»ç†è®ºåˆ†æ...');

            try {
                const treeData = {
                    disease_name: getCurrentDiseaseName(),
                    nodes: nodes
                };

                const response = await fetch('/api/analyze_tree_tcm_theory', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        tree_data: treeData,
                        disease_name: getCurrentDiseaseName()
                    })
                });

                const data = await response.json();
                
                if (data.success && data.data) {
                    hideLoading();
                    showAnalysisResult(data.data.analysis || 'åˆ†æå®Œæˆ');
                } else {
                    throw new Error(data.message || 'åˆ†æå¤±è´¥');
                }
            } catch (error) {
                console.error('ç†è®ºåˆ†æå¤±è´¥:', error);
                hideLoading();
                showResult('é”™è¯¯', `âŒ åˆ†æå¤±è´¥: ${error.message}`, 'error');
            }
        }

        // å»ºè®®é—æ¼é€»è¾‘
        async function suggestMissingLogic() {
            console.log('å»ºè®®é—æ¼é€»è¾‘è¢«è°ƒç”¨');
            
            if (nodes.length === 0) {
                alert('è¯·å…ˆåˆ›å»ºæˆ–ç”Ÿæˆå†³ç­–æ ‘');
                return;
            }

            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            if (!getCurrentDiseaseName()) {
                alert('è¯·å…ˆè¾“å…¥ç–¾ç—…åç§°');
                return;
            }

            showLoading('æ­£åœ¨æ£€æµ‹é—æ¼é€»è¾‘...');

            try {
                const response = await fetch('/api/detect_missing_logic', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        disease_name: getCurrentDiseaseName(),
                        current_paths: [],
                        existing_nodes: nodes
                    })
                });

                const data = await response.json();
                
                if (data.success && data.data) {
                    hideLoading();
                    showMissingLogicResult(data.data);
                } else {
                    throw new Error(data.message || 'æ£€æµ‹å¤±è´¥');
                }
            } catch (error) {
                console.error('é—æ¼é€»è¾‘æ£€æµ‹å¤±è´¥:', error);
                hideLoading();
                showResult('é”™è¯¯', `âŒ æ£€æµ‹å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ·»åŠ æ ‡å‡†è·¯å¾„
        function addStandardPath() {
            console.log('æ·»åŠ æ ‡å‡†è·¯å¾„è¢«è°ƒç”¨');
            
            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            
            clearCanvas();
            
            // æ£€æŸ¥æ˜¯å¦åº”è¯¥åˆ›å»ºç—‡çŠ¶ç¾¤
            const template = SYMPTOM_CLUSTER_TEMPLATES[`${getCurrentDiseaseName()}ç¾¤`];
            if (template) {
                // åˆ›å»ºç—‡çŠ¶ç¾¤æ¨¡å¼
                // TODO: ä¼˜åŒ–åæ·»åŠ ç—‡çŠ¶ç¾¤åŠŸèƒ½
                
                // åˆ›å»ºåç»­èŠ‚ç‚¹
                const followUpNodes = [
                    { type: 'diagnosis', name: 'ä¸­åŒ»è¯Šæ–­', description: 'è¾¨è¯åˆ†å‹', x: 400, y: 150 },
                    { type: 'treatment', name: 'æ²»ç–—æ–¹æ³•', description: 'æ²»åˆ™æ²»æ³•', x: 650, y: 150 },
                    { type: 'formula', name: 'æ–¹å‰‚é€‰æ‹©', description: 'å…·ä½“æ–¹è¯', x: 900, y: 150 }
                ];
                
                let previousNode = null;
                followUpNodes.forEach((nodeData, index) => {
                    const node = {
                        id: `std_${index + 2}`,
                        ...nodeData
                    };
                    nodes.push(node);
                    renderNode(node);
                    previousNode = node;
                });
            } else {
                // ä¼ ç»Ÿæ¨¡å¼ - åˆ›å»ºæ ‡å‡†è·¯å¾„èŠ‚ç‚¹
                const standardNodes = [
                    { type: 'symptom', name: `${getCurrentDiseaseName()}`, description: 'ä¸»è¦ç—‡çŠ¶', x: 50, y: 100 },
                    { type: 'condition', name: 'ç—‡çŠ¶åˆ¤æ–­', description: 'è¯„ä¼°ç—‡çŠ¶ä¸¥é‡ç¨‹åº¦', x: 300, y: 100 },
                    { type: 'diagnosis', name: 'ä¸­åŒ»è¯Šæ–­', description: 'è¾¨è¯åˆ†å‹', x: 550, y: 100 },
                    { type: 'treatment', name: 'æ²»ç–—æ–¹æ³•', description: 'æ²»åˆ™æ²»æ³•', x: 800, y: 100 },
                    { type: 'formula', name: 'æ–¹å‰‚é€‰æ‹©', description: 'å…·ä½“æ–¹è¯', x: 1050, y: 100 }
                ];
                
                let previousNode = null;
                standardNodes.forEach((nodeData, index) => {
                    const node = {
                        id: `std_${index + 1}`,
                        ...nodeData
                    };
                    nodes.push(node);
                    renderNode(node);
                    
                    // åˆ›å»ºè¿æ¥
                    if (previousNode) {
                        connections.push({
                            from: previousNode.id,
                            to: node.id
                        });
                    }
                    
                    previousNode = node;
                });
            }
            
            let previousNode = null;
            standardNodes.forEach((nodeData, index) => {
                const node = {
                    id: `std_${index + 1}`,
                    ...nodeData
                };
                nodes.push(node);
                renderNode(node);
                
                // åˆ›å»ºè¿æ¥
                if (previousNode) {
                    connections.push({
                        from: previousNode.id,
                        to: node.id
                    });
                }
                
                previousNode = node;
            });
            
            updateCanvas();
            drawConnections();
            showResult('æˆåŠŸ', 'âœ… æ ‡å‡†è¯Šç–—è·¯å¾„å·²æ·»åŠ ', 'success');
        }

        // è‡ªåŠ¨æ’åˆ—èŠ‚ç‚¹
        function autoArrangeNodes() {
            console.log('è‡ªåŠ¨æ’åˆ—èŠ‚ç‚¹è¢«è°ƒç”¨');
            
            if (nodes.length === 0) {
                showResult('æç¤º', 'æ²¡æœ‰èŠ‚ç‚¹éœ€è¦æ’åˆ—', 'info');
                return;
            }

            // ç®€å•çš„ç½‘æ ¼æ’åˆ—
            const cols = 4;
            const startX = 50;
            const startY = 50;
            const stepX = 250;
            const stepY = 120;

            nodes.forEach((node, index) => {
                const row = Math.floor(index / cols);
                const col = index % cols;
                
                node.x = startX + (col * stepX);
                node.y = startY + (row * stepY);
                
                const element = document.getElementById(node.id);
                if (element) {
                    element.style.left = `${node.x}px`;
                    element.style.top = `${node.y}px`;
                }
            });
            
            // é‡ç»˜è¿æ¥çº¿
            drawConnections();
            showResult('æˆåŠŸ', `âœ… å·²è‡ªåŠ¨æ’åˆ—${nodes.length}ä¸ªèŠ‚ç‚¹`, 'success');
        }

        // æ¸…ç©ºç”»å¸ƒ
        function clearCanvas() {
            console.log('æ¸…ç©ºç”»å¸ƒè¢«è°ƒç”¨');
            
            nodes = [];
            selectedNode = null;
            connections = [];
            
            const canvas = document.getElementById('canvas');
            canvas.innerHTML = `
                <svg id="branchSvg">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#3b82f6" />
                        </marker>
                    </defs>
                </svg>
                <div class="empty-canvas" id="emptyHint">
                    <div style="font-size: 48px; margin-bottom: 20px;">ğŸŒ³</div>
                    <h3>å¼€å§‹æ„å»ºæ‚¨çš„å†³ç­–æ ‘</h3>
                    <p style="margin: 10px 0;">è¾“å…¥ç–¾ç—…åç§°ï¼Œç„¶åç‚¹å‡»"AIç”Ÿæˆå†³ç­–æ ‘"</p>
                    <p style="color: #9ca3af; font-size: 12px;">æˆ–ç‚¹å‡»"æ ‡å‡†è·¯å¾„"å¿«é€Ÿå¼€å§‹</p>
                </div>
            `;
            
            clearResults();
            hideSelectedNodeInfo();
            showResult('æˆåŠŸ', 'âœ… ç”»å¸ƒå·²æ¸…ç©º', 'success');
        }

        // ä¿å­˜å†³ç­–æ ‘
        async function saveDecisionTree() {
            console.log('ä¿å­˜å†³ç­–æ ‘è¢«è°ƒç”¨');
            
            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            if (!getCurrentDiseaseName()) {
                alert('è¯·å…ˆè¾“å…¥ç–¾ç—…åç§°');
                return;
            }

            if (nodes.length === 0) {
                alert('è¯·å…ˆæ„å»ºå†³ç­–æ ‘');
                return;
            }

            if (!isAuthenticated) {
                alert('è¯·å…ˆç™»å½•åŒ»ç”Ÿè´¦æˆ·');
                return;
            }

            showLoading('æ­£åœ¨ä¿å­˜å†³ç­–æ ‘...');

            try {
                const saveData = {
                    disease_name: getCurrentDiseaseName(),
                    paths: convertNodesToPaths(),
                    integration_enabled: true
                };

                const response = await fetch('/api/save_decision_tree_v3', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify(saveData)
                });

                const data = await response.json();
                
                if (data.success) {
                    hideLoading();
                    showResult('æˆåŠŸ', `âœ… å†³ç­–æ ‘å·²ä¿å­˜ï¼åŒ…å«${nodes.length}ä¸ªèŠ‚ç‚¹`, 'success');
                } else {
                    throw new Error(data.message || 'ä¿å­˜å¤±è´¥');
                }
            } catch (error) {
                console.error('ä¿å­˜å¤±è´¥:', error);
                hideLoading();
                showResult('é”™è¯¯', `âŒ ä¿å­˜å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // å¯¼å‡ºJSON
        function exportJSON() {
            console.log('å¯¼å‡ºJSONè¢«è°ƒç”¨');
            
            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            
            const exportData = {
                disease_name: getCurrentDiseaseName() || 'æœªå‘½åç–¾ç—…',
                nodes: nodes,
                exported_at: new Date().toISOString(),
                version: '2.0'
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `å†³ç­–æ ‘_${getCurrentDiseaseName() || 'æœªå‘½å'}_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
            showResult('æˆåŠŸ', 'âœ… JSONæ–‡ä»¶å·²ä¸‹è½½', 'success');
        }

        // æ¸²æŸ“èŠ‚ç‚¹
        function renderNode(node) {
            const canvas = document.getElementById('canvas');
            const emptyHint = document.getElementById('emptyHint');
            
            if (emptyHint) {
                emptyHint.remove();
            }

            const nodeElement = document.createElement('div');
            nodeElement.className = `node ${node.type}`;
            nodeElement.id = node.id;
            nodeElement.style.left = `${node.x}px`;
            nodeElement.style.top = `${node.y}px`;
            
            // æ„å»ºèŠ‚ç‚¹å†…å®¹ï¼Œæ”¯æŒç›¸å…³ç—‡çŠ¶æ˜¾ç¤º
            let nodeContent = node.description || '';
            if (node.relatedSymptoms && node.relatedSymptoms.length > 0) {
                nodeContent = `${nodeContent}
                    <div class="related-symptoms">
                        <div class="symptoms-label">ç›¸å…³ç—‡çŠ¶:</div>
                        <div class="symptoms-list">${node.relatedSymptoms.join(', ')}</div>
                    </div>`;
            }
            
            nodeElement.innerHTML = `
                <button class="delete-btn" onclick="deleteNodeById('${node.id}')">Ã—</button>
                <div class="node-title">${node.name}</div>
                <div class="node-content">${nodeContent}</div>
            `;
            
            // æ·»åŠ ç‚¹å‡»äº‹ä»¶
            nodeElement.addEventListener('click', function(e) {
                e.stopPropagation();
                selectNode(node);
            });
            
            // æ·»åŠ å³é”®èœå•äº‹ä»¶
            nodeElement.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                e.stopPropagation();
                showContextMenu(e, node);
            });
            
            // æ·»åŠ æ‹–æ‹½
            makeNodeDraggable(nodeElement, node);
            
            canvas.appendChild(nodeElement);
        }

        // é€‰æ‹©èŠ‚ç‚¹
        function selectNode(node) {
            // æ¸…é™¤å…¶ä»–é€‰æ‹©
            document.querySelectorAll('.node').forEach(el => {
                el.classList.remove('selected');
            });
            
            // é€‰æ‹©å½“å‰èŠ‚ç‚¹
            document.getElementById(node.id).classList.add('selected');
            selectedNode = node;
            
            showSelectedNodeInfo(node);
            console.log('é€‰æ‹©äº†èŠ‚ç‚¹:', node.name);
        }

        // ä½¿èŠ‚ç‚¹å¯æ‹–æ‹½
        function makeNodeDraggable(element, node) {
            let isDragging = false;
            let startX, startY, startNodeX, startNodeY;

            element.addEventListener('mousedown', function(e) {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startNodeX = node.x;
                startNodeY = node.y;
                
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            });

            function handleMouseMove(e) {
                if (!isDragging) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                node.x = Math.max(0, startNodeX + deltaX);
                node.y = Math.max(0, startNodeY + deltaY);
                
                updateNodePosition(node);
            }

            function handleMouseUp() {
                isDragging = false;
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            }
        }

        // æ›´æ–°èŠ‚ç‚¹ä½ç½®
        function updateNodePosition(node) {
            const element = document.getElementById(node.id);
            if (element) {
                element.style.left = `${node.x}px`;
                element.style.top = `${node.y}px`;
            }
        }

        // è½¬æ¢èŠ‚ç‚¹ä¸ºè·¯å¾„æ ¼å¼
        function convertNodesToPaths() {
            if (nodes.length === 0) return [];
            
            return [{
                id: 'path_1',
                steps: nodes.map(node => ({
                    type: node.type,
                    content: node.name
                })),
                keywords: [document.getElementById('diseaseName').value.trim()],
                created_by: currentUser?.name || 'åŒ¿åç”¨æˆ·'
            }];
        }

        // æ›´æ–°ç”»å¸ƒçŠ¶æ€
        function updateCanvas() {
            const canvas = document.getElementById('canvas');
            const emptyHint = document.getElementById('emptyHint');
            
            if (nodes.length === 0 && !emptyHint) {
                canvas.innerHTML = `
                    <div class="empty-canvas" id="emptyHint">
                        <div style="font-size: 48px; margin-bottom: 20px;">ğŸŒ³</div>
                        <h3>å¼€å§‹æ„å»ºæ‚¨çš„å†³ç­–æ ‘</h3>
                        <p style="margin: 10px 0;">è¾“å…¥ç–¾ç—…åç§°ï¼Œç„¶åç‚¹å‡»"AIç”Ÿæˆå†³ç­–æ ‘"</p>
                        <p style="color: #9ca3af; font-size: 12px;">æˆ–ç‚¹å‡»"æ ‡å‡†è·¯å¾„"å¿«é€Ÿå¼€å§‹</p>
                    </div>
                `;
            }
        }

        // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        function showLoading(message) {
            const loading = document.getElementById('loading');
            const loadingText = document.getElementById('loadingText');
            
            loadingText.textContent = message;
            loading.style.display = 'flex';
        }

        // éšè—åŠ è½½çŠ¶æ€
        function hideLoading() {
            const loading = document.getElementById('loading');
            loading.style.display = 'none';
        }

        // æ˜¾ç¤ºç»“æœ
        function showResult(title, message, type) {
            const resultsDiv = document.getElementById('analysisResults');
            
            const typeColors = {
                success: '#22c55e',
                error: '#ef4444',
                warning: '#f59e0b',
                info: '#3b82f6'
            };
            
            const color = typeColors[type] || typeColors.info;
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = `
                <div class="result-title" style="color: ${color};">${title}</div>
                <div style="font-size: 13px; color: #374151;">${message}</div>
            `;
            
            resultsDiv.appendChild(resultElement);
            
            // 5ç§’åè‡ªåŠ¨ç§»é™¤æˆåŠŸæ¶ˆæ¯
            if (type === 'success') {
                setTimeout(() => {
                    resultElement.remove();
                }, 5000);
            }
        }

        // æ˜¾ç¤ºåˆ†æç»“æœ
        function showAnalysisResult(analysisHtml) {
            // æ¸…é™¤ä¹‹å‰çš„ç»“æœï¼Œé¿å…é‡å¤
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = `
                <div class="result-title">ğŸ§  ä¸­åŒ»ç†è®ºåˆ†æç»“æœ</div>
                <div style="font-size: 13px;">${analysisHtml}</div>
            `;
            
            resultsDiv.appendChild(resultElement);
        }

        // æ˜¾ç¤ºé—æ¼é€»è¾‘ç»“æœ
        function showMissingLogicResult(data) {
            // æ¸…é™¤ä¹‹å‰çš„ç»“æœï¼Œé¿å…é‡å¤
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            let html = '<div class="result-title">ğŸ’¡ é—æ¼é€»è¾‘æ£€æµ‹ç»“æœ</div>';
            
            if (data.missing_analyses && data.missing_analyses.length > 0) {
                data.missing_analyses.forEach(analysis => {
                    html += `<div style="margin: 15px 0;"><strong>${analysis.category}:</strong><br>`;
                    analysis.items.forEach(item => {
                        html += `
                            <div class="suggestion-item" onclick="addSuggestionToTree('${item.suggested_addition.step_type}', '${item.content}', '${item.description}')">
                                <div class="suggestion-content">${item.content}</div>
                                <div class="suggestion-desc">${item.description}</div>
                            </div>
                        `;
                    });
                    html += `</div>`;
                });
            } else {
                html += '<div style="color: #22c55e;">âœ… å½“å‰å†³ç­–æ ‘é€»è¾‘å®Œæ•´ï¼Œæœªå‘ç°æ˜æ˜¾é—æ¼</div>';
            }
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = html;
            
            resultsDiv.appendChild(resultElement);
        }

        // æ¸…é™¤ç»“æœ
        function clearResults() {
            const resultsDiv = document.getElementById('analysisResults');
            resultsDiv.innerHTML = '';
        }

        // ç”»å¸ƒç‚¹å‡»äº‹ä»¶
        document.addEventListener('click', function(e) {
            if (e.target.id === 'canvas') {
                // æ¸…é™¤é€‰æ‹©
                document.querySelectorAll('.node').forEach(el => {
                    el.classList.remove('selected');
                });
                selectedNode = null;
            }
        });

        // ç»˜åˆ¶è¿æ¥çº¿
        function drawConnections() {
            const svg = document.getElementById('branchSvg');
            
            // æ¸…é™¤ç°æœ‰è¿æ¥çº¿
            const existingLines = svg.querySelectorAll('.branch-line');
            existingLines.forEach(line => line.remove());
            
            connections.forEach(conn => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);
                
                if (fromNode && toNode) {
                    const fromElement = document.getElementById(fromNode.id);
                    const toElement = document.getElementById(toNode.id);
                    
                    if (fromElement && toElement) {
                        const fromRect = fromElement.getBoundingClientRect();
                        const toRect = toElement.getBoundingClientRect();
                        const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                        
                        const x1 = fromRect.left - canvasRect.left + fromRect.width;
                        const y1 = fromRect.top - canvasRect.top + fromRect.height / 2;
                        const x2 = toRect.left - canvasRect.left;
                        const y2 = toRect.top - canvasRect.top + toRect.height / 2;
                        
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', x1);
                        line.setAttribute('y1', y1);
                        line.setAttribute('x2', x2);
                        line.setAttribute('y2', y2);
                        line.setAttribute('class', 'branch-line');
                        
                        svg.appendChild(line);
                    }
                }
            });
        }

        // æ˜¾ç¤ºé€‰ä¸­èŠ‚ç‚¹ä¿¡æ¯
        function showSelectedNodeInfo(node) {
            const infoDiv = document.getElementById('selectedNodeInfo');
            const contentDiv = document.getElementById('nodeInfoContent');
            
            contentDiv.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 8px;">${node.name}</div>
                <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">ç±»å‹: ${getNodeTypeText(node.type)}</div>
                <div style="font-size: 12px; color: #374151;">${node.description}</div>
                ${selectedNode ? '<div style="margin-top: 10px; font-size: 11px; color: #059669;">ğŸ’¡ ç‚¹å‡»é—æ¼é€»è¾‘æ£€æµ‹ç»“æœä¸­çš„å»ºè®®å¯æ·»åŠ åˆ°æ­¤èŠ‚ç‚¹</div>' : ''}
            `;
            
            infoDiv.style.display = 'block';
        }

        // éšè—é€‰ä¸­èŠ‚ç‚¹ä¿¡æ¯
        function hideSelectedNodeInfo() {
            const infoDiv = document.getElementById('selectedNodeInfo');
            infoDiv.style.display = 'none';
        }

        // è·å–èŠ‚ç‚¹ç±»å‹æ–‡æœ¬
        function getNodeTypeText(type) {
            const typeMap = {
                'symptom': 'ç—‡çŠ¶',
                'condition': 'åˆ¤æ–­æ¡ä»¶',
                'diagnosis': 'è¯Šæ–­',
                'treatment': 'æ²»ç–—',
                'formula': 'æ–¹å‰‚'
            };
            return typeMap[type] || type;
        }

        // æ·»åŠ å»ºè®®åˆ°å†³ç­–æ ‘
        function addSuggestionToTree(nodeType, nodeName, description) {
            if (!selectedNode) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºæ·»åŠ ä½ç½®');
                return;
            }
            
            // æ™ºèƒ½ç—‡çŠ¶åˆå¹¶ï¼šæ£€æŸ¥æ˜¯å¦åº”è¯¥åˆå¹¶åˆ°ç°æœ‰ç—‡çŠ¶ç¾¤
            if (nodeType === 'symptom') {
                const mergeTarget = findSymptomMergeTarget(nodeName);
                if (mergeTarget) {
                    // ç»™ç”¨æˆ·ä¸€ä¸ªç¡®è®¤æç¤º
                    const isSelectedNode = mergeTarget === selectedNode;
                    const targetDescription = isSelectedNode ? 
                        `å½“å‰é€‰ä¸­çš„"${mergeTarget.name}"` : 
                        `ç°æœ‰çš„"${mergeTarget.name}"`;
                    
                    console.log(`å‡†å¤‡åˆå¹¶ç—‡çŠ¶"${nodeName}"åˆ°${targetDescription}èŠ‚ç‚¹`);
                    mergeSymptomToNode(mergeTarget, nodeName, description);
                    return;
                }
            }
            
            // å¦‚æœä¸éœ€è¦åˆå¹¶ï¼Œåˆ›å»ºæ–°çš„ç‹¬ç«‹èŠ‚ç‚¹
            const newX = selectedNode.x + 250;
            const newY = selectedNode.y + (Math.random() - 0.5) * 100; // ç¨å¾®éšæœºåç§»
            
            const newNode = {
                id: `suggested_${nodeCounter++}`,
                type: nodeType,
                name: nodeName,
                description: description,
                x: newX,
                y: newY
            };
            
            nodes.push(newNode);
            renderNode(newNode);
            
            // åˆ›å»ºè¿æ¥
            connections.push({
                from: selectedNode.id,
                to: newNode.id
            });
            
            drawConnections();
            updateCanvas();
            
            // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            showResult('æˆåŠŸ', `âœ… å·²æ·»åŠ "${nodeName}"åˆ°å†³ç­–æ ‘`, 'success');
        }

        // æ™ºèƒ½ç—‡çŠ¶åˆå¹¶ï¼šæŸ¥æ‰¾åº”è¯¥åˆå¹¶çš„ç›®æ ‡èŠ‚ç‚¹
        function findSymptomMergeTarget(newSymptom) {
            console.log(`\n=== æŸ¥æ‰¾ç—‡çŠ¶åˆå¹¶ç›®æ ‡ ===`);
            console.log(`æ–°ç—‡çŠ¶: ${newSymptom}`);
            console.log(`å½“å‰é€‰ä¸­èŠ‚ç‚¹:`, selectedNode);
            console.log(`å½“å‰é€‰ä¸­èŠ‚ç‚¹çš„ç›¸å…³ç—‡çŠ¶:`, selectedNode?.relatedSymptoms);
            
            // ç¬¬ä¸€ä¼˜å…ˆçº§ï¼šå¦‚æœå½“å‰é€‰ä¸­çš„èŠ‚ç‚¹æ˜¯ç—‡çŠ¶ç±»å‹ä¸”ä¸æ–°ç—‡çŠ¶ç›¸å…³ï¼Œç›´æ¥åˆå¹¶åˆ°é€‰ä¸­èŠ‚ç‚¹
            if (selectedNode && selectedNode.type === 'symptom') {
                console.log(`æ£€æŸ¥é€‰ä¸­èŠ‚ç‚¹æ˜¯å¦ä¸æ–°ç—‡çŠ¶ç›¸å…³...`);
                
                if (isSymptomRelated(selectedNode.name, newSymptom)) {
                    console.log(`âœ… ä¼˜å…ˆåˆå¹¶åˆ°é€‰ä¸­èŠ‚ç‚¹: ${newSymptom} -> ${selectedNode.name}`);
                    return selectedNode;
                }
                
                // æ£€æŸ¥æ˜¯å¦ç¬¦åˆç—‡çŠ¶èšç±»æ¨¡æ¿
                console.log(`æ£€æŸ¥ç—‡çŠ¶èšç±»æ¨¡æ¿...`);
                for (const [clusterName, clusterData] of Object.entries(SYMPTOM_CLUSTER_TEMPLATES)) {
                    const mainDisease = clusterData.mainDisease;
                    const relatedSymptoms = clusterData.relatedSymptoms || [];
                    
                    console.log(`æ£€æŸ¥èšç±» ${clusterName}: ä¸»ç–¾ç—…=${mainDisease}, ç›¸å…³ç—‡çŠ¶=`, relatedSymptoms);
                    
                    // å¦‚æœé€‰ä¸­èŠ‚ç‚¹æ˜¯ä¸»ç–¾ç—…ä¸”æ–°ç—‡çŠ¶åœ¨ç›¸å…³åˆ—è¡¨ä¸­
                    if ((selectedNode.name === mainDisease || selectedNode.name.includes(mainDisease)) 
                        && relatedSymptoms.includes(newSymptom)) {
                        console.log(`âœ… åŸºäºèšç±»æ¨¡æ¿åˆå¹¶åˆ°é€‰ä¸­èŠ‚ç‚¹: ${newSymptom} -> ${selectedNode.name}`);
                        return selectedNode;
                    }
                }
                
                console.log(`âŒ é€‰ä¸­èŠ‚ç‚¹ä¸æ–°ç—‡çŠ¶ä¸ç›¸å…³`);
            } else {
                console.log(`âŒ æ²¡æœ‰é€‰ä¸­ç—‡çŠ¶ç±»å‹èŠ‚ç‚¹`);
            }
            
            // ç¬¬äºŒä¼˜å…ˆçº§ï¼šåŸºäºç—‡çŠ¶èšç±»æ¨¡æ¿æŸ¥æ‰¾ä¸»ç—‡çŠ¶
            for (const [clusterName, clusterData] of Object.entries(SYMPTOM_CLUSTER_TEMPLATES)) {
                const mainDisease = clusterData.mainDisease;
                const relatedSymptoms = clusterData.relatedSymptoms || [];
                
                // å¦‚æœæ–°ç—‡çŠ¶åœ¨ç›¸å…³ç—‡çŠ¶åˆ—è¡¨ä¸­ï¼ŒæŸ¥æ‰¾å¯¹åº”çš„ä¸»ç—‡çŠ¶èŠ‚ç‚¹
                if (relatedSymptoms.includes(newSymptom)) {
                    const mainSymptomNode = nodes.find(node => 
                        node.type === 'symptom' && 
                        node !== selectedNode && // æ’é™¤å·²ç»æ£€æŸ¥è¿‡çš„é€‰ä¸­èŠ‚ç‚¹
                        (node.name === mainDisease || node.name.includes(mainDisease))
                    );
                    if (mainSymptomNode) {
                        console.log(`åŸºäºæ¨¡æ¿æ‰¾åˆ°åˆå¹¶ç›®æ ‡: ${newSymptom} -> ${mainSymptomNode.name}`);
                        return mainSymptomNode;
                    }
                }
            }
            
            // ç¬¬ä¸‰ä¼˜å…ˆçº§ï¼šåŸºäºå…³é”®è¯åŒ¹é…æŸ¥æ‰¾ç›¸ä¼¼ç—‡çŠ¶èŠ‚ç‚¹
            const existingSymptomNodes = nodes.filter(node => 
                node.type === 'symptom' && node !== selectedNode
            );
            for (const node of existingSymptomNodes) {
                if (isSymptomRelated(node.name, newSymptom)) {
                    console.log(`åŸºäºå…³é”®è¯æ‰¾åˆ°åˆå¹¶ç›®æ ‡: ${newSymptom} -> ${node.name}`);
                    return node;
                }
            }
            
            console.log(`æ²¡æœ‰æ‰¾åˆ°åˆå¹¶ç›®æ ‡ï¼Œå°†åˆ›å»ºæ–°èŠ‚ç‚¹: ${newSymptom}`);
            return null; // æ²¡æ‰¾åˆ°åˆå¹¶ç›®æ ‡ï¼Œéœ€è¦åˆ›å»ºæ–°èŠ‚ç‚¹
        }

        // åˆ¤æ–­ä¸¤ä¸ªç—‡çŠ¶æ˜¯å¦ç›¸å…³
        function isSymptomRelated(existingSymptom, newSymptom) {
            console.log(`  æ£€æŸ¥ç—‡çŠ¶å…³è”æ€§: "${existingSymptom}" vs "${newSymptom}"`);
            
            const relationshipMap = {
                'å¤±çœ ': ['æ—©é†’', 'å¤šæ¢¦', 'å…¥ç¡å›°éš¾', 'ç¡çœ æµ…', 'æ˜“æƒŠé†’', 'å¤œé†’'],
                'å¤´ç—›': ['å¤´èƒ€', 'å¤´æ™•', 'åå¤´ç—›', 'å¤ªé˜³ç©´ç—›', 'åè„‘ç—›'],
                'èƒƒç—›': ['èƒƒèƒ€', 'èƒƒé…¸', 'åé…¸', 'å—³æ°”', 'èƒƒè„˜ç—›', 'èƒƒéƒ¨ä¸é€‚'],
                'ä¾¿ç§˜': ['å¤§ä¾¿å¹²ç‡¥', 'æ’ä¾¿å›°éš¾', 'å¤§ä¾¿å¹²ç»“', 'ä¾¿å¹²å¦‚æ —'],
                'è…¹æ³»': ['ä¾¿æº', 'æ³„æ³»', 'æ°´æ³»', 'å¤§ä¾¿ç¨€è–„'],
                'å’³å—½': ['å’³ç—°', 'å¹²å’³', 'å’³å–˜', 'ç—°å¤š', 'å–‰ç—’']
            };
            
            // æ£€æŸ¥åŒå‘å…³ç³»
            for (const [mainSymptom, relatedList] of Object.entries(relationshipMap)) {
                const condition1 = existingSymptom.includes(mainSymptom) && relatedList.includes(newSymptom);
                const condition2 = newSymptom.includes(mainSymptom) && relatedList.includes(existingSymptom);
                
                if (condition1 || condition2) {
                    console.log(`    âœ… æ‰¾åˆ°å…³è”: ${mainSymptom} -> [${relatedList.join(', ')}]`);
                    console.log(`    æ¡ä»¶1 (${existingSymptom} åŒ…å« ${mainSymptom} ä¸” ${newSymptom} åœ¨åˆ—è¡¨ä¸­): ${condition1}`);
                    console.log(`    æ¡ä»¶2 (${newSymptom} åŒ…å« ${mainSymptom} ä¸” ${existingSymptom} åœ¨åˆ—è¡¨ä¸­): ${condition2}`);
                    return true;
                }
            }
            
            console.log(`    âŒ æœªæ‰¾åˆ°å…³è”å…³ç³»`);
            return false;
        }

        // å°†ç—‡çŠ¶åˆå¹¶åˆ°ç°æœ‰èŠ‚ç‚¹
        function mergeSymptomToNode(targetNode, newSymptom, description) {
            console.log(`å¼€å§‹åˆå¹¶ç—‡çŠ¶: ${newSymptom} -> ${targetNode.name}`);
            
            // æ›´æ–°èŠ‚ç‚¹å†…å®¹ï¼Œå°†æ–°ç—‡çŠ¶æ·»åŠ åˆ°æè¿°ä¸­
            if (!targetNode.relatedSymptoms) {
                targetNode.relatedSymptoms = [];
            }
            
            // é¿å…é‡å¤æ·»åŠ 
            if (!targetNode.relatedSymptoms.includes(newSymptom)) {
                targetNode.relatedSymptoms.push(newSymptom);
                
                console.log(`ç—‡çŠ¶åˆå¹¶æˆåŠŸï¼Œå½“å‰ç›¸å…³ç—‡çŠ¶:`, targetNode.relatedSymptoms);
                
                // æ›´æ–°èŠ‚ç‚¹æ˜¾ç¤º
                updateNodeDisplay(targetNode);
                
                // æ˜¾ç¤ºåˆå¹¶æˆåŠŸæ¶ˆæ¯ï¼ŒåŒºåˆ†æ˜¯å¦ä¸ºé€‰ä¸­èŠ‚ç‚¹
                const isSelectedNode = targetNode === selectedNode;
                const message = isSelectedNode ? 
                    `âœ… å·²å°†"${newSymptom}"åˆå¹¶åˆ°æ‚¨é€‰ä¸­çš„"${targetNode.name}"ç—‡çŠ¶ç¾¤` :
                    `âœ… å·²å°†"${newSymptom}"åˆå¹¶åˆ°ç›¸å…³çš„"${targetNode.name}"ç—‡çŠ¶ç¾¤`;
                showResult('æˆåŠŸ', message, 'success');
                
                console.log(`èŠ‚ç‚¹æ˜¾ç¤ºæ›´æ–°å®Œæˆï¼Œç›®æ ‡èŠ‚ç‚¹:`, targetNode);
            } else {
                showResult('æç¤º', `"${newSymptom}"å·²å­˜åœ¨äº"${targetNode.name}"ç—‡çŠ¶ç¾¤ä¸­`, 'info');
            }
        }

        // æ›´æ–°èŠ‚ç‚¹æ˜¾ç¤ºä»¥æ˜¾ç¤ºç›¸å…³ç—‡çŠ¶
        function updateNodeDisplay(node) {
            const nodeElement = document.getElementById(node.id);
            if (!nodeElement) return;
            
            const contentDiv = nodeElement.querySelector('.node-content');
            if (!contentDiv) return;
            
            // ä½¿ç”¨ä¸renderNodeç›¸åŒçš„é€»è¾‘
            let nodeContent = node.description || '';
            if (node.relatedSymptoms && node.relatedSymptoms.length > 0) {
                nodeContent = `${nodeContent}
                    <div class="related-symptoms">
                        <div class="symptoms-label">ç›¸å…³ç—‡çŠ¶:</div>
                        <div class="symptoms-list">${node.relatedSymptoms.join(', ')}</div>
                    </div>`;
            }
            
            contentDiv.innerHTML = nodeContent;
        }

        // æ›´æ–°èŠ‚ç‚¹æ‹–æ‹½åé‡ç»˜è¿æ¥çº¿
        function updateNodePosition(node) {
            const element = document.getElementById(node.id);
            if (element) {
                element.style.left = `${node.x}px`;
                element.style.top = `${node.y}px`;
                
                // é‡ç»˜è¿æ¥çº¿
                setTimeout(drawConnections, 10);
            }
        }

        // åˆ é™¤èŠ‚ç‚¹
        function deleteNodeById(nodeId) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªèŠ‚ç‚¹å—ï¼Ÿ')) {
                // ä»æ•°ç»„ä¸­ç§»é™¤èŠ‚ç‚¹
                nodes = nodes.filter(node => node.id !== nodeId);
                
                // ç§»é™¤ç›¸å…³è¿æ¥
                connections = connections.filter(conn => 
                    conn.from !== nodeId && conn.to !== nodeId
                );
                
                // ä»DOMä¸­ç§»é™¤èŠ‚ç‚¹
                const element = document.getElementById(nodeId);
                if (element) {
                    element.remove();
                }
                
                // å¦‚æœåˆ é™¤çš„æ˜¯é€‰ä¸­èŠ‚ç‚¹ï¼Œæ¸…é™¤é€‰æ‹©
                if (selectedNode && selectedNode.id === nodeId) {
                    selectedNode = null;
                    hideSelectedNodeInfo();
                }
                
                // é‡ç»˜è¿æ¥çº¿
                drawConnections();
                updateCanvas();
                
                showResult('æˆåŠŸ', 'âœ… èŠ‚ç‚¹å·²åˆ é™¤', 'success');
            }
        }

        // æ˜¾ç¤ºå³é”®èœå•
        function showContextMenu(e, node) {
            hideContextMenu();
            
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.id = 'contextMenu';
            menu.style.left = `${e.clientX}px`;
            menu.style.top = `${e.clientY}px`;
            
            const menuItems = [
                { text: 'ğŸ” åˆ†ææ­¤èŠ‚ç‚¹', action: () => analyzeSelectedNode(node) },
                { text: 'ğŸ“ ç¼–è¾‘èŠ‚ç‚¹', action: () => editNode(node) },
                { text: 'â• æ·»åŠ å­èŠ‚ç‚¹', action: () => addChildNode(node) }
            ];
            
            if (node.type === 'formula') {
                menuItems.push({ text: 'ğŸ’Š AIæ–¹å‰‚åˆ†æ', action: () => analyzeFormulaNode(node) });
            }
            
            menuItems.push({ text: 'ğŸ—‘ï¸ åˆ é™¤èŠ‚ç‚¹', action: () => deleteNodeById(node.id), danger: true });
            
            menuItems.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.className = `context-menu-item ${item.danger ? 'danger' : ''}`;
                menuItem.innerHTML = item.text;
                menuItem.onclick = () => {
                    item.action();
                    hideContextMenu();
                };
                menu.appendChild(menuItem);
            });
            
            document.body.appendChild(menu);
        }

        // éšè—å³é”®èœå•
        function hideContextMenu() {
            const menu = document.getElementById('contextMenu');
            if (menu) {
                menu.remove();
            }
        }

        // ç—‡çŠ¶é—æ¼æ£€æµ‹
        async function detectMissingSymptoms() {
            console.log('ç—‡çŠ¶é—æ¼æ£€æµ‹è¢«è°ƒç”¨');
            
            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            if (!getCurrentDiseaseName()) {
                alert('è¯·å…ˆè¾“å…¥ç–¾ç—…åç§°');
                return;
            }

            // æ”¶é›†ç°æœ‰ç—‡çŠ¶èŠ‚ç‚¹
            const symptomNodes = nodes.filter(node => node.type === 'symptom');
            const existingSymptoms = symptomNodes.map(node => node.name);
            
            showLoading('æ­£åœ¨æ£€æµ‹ç—‡çŠ¶é—æ¼...');

            try {
                // ä½¿ç”¨ç°æœ‰çš„APIï¼Œä½†ä¸“æ³¨äºç—‡çŠ¶æ£€æµ‹
                const response = await fetch('/api/detect_missing_logic', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        disease_name: getCurrentDiseaseName(),
                        current_paths: [],
                        existing_nodes: nodes.filter(node => node.type === 'symptom')
                    })
                });

                const data = await response.json();
                
                if (data.success && data.data) {
                    hideLoading();
                    showSymptomDetectionResult(data.data, existingSymptoms);
                } else {
                    throw new Error(data.message || 'æ£€æµ‹å¤±è´¥');
                }
            } catch (error) {
                console.error('ç—‡çŠ¶é—æ¼æ£€æµ‹å¤±è´¥:', error);
                hideLoading();
                showResult('é”™è¯¯', `âŒ æ£€æµ‹å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ˜¾ç¤ºç—‡çŠ¶æ£€æµ‹ç»“æœ
        function showSymptomDetectionResult(data, existingSymptoms) {
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            // ç”Ÿæˆå¸¸è§ç—‡çŠ¶å»ºè®®
            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            const commonSymptoms = getCommonSymptomsForDisease(getCurrentDiseaseName());
            const missingSymptoms = commonSymptoms.filter(symptom => 
                !existingSymptoms.some(existing => existing.includes(symptom))
            );
            
            let html = '<div class="result-title">ğŸ” ç—‡çŠ¶é—æ¼æ£€æµ‹ç»“æœ</div>';
            
            if (missingSymptoms.length > 0) {
                html += '<div style="margin: 15px 0;"><strong>å»ºè®®è¡¥å……çš„ç—‡çŠ¶:</strong><br>';
                missingSymptoms.forEach(symptom => {
                    html += `
                        <div class="suggestion-item" onclick="addSuggestionToTree('symptom', '${symptom}', '${getCurrentDiseaseName()}çš„å¸¸è§ç—‡çŠ¶')">
                            <div class="suggestion-content">${symptom}</div>
                            <div class="suggestion-desc">${getCurrentDiseaseName()}çš„å¸¸è§ç—‡çŠ¶è¡¨ç°</div>
                        </div>
                    `;
                });
                html += '</div>';
            } else {
                html += '<div style="color: #22c55e;">âœ… ç—‡çŠ¶è¦†ç›–è¾ƒä¸ºå®Œæ•´</div>';
            }
            
            // æ·»åŠ ç°æœ‰ç—‡çŠ¶åˆ†æ
            if (existingSymptoms.length > 0) {
                html += '<div style="margin: 15px 0;"><strong>ç°æœ‰ç—‡çŠ¶:</strong><br>';
                html += `<div style="font-size: 12px; color: #6b7280;">${existingSymptoms.join('ã€')}</div></div>`;
            }
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = html;
            
            resultsDiv.appendChild(resultElement);
        }

        // è·å–ç–¾ç—…å¸¸è§ç—‡çŠ¶
        function getCommonSymptomsForDisease(diseaseName) {
            const symptomDatabase = {
                'å¤±çœ ': ['éš¾ä»¥å…¥ç¡', 'æ—©é†’', 'å¤šæ¢¦', 'ç¡çœ æµ…', 'å¿ƒçƒ¦', 'å¥å¿˜', 'å¤´æ™•', 'ç–²ä¹'],
                'èƒƒç—›': ['èƒƒè„˜ç–¼ç—›', 'èƒƒèƒ€', 'åé…¸', 'å—³æ°”', 'æ¶å¿ƒ', 'é£Ÿæ¬²ä¸æŒ¯', 'è…¹èƒ€', 'ä¾¿ç§˜'],
                'å¤´ç—›': ['å¤´éƒ¨ç–¼ç—›', 'çœ©æ™•', 'æ¶å¿ƒå‘•å', 'ç•å…‰', 'é¢ˆé¡¹å¼ºç›´', 'è€³é¸£', 'è§†ç‰©æ¨¡ç³Š'],
                'å’³å—½': ['å¹²å’³', 'å’³ç—°', 'æ°”çŸ­', 'èƒ¸é—·', 'å’½ç—’', 'å£°å˜¶', 'å‘çƒ­', 'ä¹åŠ›'],
                'è…¹æ³»': ['å¤§ä¾¿ç¨€æº', 'è…¹ç—›', 'è…¹èƒ€', 'è‚ é¸£', 'é‡Œæ€¥åé‡', 'å‘çƒ­', 'æ¶å¿ƒ', 'é£Ÿæ¬²å‡é€€']
            };
            
            return symptomDatabase[diseaseName] || ['ç›¸å…³ç—‡çŠ¶1', 'ç›¸å…³ç—‡çŠ¶2', 'ç›¸å…³ç—‡çŠ¶3'];
        }

        // æ–¹å‰‚AIåˆ†æ
        async function analyzeFormula() {
            console.log('æ–¹å‰‚AIåˆ†æè¢«è°ƒç”¨');
            
            const formulaNodes = nodes.filter(node => node.type === 'formula');
            if (formulaNodes.length === 0) {
                alert('è¯·å…ˆæ·»åŠ æ–¹å‰‚èŠ‚ç‚¹');
                return;
            }

            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            if (!getCurrentDiseaseName()) {
                alert('è¯·å…ˆè¾“å…¥ç–¾ç—…åç§°');
                return;
            }

            showLoading('æ­£åœ¨è¿›è¡ŒAIæ–¹å‰‚åˆ†æ...');

            try {
                const response = await fetch('/api/analyze_formula_composition', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        disease_name: getCurrentDiseaseName(),
                        formulas: formulaNodes.map(node => ({
                            name: node.name,
                            description: node.description
                        })),
                        patient_symptoms: nodes.filter(n => n.type === 'symptom').map(n => n.name)
                    })
                });

                const data = await response.json();
                
                if (data.success) {
                    hideLoading();
                    showFormulaAnalysisResult(data.data || {});
                } else {
                    // å¦‚æœAPIä¸å­˜åœ¨ï¼Œä½¿ç”¨æœ¬åœ°åˆ†æ
                    hideLoading();
                    showLocalFormulaAnalysis(formulaNodes, getCurrentDiseaseName());
                }
            } catch (error) {
                console.error('æ–¹å‰‚åˆ†æå¤±è´¥:', error);
                hideLoading();
                // ä½¿ç”¨æœ¬åœ°åˆ†æä½œä¸ºåå¤‡
                showLocalFormulaAnalysis(formulaNodes, getCurrentDiseaseName());
            }
        }

        // æœ¬åœ°æ–¹å‰‚åˆ†æ
        function showLocalFormulaAnalysis(formulaNodes, diseaseName) {
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            let html = '<div class="result-title">ğŸ’Š æ–¹å‰‚AIåˆ†æç»“æœ</div>';
            
            formulaNodes.forEach(formulaNode => {
                const analysis = analyzeFormulaLocally(formulaNode.name, getCurrentDiseaseName());
                html += `
                    <div class="formula-analysis-panel">
                        <div style="font-weight: 600; margin-bottom: 10px;">ğŸ“‹ ${formulaNode.name}</div>
                        <div style="margin-bottom: 10px;">
                            <strong>å»ºè®®è¯æç»„æˆ:</strong><br>
                            <div style="margin-top: 5px;">
                                ${analysis.herbs.map(herb => 
                                    `<span class="herb-item" onclick="addHerbToFormula('${formulaNode.id}', '${herb.name}', '${herb.dosage}')" title="ç‚¹å‡»æ·»åŠ åˆ°æ–¹å‰‚">${herb.name} ${herb.dosage}</span>`
                                ).join('')}
                            </div>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <strong>åŠ å‡å»ºè®®:</strong><br>
                            <div style="font-size: 12px; color: #059669;">${analysis.modifications}</div>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <strong>åŠŸæ•ˆ:</strong><br>
                            <div style="font-size: 12px; color: #6b7280;">${analysis.effects}</div>
                        </div>
                        <button class="apply-formula-btn" onclick="applyFullFormulaToNode('${formulaNode.id}', '${JSON.stringify(analysis.herbs).replace(/"/g, "&quot;")}')">
                            âœ¨ åº”ç”¨å®Œæ•´æ–¹å‰‚
                        </button>
                    </div>
                `;
            });
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = html;
            
            resultsDiv.appendChild(resultElement);
        }

        // å®Œæ•´çš„æ–¹å‰‚æ•°æ®åº“ï¼ŒåŒ…å«å…·ä½“è¯æä¿¡æ¯
        function analyzeFormulaLocally(formulaName, diseaseName) {
            const formulaDatabase = {
                'é€é¥æ•£': {
                    herbs: [
                        { name: 'æŸ´èƒ¡', dosage: '10g' },
                        { name: 'å½“å½’', dosage: '10g' },
                        { name: 'ç™½èŠ', dosage: '10g' },
                        { name: 'ç™½æœ¯', dosage: '10g' },
                        { name: 'èŒ¯è‹“', dosage: '15g' },
                        { name: 'ç‚™ç”˜è‰', dosage: '6g' },
                        { name: 'è–„è·', dosage: '6g' },
                        { name: 'ç”Ÿå§œ', dosage: '3ç‰‡' }
                    ],
                    effects: 'ç–è‚è§£éƒï¼Œå¥è„¾å…»è¡€',
                    modifications: 'è‚éƒé‡è€…åŠ é¦™é™„12gï¼Œéƒé‡‘10gï¼›è„¾è™šé‡è€…åŠ å…šå‚12g'
                },
                'ç”˜éº¦å¤§æ£æ±¤': {
                    herbs: [
                        { name: 'æ·®å°éº¦', dosage: '30g' },
                        { name: 'ç‚™ç”˜è‰', dosage: '10g' },
                        { name: 'å¤§æ£', dosage: '10æš' }
                    ],
                    effects: 'å…»å¿ƒå®‰ç¥ï¼Œç¼“æ€¥æ­¢ç—›',
                    modifications: 'å¿ƒç¥ä¸å®‰é‡è€…åŠ é…¸æ£ä»15gï¼Œè¿œå¿—10g'
                },
                'é€é¥æ•£åˆç”˜éº¦å¤§æ£æ±¤': {
                    herbs: [
                        { name: 'æŸ´èƒ¡', dosage: '10g' },
                        { name: 'å½“å½’', dosage: '10g' },
                        { name: 'ç™½èŠ', dosage: '10g' },
                        { name: 'ç™½æœ¯', dosage: '10g' },
                        { name: 'èŒ¯è‹“', dosage: '15g' },
                        { name: 'ç‚™ç”˜è‰', dosage: '10g' },
                        { name: 'è–„è·', dosage: '6g' },
                        { name: 'ç”Ÿå§œ', dosage: '3ç‰‡' },
                        { name: 'æ·®å°éº¦', dosage: '30g' },
                        { name: 'å¤§æ£', dosage: '10æš' }
                    ],
                    effects: 'ç–è‚è§£éƒï¼Œå¥è„¾å…»è¡€ï¼Œå…»å¿ƒå®‰ç¥',
                    modifications: 'æƒ…å¿—æŠ‘éƒé‡è€…åŠ åˆæ¬¢çš®12gï¼›å¿ƒç¥ä¸å®‰é‡è€…åŠ é…¸æ£ä»15gï¼Œé¾™éª¨20g'
                },
                'é»„è¿é˜¿èƒ¶æ±¤': {
                    herbs: [
                        { name: 'é»„è¿', dosage: '6g' },
                        { name: 'é˜¿èƒ¶', dosage: '9g' },
                        { name: 'é»„èŠ©', dosage: '6g' },
                        { name: 'ç™½èŠ', dosage: '9g' },
                        { name: 'é¸¡å­é»„', dosage: '2æš' }
                    ],
                    effects: 'æ¸…å¿ƒç«ï¼Œå…»å¿ƒé˜´ï¼Œå®‰ç¥å¿—',
                    modifications: 'å¿ƒç«åç››åŠ æ €å­6gï¼›é˜´è™šæ˜æ˜¾åŠ éº¦å†¬12g'
                },
                'å½’è„¾æ±¤': {
                    herbs: [
                        { name: 'å…šå‚', dosage: '12g' },
                        { name: 'ç™½æœ¯', dosage: '10g' },
                        { name: 'èŒ¯è‹“', dosage: '12g' },
                        { name: 'å½“å½’', dosage: '9g' },
                        { name: 'é¾™çœ¼è‚‰', dosage: '12g' },
                        { name: 'é…¸æ£ä»', dosage: '15g' },
                        { name: 'æœ¨é¦™', dosage: '6g' },
                        { name: 'ç‚™ç”˜è‰', dosage: '6g' }
                    ],
                    effects: 'è¡¥ç›Šå¿ƒè„¾ï¼Œå…»è¡€å®‰ç¥',
                    modifications: 'æ°”è™šæ˜æ˜¾åŠ é»„èŠª15gï¼›è¡€è™šç”šè€…åŠ ç†Ÿåœ°12g'
                },
                'ç†ä¸­æ±¤': {
                    herbs: [
                        { name: 'äººå‚', dosage: '9g' },
                        { name: 'ç™½æœ¯', dosage: '9g' },
                        { name: 'å¹²å§œ', dosage: '9g' },
                        { name: 'ç‚™ç”˜è‰', dosage: '6g' }
                    ],
                    effects: 'æ¸©ä¸­æ•£å¯’ï¼Œè¡¥æ°”å¥è„¾',
                    modifications: 'å¯’ç››åŠ é™„å­6gï¼›æ°”è™šç”šåŠ é»„èŠª15g'
                }
            };
            
            return formulaDatabase[formulaName] || {
                herbs: [
                    { name: 'ä¸»è¯', dosage: '10-15g' },
                    { name: 'è¾…è¯', dosage: '6-12g' },
                    { name: 'ä½è¯', dosage: '3-9g' }
                ],
                effects: `æ²»ç–—${getCurrentDiseaseName()}çš„æœ‰æ•ˆæ–¹å‰‚`,
                modifications: 'è¯·æ ¹æ®å…·ä½“ç—‡çŠ¶è¿›è¡ŒåŠ å‡'
            };
        }

        // æ˜¾ç¤ºæ–¹å‰‚åˆ†æç»“æœ
        function showFormulaAnalysisResult(data) {
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = `
                <div class="result-title">ğŸ’Š æ–¹å‰‚AIåˆ†æç»“æœ</div>
                <div style="font-size: 13px;">${data.analysis || 'åˆ†æå®Œæˆï¼Œè¯·æŸ¥çœ‹å…·ä½“å»ºè®®'}</div>
            `;
            
            resultsDiv.appendChild(resultElement);
        }

        // åˆ†æé€‰ä¸­èŠ‚ç‚¹
        function analyzeSelectedNode(node) {
            if (node.type === 'formula') {
                analyzeFormulaNode(node);
            } else {
                showResult('æç¤º', `æ­£åœ¨åˆ†æ${getNodeTypeText(node.type)}èŠ‚ç‚¹: ${node.name}`, 'info');
            }
        }

        // åˆ†ææ–¹å‰‚èŠ‚ç‚¹
        function analyzeFormulaNode(node) {
            const analysis = analyzeFormulaLocally(node.name, getCurrentDiseaseName());
            
            clearResults();
            const resultsDiv = document.getElementById('analysisResults');
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = `
                <div class="result-title">ğŸ’Š ${node.name} è¯¦ç»†åˆ†æ</div>
                <div class="formula-analysis-panel">
                    <div style="margin-bottom: 10px;">
                        <strong>è¯æç»„æˆ:</strong><br>
                        <div style="font-size: 12px; margin-top: 5px;">
                            ${analysis.herbs.map(herb => `${herb.name} ${herb.dosage}`).join('ã€')}
                        </div>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>åŠŸæ•ˆä¸»æ²»:</strong><br>
                        <div style="font-size: 12px; color: #6b7280;">${analysis.effects}</div>
                    </div>
                    <div>
                        <strong>åŠ å‡åŒ–è£:</strong><br>
                        <div style="font-size: 12px; color: #059669;">${analysis.modifications}</div>
                    </div>
                </div>
            `;
            
            resultsDiv.appendChild(resultElement);
        }

        // ç¼–è¾‘èŠ‚ç‚¹
        function editNode(node) {
            const newName = prompt('è¯·è¾“å…¥æ–°çš„èŠ‚ç‚¹åç§°:', node.name);
            if (newName && newName.trim() && newName !== node.name) {
                node.name = newName.trim();
                
                const element = document.getElementById(node.id);
                const titleElement = element.querySelector('.node-title');
                if (titleElement) {
                    titleElement.textContent = node.name;
                }
                
                showResult('æˆåŠŸ', 'âœ… èŠ‚ç‚¹å·²æ›´æ–°', 'success');
            }
        }

        // æ·»åŠ å­èŠ‚ç‚¹
        function addChildNode(parentNode) {
            const nodeType = prompt('è¯·è¾“å…¥èŠ‚ç‚¹ç±»å‹ (symptom/condition/diagnosis/treatment/formula):', 'condition');
            if (!nodeType) return;
            
            const nodeName = prompt('è¯·è¾“å…¥èŠ‚ç‚¹åç§°:', 'æ–°èŠ‚ç‚¹');
            if (!nodeName) return;
            
            const newNode = {
                id: `child_${nodeCounter++}`,
                type: nodeType,
                name: nodeName,
                description: `${parentNode.name}çš„ç›¸å…³èŠ‚ç‚¹`,
                x: parentNode.x + 250,
                y: parentNode.y + (Math.random() - 0.5) * 100
            };
            
            nodes.push(newNode);
            renderNode(newNode);
            
            connections.push({
                from: parentNode.id,
                to: newNode.id
            });
            
            drawConnections();
            showResult('æˆåŠŸ', `âœ… å·²æ·»åŠ å­èŠ‚ç‚¹"${nodeName}"`, 'success');
        }

        // æ·»åŠ è¯æåˆ°æ–¹å‰‚èŠ‚ç‚¹
        function addHerbToFormula(formulaNodeId, herbName, dosage) {
            const formulaNode = nodes.find(node => node.id === formulaNodeId);
            if (!formulaNode) {
                showResult('é”™è¯¯', 'æ‰¾ä¸åˆ°æ–¹å‰‚èŠ‚ç‚¹', 'error');
                return;
            }
            
            // åˆå§‹åŒ– herbs æ•°ç»„
            if (!formulaNode.herbs) {
                formulaNode.herbs = [];
            }
            
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨è¯¥è¯æ
            const existingHerb = formulaNode.herbs.find(h => h.name === herbName);
            if (existingHerb) {
                existingHerb.dosage = dosage;
                showResult('æˆåŠŸ', `âœ… å·²æ›´æ–° ${herbName} ç”¨é‡ä¸º ${dosage}`, 'success');
            } else {
                formulaNode.herbs.push({ name: herbName, dosage: dosage });
                showResult('æˆåŠŸ', `âœ… å·²æ·»åŠ  ${herbName} ${dosage} åˆ°æ–¹å‰‚`, 'success');
            }
            
            // æ›´æ–°èŠ‚ç‚¹æ˜¾ç¤º
            updateFormulaNodeDisplay(formulaNode);
        }

        // åº”ç”¨å®Œæ•´æ–¹å‰‚åˆ°èŠ‚ç‚¹
        function applyFullFormulaToNode(formulaNodeId, herbsJsonStr) {
            const formulaNode = nodes.find(node => node.id === formulaNodeId);
            if (!formulaNode) {
                showResult('é”™è¯¯', 'æ‰¾ä¸åˆ°æ–¹å‰‚èŠ‚ç‚¹', 'error');
                return;
            }
            
            try {
                const herbs = JSON.parse(herbsJsonStr.replace(/&quot;/g, '"'));
                formulaNode.herbs = herbs;
                
                updateFormulaNodeDisplay(formulaNode);
                showResult('æˆåŠŸ', `âœ… å·²åº”ç”¨å®Œæ•´æ–¹å‰‚åˆ° ${formulaNode.name}ï¼ŒåŒ…å« ${herbs.length} å‘³è¯æ`, 'success');
            } catch (error) {
                showResult('é”™è¯¯', 'æ–¹å‰‚æ•°æ®è§£æå¤±è´¥', 'error');
            }
        }

        // æ›´æ–°æ–¹å‰‚èŠ‚ç‚¹æ˜¾ç¤º
        function updateFormulaNodeDisplay(formulaNode) {
            const element = document.getElementById(formulaNode.id);
            if (!element) return;
            
            const contentDiv = element.querySelector('.node-content');
            if (contentDiv && formulaNode.herbs && formulaNode.herbs.length > 0) {
                const herbsList = formulaNode.herbs.map(h => `${h.name} ${h.dosage}`).join('ã€');
                contentDiv.innerHTML = `${formulaNode.description || ''}<br><small style="color: #059669;">è¯æ: ${herbsList}</small>`;
            }
        }

        // å¢å¼ºçš„è¯å‹æ™ºèƒ½è¯†åˆ«
        async function analyzeSyndrome() {
            console.log('è¯å‹æ™ºèƒ½è¯†åˆ«è¢«è°ƒç”¨');
            
            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            if (!getCurrentDiseaseName()) {
                alert('è¯·å…ˆè¾“å…¥ç–¾ç—…åç§°');
                return;
            }
            
            // æ”¶é›†æ‰€æœ‰ç—‡çŠ¶ï¼ˆä»èŠ‚ç‚¹å’Œç—‡çŠ¶ç¾¤ï¼‰
            const symptomNodes = nodes.filter(node => node.type === 'symptom');
            const allSymptoms = symptomNodes.map(n => n.name);
            
            // å³ä½¿æ²¡æœ‰ç—‡çŠ¶ä¹Ÿè¿›è¡Œåˆ†æï¼ˆä½¿ç”¨ç–¾ç—…åç§°ï¼‰
            const symptomsForAnalysis = allSymptoms.length > 0 ? allSymptoms : [getCurrentDiseaseName()];

            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            if (!getCurrentDiseaseName()) {
                alert('è¯·å…ˆè¾“å…¥ç–¾ç—…åç§°');
                return;
            }

            showLoading('æ­£åœ¨è¿›è¡Œè¯å‹æ™ºèƒ½è¯†åˆ«...');

            try {
                    const syndromeAnalysis = analyzeSyndromeLocally(getCurrentDiseaseName(), symptomsForAnalysis || []);
                
                hideLoading();
                showSyndromeAnalysisResult(syndromeAnalysis);
                
            } catch (error) {
                console.error('è¯å‹è¯†åˆ«å¤±è´¥:', error);
                hideLoading();
                showResult('é”™è¯¯', `âŒ è¯†åˆ«å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // å¢å¼ºçš„è¯å‹åˆ†ææ•°æ®åº“
        function analyzeSyndromeLocally(diseaseName, symptoms) {
            const syndromeDatabase = {
                'å¤±çœ ': {
                    'å¿ƒç«æ—ºç››è¯': {
                        keywords: ['å¿ƒçƒ¦', 'å¤šæ¢¦', 'å£å¹²', 'èˆŒçº¢', 'è‹”é»„', 'å¤±çœ ', 'éš¾ä»¥å…¥ç¡'],
                        description: 'å¿ƒç«äº¢ç››ï¼Œæ‰°ä¹±ç¥æ˜',
                        treatment: 'æ¸…å¿ƒç«ï¼Œå®‰ç¥å¿—',
                        formula: 'é»„è¿é˜¿èƒ¶æ±¤',
                        weight: 0.8
                    },
                    'å¿ƒè„¾ä¸¤è™šè¯': {
                        keywords: ['å¥å¿˜', 'å¿ƒæ‚¸', 'é¢è‰²èé»„', 'èˆŒæ·¡', 'è„‰å¼±', 'å¤±çœ ', 'ç–²ä¹', 'é£Ÿæ¬²ä¸æŒ¯'],
                        description: 'å¿ƒè„¾æ°”è¡€ä¸è¶³ï¼Œç¥å¤±æ‰€å…»',
                        treatment: 'è¡¥ç›Šå¿ƒè„¾ï¼Œå…»è¡€å®‰ç¥',
                        formula: 'å½’è„¾æ±¤',
                        weight: 0.7
                    },
                    'è‚éƒåŒ–ç«è¯': {
                        keywords: ['æ˜“æ€’', 'èƒ¸èƒèƒ€æ»¡', 'å£è‹¦', 'è„‰å¼¦', 'å¤±çœ ', 'çƒ¦èº', 'å¤´ç—›'],
                        description: 'è‚éƒåŒ–ç«ï¼Œä¸Šæ‰°ç¥æ˜',
                        treatment: 'ç–è‚è§£éƒï¼Œæ¸…çƒ­å®‰ç¥',
                        formula: 'é€é¥æ•£åˆç”˜éº¦å¤§æ£æ±¤',
                        weight: 0.8
                    },
                    'é˜´è™šç«æ—ºè¯': {
                        keywords: ['å¤±çœ ', 'æ—©é†’', 'äº”å¿ƒçƒ¦çƒ­', 'ç›—æ±—', 'å£å¹²', 'èˆŒçº¢å°‘è‹”'],
                        description: 'è‚¾é˜´ä¸è¶³ï¼Œè™šç«ä¸Šç‚',
                        treatment: 'æ»‹é˜´é™ç«ï¼Œå…»å¿ƒå®‰ç¥',
                        formula: 'é»„è¿é˜¿èƒ¶æ±¤',
                        weight: 0.7
                    }
                },
                'èƒƒç—›': {
                    'è„¾èƒƒè™šå¯’è¯': {
                        keywords: ['å–œæ¸©å–œæŒ‰', 'é¢è‰²èç™½', 'èˆŒæ·¡è‹”ç™½', 'è„‰ç»†å¼±', 'èƒƒç—›', 'èƒƒèƒ€'],
                        description: 'è„¾èƒƒé˜³æ°”ä¸è¶³ï¼Œå¤±äºæ¸©ç…¦',
                        treatment: 'æ¸©ä¸­æ•£å¯’ï¼Œè¡¥æ°”å¥è„¾',
                        formula: 'ç†ä¸­æ±¤',
                        weight: 0.8
                    },
                    'è‚æ°”çŠ¯èƒƒè¯': {
                        keywords: ['èƒ€ç—›æ‹’æŒ‰', 'å—³æ°”', 'æƒ…å¿—ä¸é‚', 'è„‰å¼¦', 'èƒƒç—›', 'åé…¸'],
                        description: 'è‚æ°”éƒç»“ï¼Œæ¨ªé€†çŠ¯èƒƒ',
                        treatment: 'ç–è‚ç†æ°”ï¼Œå’Œèƒƒæ­¢ç—›',
                        formula: 'æŸ´èƒ¡ç–è‚æ•£',
                        weight: 0.7
                    }
                },
                // é€šç”¨ç—‡çŠ¶åŒ¹é…ï¼ˆé™ä½é˜ˆå€¼ï¼‰
                'é€šç”¨': {
                    'æ°”è¡€ä¸è¶³è¯': {
                        keywords: ['ç–²ä¹', 'ä¹åŠ›', 'é¢è‰²èé»„', 'å¤´æ™•', 'å¿ƒæ‚¸'],
                        description: 'æ°”è¡€äºè™šï¼Œè„è…‘å¤±å…»',
                        treatment: 'ç›Šæ°”å…»è¡€',
                        formula: 'å…«çæ±¤',
                        weight: 0.4
                    },
                    'ç—°æ¹¿å†…é˜»è¯': {
                        keywords: ['èƒ¸é—·', 'æ¶å¿ƒ', 'é£Ÿæ¬²ä¸æŒ¯', 'èˆŒè‹”åšè…»', 'å¤´é‡'],
                        description: 'ç—°æ¹¿å†…ç”Ÿï¼Œé˜»æ»æ°”æœº',
                        treatment: 'åŒ–ç—°é™¤æ¹¿ï¼Œç†æ°”å’Œä¸­',
                        formula: 'äºŒé™ˆæ±¤',
                        weight: 0.4
                    }
                }
            };

            const diseaseSymptoms = syndromeDatabase[diseaseName] || {};
            const matchedSyndromes = [];

            // æ£€æŸ¥ç–¾ç—…ç‰¹å®šè¯å‹
            Object.keys(diseaseSymptoms).forEach(syndromeName => {
                const syndrome = diseaseSymptoms[syndromeName];
                const matchCount = syndrome.keywords.filter(keyword => 
                    symptoms.some(symptom => symptom.includes(keyword) || keyword.includes(symptom))
                ).length;
                
                const baseMatchRate = matchCount / syndrome.keywords.length;
                const weightedMatchRate = baseMatchRate * (syndrome.weight || 0.5);
                
                // é™ä½åŒ¹é…é˜ˆå€¼åˆ°15%ï¼Œè®©æ›´å¤šè¯å‹èƒ½è¢«è¯†åˆ«
                if (weightedMatchRate > 0.15) {
                    matchedSyndromes.push({
                        name: syndromeName,
                        matchRate: weightedMatchRate,
                        confidence: Math.min(weightedMatchRate * 1.5, 1.0),
                        ...syndrome
                    });
                }
            });
            
            // æ£€æŸ¥é€šç”¨è¯å‹ï¼ˆå½“ç–¾ç—…ç‰¹å®šè¯å‹åŒ¹é…åº¦ä½æ—¶ï¼‰
            if (matchedSyndromes.length === 0 && syndromeDatabase['é€šç”¨']) {
                Object.keys(syndromeDatabase['é€šç”¨']).forEach(syndromeName => {
                    const syndrome = syndromeDatabase['é€šç”¨'][syndromeName];
                    const matchCount = syndrome.keywords.filter(keyword => 
                        symptoms.some(symptom => symptom.includes(keyword) || keyword.includes(symptom))
                    ).length;
                    
                    const matchRate = matchCount / syndrome.keywords.length;
                    
                    if (matchRate > 0.2) { // é€šç”¨è¯å‹é˜ˆå€¼ç¨é«˜
                        matchedSyndromes.push({
                            name: syndromeName,
                            matchRate: matchRate,
                            confidence: matchRate * 0.8, // é€šç”¨è¯å‹ç½®ä¿¡åº¦ç¨ä½
                            isGeneric: true,
                            ...syndrome
                        });
                    }
                });
            }

            // æŒ‰åŒ¹é…åº¦æ’åº
            matchedSyndromes.sort((a, b) => b.matchRate - a.matchRate);

            return {
                matchedSyndromes,
                recommendation: matchedSyndromes.length > 0 ? matchedSyndromes[0] : null
            };
        }

        // æ˜¾ç¤ºè¯å‹åˆ†æç»“æœ
        function showSyndromeAnalysisResult(analysis) {
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            let html = '<div class="result-title">ğŸ¯ è¯å‹æ™ºèƒ½è¯†åˆ«ç»“æœ</div>';
            
            if (analysis.recommendation) {
                html += `
                    <div class="auto-analysis-panel">
                        <div style="font-weight: 600; margin-bottom: 10px; color: #d97706;">
                            ğŸ† æ¨èè¯å‹: ${analysis.recommendation.name} 
                            <span style="font-size: 12px; color: #6b7280;">(åŒ¹é…åº¦: ${Math.round(analysis.recommendation.matchRate * 100)}%)</span>
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>ç—…æœº:</strong> ${analysis.recommendation.description}
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>æ²»æ³•:</strong> ${analysis.recommendation.treatment}
                        </div>
                        <div style="margin-bottom: 10px;">
                            <strong>æ¨èæ–¹å‰‚:</strong> ${analysis.recommendation.formula}
                        </div>
                        <button class="add-pathway-btn" onclick="addSyndromeToTree('${analysis.recommendation.name}', '${analysis.recommendation.description}')">
                            â• æ·»åŠ è¯å‹åˆ°å†³ç­–æ ‘
                        </button>
                        <button class="add-pathway-btn" onclick="addTreatmentToTree('${analysis.recommendation.treatment}', '${analysis.recommendation.formula}')">
                            â• æ·»åŠ æ²»ç–—æ–¹æ¡ˆ
                        </button>
                    </div>
                `;
            }

            if (analysis.matchedSyndromes.length > 1) {
                html += '<div style="margin-top: 15px;"><strong>å…¶ä»–å¯èƒ½è¯å‹:</strong><br>';
                analysis.matchedSyndromes.slice(1, 3).forEach(syndrome => {
                    html += `
                        <div class="suggestion-item" onclick="addSyndromeToTree('${syndrome.name}', '${syndrome.description}')">
                            <div class="suggestion-content">${syndrome.name}</div>
                            <div class="suggestion-desc">åŒ¹é…åº¦: ${Math.round(syndrome.matchRate * 100)}% - ${syndrome.description}</div>
                        </div>
                    `;
                });
                html += '</div>';
            }

            if (analysis.matchedSyndromes.length === 0) {
                // æä¾›æ›´å¤šå¸®åŠ©ä¿¡æ¯
                // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
                html += `
                    <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 8px; padding: 12px; color: #92400e;">
                        <div style="font-weight: 600; margin-bottom: 8px;">âš ï¸ è¯å‹è¯†åˆ«å»ºè®®</div>
                        <div style="font-size: 12px; margin-bottom: 8px;">
                            å½“å‰${diseaseName}çš„ç—‡çŠ¶ä¿¡æ¯ä¸è¶³ï¼Œå»ºè®®è¡¥å……ä»¥ä¸‹ä¿¡æ¯ï¼š
                        </div>
                        <div style="font-size: 11px; line-height: 1.4;">
                            â€¢ è¯¦ç»†æè¿°ç—‡çŠ¶ç‰¹ç‚¹ï¼ˆå¦‚ç—›ç—›æ€§è´¨ã€å‘ä½œæ—¶é—´ï¼‰<br>
                            â€¢ æ·»åŠ ä¼´éšç—‡çŠ¶ï¼ˆå¦‚ç¡çœ ã€é¥®é£Ÿã€å¤§å°ä¾¿ï¼‰<br>
                            â€¢ æä¾›èˆŒè±¡è„‰è±¡ä¿¡æ¯<br>
                            â€¢ è®°å½•æƒ…å¿—å› ç´ å’Œèµ·ç—…åŸå› 
                        </div>
                        <div style="margin-top: 10px;">
                            <button onclick="showSymptomGuidance('${diseaseName}')" style="
                                background: #f59e0b; color: white; border: none; border-radius: 6px; 
                                padding: 6px 12px; font-size: 11px; cursor: pointer;
                            ">
                                ğŸ“ è·å–ç—‡çŠ¶æŒ‡å¯¼
                            </button>
                        </div>
                    </div>
                `;
            }
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = html;
            
            resultsDiv.appendChild(resultElement);
        }

        // æ·»åŠ è¯å‹åˆ°å†³ç­–æ ‘
        function addSyndromeToTree(syndromeName, description) {
            if (!selectedNode) {
                // è‡ªåŠ¨é€‰æ‹©æœ€åä¸€ä¸ªconditionèŠ‚ç‚¹æˆ–åˆ›å»ºæ–°ä½ç½®
                const conditionNodes = nodes.filter(n => n.type === 'condition');
                if (conditionNodes.length > 0) {
                    selectedNode = conditionNodes[conditionNodes.length - 1];
                } else {
                    showResult('æç¤º', 'è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºæ·»åŠ ä½ç½®', 'info');
                    return;
                }
            }

            const newNode = {
                id: `syndrome_${nodeCounter++}`,
                type: 'diagnosis',
                name: syndromeName,
                description: description,
                x: selectedNode.x + 250,
                y: selectedNode.y
            };
            
            nodes.push(newNode);
            renderNode(newNode);
            
            connections.push({
                from: selectedNode.id,
                to: newNode.id
            });
            
            drawConnections();
            showResult('æˆåŠŸ', `âœ… å·²æ·»åŠ è¯å‹"${syndromeName}"åˆ°å†³ç­–æ ‘`, 'success');
        }

        // æ·»åŠ æ²»ç–—æ–¹æ¡ˆåˆ°å†³ç­–æ ‘
        function addTreatmentToTree(treatmentMethod, formulaName) {
            const diagnosisNodes = nodes.filter(n => n.type === 'diagnosis');
            if (diagnosisNodes.length === 0) {
                showResult('æç¤º', 'è¯·å…ˆæ·»åŠ è¯Šæ–­èŠ‚ç‚¹', 'info');
                return;
            }

            const lastDiagnosisNode = diagnosisNodes[diagnosisNodes.length - 1];
            
            // æ·»åŠ æ²»ç–—èŠ‚ç‚¹
            const treatmentNode = {
                id: `treatment_${nodeCounter++}`,
                type: 'treatment',
                name: 'æ²»ç–—æ–¹æ¡ˆ',
                description: treatmentMethod,
                x: lastDiagnosisNode.x + 250,
                y: lastDiagnosisNode.y
            };
            
            nodes.push(treatmentNode);
            renderNode(treatmentNode);
            
            connections.push({
                from: lastDiagnosisNode.id,
                to: treatmentNode.id
            });

            // æ·»åŠ æ–¹å‰‚èŠ‚ç‚¹
            const formulaNode = {
                id: `formula_${nodeCounter++}`,
                type: 'formula',
                name: formulaName,
                description: 'æ¨èæ–¹å‰‚',
                x: treatmentNode.x + 250,
                y: treatmentNode.y
            };
            
            nodes.push(formulaNode);
            renderNode(formulaNode);
            
            connections.push({
                from: treatmentNode.id,
                to: formulaNode.id
            });
            
            drawConnections();
            showResult('æˆåŠŸ', `âœ… å·²æ·»åŠ æ²»ç–—æ–¹æ¡ˆå’Œæ–¹å‰‚åˆ°å†³ç­–æ ‘`, 'success');
        }

        // ç”ŸæˆåŸºç¡€è¯Šç–—è·¯å¾„ï¼ˆæ— ç—‡çŠ¶æ—¶ï¼‰
        function generateBasicPathway(diseaseName) {
            const basicSteps = [
                {
                    type: 'inquiry',
                    title: 'é—®è¯Šé‡‡é›†',
                    content: `è¯¦ç»†äº†è§£${diseaseName}ç›¸å…³ç—‡çŠ¶`,
                    action: 'collect_symptoms'
                },
                {
                    type: 'examination',
                    title: 'ä½“æ ¼æ£€æŸ¥',
                    content: 'æœ›é—»é—®åˆ‡å››è¯Šåˆå‚',
                    action: 'physical_exam'
                },
                {
                    type: 'analysis',
                    title: 'è¾¨è¯åˆ†æ',
                    content: `æ ¹æ®ç—‡çŠ¶ç‰¹ç‚¹è¿›è¡Œ${diseaseName}çš„è¯å‹åˆ¤æ–­`,
                    action: 'syndrome_analysis'
                },
                {
                    type: 'treatment',
                    title: 'æ²»ç–—æ–¹æ¡ˆ',
                    content: 'åˆ¶å®šé’ˆå¯¹æ€§çš„ä¸­åŒ»æ²»ç–—æ–¹æ¡ˆ',
                    action: 'treatment_plan'
                }
            ];
            
            return {
                pathway: basicSteps,
                message: `ä¸º${diseaseName}ç”Ÿæˆçš„åŸºç¡€è¯Šç–—è·¯å¾„`
            };
        }
        
        // ç”Ÿæˆé€šç”¨è¯Šç–—è·¯å¾„ï¼ˆæœ‰ç—‡çŠ¶ä½†æ— æ˜ç¡®è¯å‹ï¼‰
        function generateGenericPathway(diseaseName, symptoms) {
            const genericSteps = [
                {
                    type: 'analysis',
                    title: 'ç—‡çŠ¶åˆ†æ',
                    content: `å½“å‰ç—‡çŠ¶: ${symptoms.join('ã€')}ï¼Œéœ€è¿›ä¸€æ­¥åˆ†æè¾¨è¯`,
                    action: 'symptom_analysis'
                },
                {
                    type: 'differential',
                    title: 'é‰´åˆ«è¯Šæ–­',
                    content: `æ’é™¤${diseaseName}çš„å…¶ä»–å¯èƒ½è¯å‹`,
                    action: 'differential_diagnosis'
                },
                {
                    type: 'supplementary',
                    title: 'è¡¥å……æ£€æŸ¥',
                    content: 'å®Œå–„å››è¯Šä¿¡æ¯ï¼Œæ˜ç¡®è¯å‹',
                    action: 'supplementary_exam'
                },
                {
                    type: 'treatment',
                    title: 'åˆ†å‹æ²»ç–—',
                    content: 'æ ¹æ®æœ€ç»ˆè¯å‹é€‰æ‹©åˆé€‚æ²»æ³•',
                    action: 'targeted_treatment'
                }
            ];
            
            return {
                pathway: genericSteps,
                syndrome: null,
                message: `åŸºäºç°æœ‰ç—‡çŠ¶ç”Ÿæˆçš„${diseaseName}é€šç”¨è¯Šç–—è·¯å¾„`
            };
        }
        
        // å¢å¼ºçš„æ™ºèƒ½è¯Šç–—è·¯å¾„ç”Ÿæˆ
        async function generateAutoPathway() {
            console.log('æ™ºèƒ½è¯Šç–—è·¯å¾„è¢«è°ƒç”¨');
            
            // ç›´æ¥ä½¿ç”¨getCurrentDiseaseName()ï¼Œä¸å£°æ˜å±€éƒ¨å˜é‡
            if (!getCurrentDiseaseName()) {
                alert('è¯·å…ˆè¾“å…¥ç–¾ç—…åç§°');
                return;
            }
            
            showLoading('æ­£åœ¨ç”Ÿæˆæ™ºèƒ½è¯Šç–—è·¯å¾„...');

            try {
                // æ”¶é›†ç—‡çŠ¶ï¼ˆä»èŠ‚ç‚¹å’Œç—‡çŠ¶ç¾¤ï¼‰
                const symptomNodes = nodes.filter(node => node.type === 'symptom');
                const allSymptoms = symptomNodes.map(n => n.name);
                
                // åŸºäºç°æœ‰ç—‡çŠ¶ç”Ÿæˆå®Œæ•´è·¯å¾„
                const pathwayData = generatePathwayFromSymptoms(diseaseName, allSymptoms || []);
                
                hideLoading();
                showPathwayGenerationResult(pathwayData);
                
            } catch (error) {
                console.error('è·¯å¾„ç”Ÿæˆå¤±è´¥:', error);
                hideLoading();
                showResult('é”™è¯¯', `âŒ ç”Ÿæˆå¤±è´¥: ${error.message}`, 'error');
            }
        }

        // å¢å¼ºçš„è¯Šç–—è·¯å¾„ç”Ÿæˆ
        function generatePathwayFromSymptoms(diseaseName, symptoms) {
            // å…ˆè¿›è¡Œè¯å‹åˆ†æ
            const syndromeAnalysis = analyzeSyndromeLocally(diseaseName, symptoms);
            const recommendedSyndrome = syndromeAnalysis.recommendation;
            
            // é™ä½é˜ˆå€¼ï¼Œå³ä½¿æ²¡æœ‰æ˜ç¡®è¯å‹ä¹Ÿç”ŸæˆåŸºç¡€è·¯å¾„
            if (!recommendedSyndrome && symptoms.length === 0) {
                // å®Œå…¨æ²¡æœ‰ç—‡çŠ¶æ—¶çš„é»˜è®¤è·¯å¾„
                return generateBasicPathway(diseaseName);
            }
            
            if (!recommendedSyndrome && symptoms.length > 0) {
                // æœ‰ç—‡çŠ¶ä½†æ²¡æœ‰åŒ¹é…è¯å‹æ—¶çš„é€šç”¨è·¯å¾„
                return generateGenericPathway(diseaseName, symptoms);
            }

            // ç”Ÿæˆå®Œæ•´è·¯å¾„æ­¥éª¤
            const pathway = [
                {
                    type: 'analysis',
                    title: 'ç—‡çŠ¶åˆ†æ',
                    content: `å½“å‰ç—‡çŠ¶: ${symptoms.join('ã€')}`,
                    action: 'review_symptoms'
                },
                {
                    type: 'syndrome',
                    title: 'è¯å‹è¯Šæ–­',
                    content: `${recommendedSyndrome.name} (åŒ¹é…åº¦: ${Math.round(recommendedSyndrome.matchRate * 100)}%)`,
                    description: recommendedSyndrome.description,
                    action: 'add_syndrome'
                },
                {
                    type: 'treatment',
                    title: 'æ²»ç–—åŸåˆ™',
                    content: recommendedSyndrome.treatment,
                    action: 'add_treatment'
                },
                {
                    type: 'formula',
                    title: 'æ–¹è¯é€‰æ‹©',
                    content: recommendedSyndrome.formula,
                    action: 'add_formula'
                }
            ];

            return {
                pathway: pathway,
                syndrome: recommendedSyndrome,
                message: 'åŸºäºç°æœ‰ç—‡çŠ¶ç”Ÿæˆçš„æ™ºèƒ½è¯Šç–—è·¯å¾„'
            };
        }

        // æ˜¾ç¤ºè·¯å¾„ç”Ÿæˆç»“æœ
        function showPathwayGenerationResult(pathwayData) {
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            let html = '<div class="result-title">ğŸ¤– æ™ºèƒ½è¯Šç–—è·¯å¾„</div>';
            
            if (pathwayData.pathway.length > 0) {
                html += `<div style="margin-bottom: 15px; color: #059669; font-size: 12px;">${pathwayData.message}</div>`;
                
                pathwayData.pathway.forEach((step, index) => {
                    html += `
                        <div class="pathway-step">
                            <div style="font-weight: 600; color: #1e40af; margin-bottom: 5px;">
                                ${index + 1}. ${step.title}
                            </div>
                            <div style="font-size: 13px; margin-bottom: 8px;">${step.content}</div>
                            ${step.description ? `<div style="font-size: 11px; color: #6b7280; margin-bottom: 8px;">${step.description}</div>` : ''}
                            <button class="add-pathway-btn" onclick="executePathwayStep('${step.action}', '${step.title}', '${step.content.replace(/'/g, "\\'")}')">
                                â• æ·»åŠ åˆ°å†³ç­–æ ‘
                            </button>
                        </div>
                    `;
                });

                html += `
                    <div style="margin-top: 15px; padding: 10px; background: #f0f9ff; border-radius: 6px;">
                        <button class="apply-formula-btn" onclick="applyFullPathway('${JSON.stringify(pathwayData).replace(/"/g, "&quot;")}')">
                            ğŸš€ åº”ç”¨å®Œæ•´è·¯å¾„
                        </button>
                    </div>
                `;
            } else {
                html += `<div style="color: #f59e0b;">${pathwayData.message}</div>`;
            }
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = html;
            
            resultsDiv.appendChild(resultElement);
        }

        // æ‰§è¡Œè·¯å¾„æ­¥éª¤
        function executePathwayStep(action, title, content) {
            const lastNode = nodes.length > 0 ? nodes[nodes.length - 1] : null;
            const baseX = lastNode ? lastNode.x + 250 : 50;
            const baseY = lastNode ? lastNode.y : 100;

            let nodeType, nodeName, nodeDescription;

            switch (action) {
                case 'add_syndrome':
                    nodeType = 'diagnosis';
                    nodeName = content.split(' (')[0]; // ç§»é™¤åŒ¹é…åº¦ä¿¡æ¯
                    nodeDescription = title;
                    break;
                case 'add_treatment':
                    nodeType = 'treatment';
                    nodeName = title;
                    nodeDescription = content;
                    break;
                case 'add_formula':
                    nodeType = 'formula';
                    nodeName = content;
                    nodeDescription = title;
                    break;
                default:
                    showResult('æç¤º', `å·²è®°å½•: ${title}`, 'info');
                    return;
            }

            const newNode = {
                id: `pathway_${nodeCounter++}`,
                type: nodeType,
                name: nodeName,
                description: nodeDescription,
                x: baseX,
                y: baseY + (Math.random() - 0.5) * 50
            };
            
            nodes.push(newNode);
            renderNode(newNode);
            
            if (lastNode) {
                connections.push({
                    from: lastNode.id,
                    to: newNode.id
                });
                drawConnections();
            }
            
            showResult('æˆåŠŸ', `âœ… å·²æ·»åŠ ${title}åˆ°å†³ç­–æ ‘`, 'success');
        }

        // åº”ç”¨å®Œæ•´è·¯å¾„
        function applyFullPathway(pathwayJsonStr) {
            try {
                const pathwayData = JSON.parse(pathwayJsonStr.replace(/&quot;/g, '"'));
                
                let previousNode = nodes.length > 0 ? nodes[nodes.length - 1] : null;
                let x = previousNode ? previousNode.x + 250 : 300;
                const baseY = previousNode ? previousNode.y : 100;
                
                pathwayData.pathway.forEach((step, index) => {
                    let nodeType, nodeName, nodeDescription;

                    switch (step.action) {
                        case 'add_syndrome':
                            nodeType = 'diagnosis';
                            nodeName = step.content.split(' (')[0];
                            nodeDescription = step.description || step.title;
                            break;
                        case 'add_treatment':
                            nodeType = 'treatment';
                            nodeName = step.title;
                            nodeDescription = step.content;
                            break;
                        case 'add_formula':
                            nodeType = 'formula';
                            nodeName = step.content;
                            nodeDescription = step.title;
                            break;
                        default:
                            return;
                    }

                    const newNode = {
                        id: `full_pathway_${nodeCounter++}`,
                        type: nodeType,
                        name: nodeName,
                        description: nodeDescription,
                        x: x,
                        y: baseY + (index * 20) - 40
                    };
                    
                    nodes.push(newNode);
                    renderNode(newNode);
                    
                    if (previousNode) {
                        connections.push({
                            from: previousNode.id,
                            to: newNode.id
                        });
                    }
                    
                    previousNode = newNode;
                    x += 250;
                });
                
                drawConnections();
                showResult('æˆåŠŸ', `âœ… å·²åº”ç”¨å®Œæ•´è¯Šç–—è·¯å¾„ï¼ŒåŒ…å«${pathwayData.pathway.filter(s => s.action !== 'review_symptoms').length}ä¸ªæ­¥éª¤`, 'success');
                
            } catch (error) {
                showResult('é”™è¯¯', 'è·¯å¾„æ•°æ®è§£æå¤±è´¥', 'error');
            }
        }

        // æ˜¾ç¤ºç—‡çŠ¶æŒ‡å¯¼
        function showSymptomGuidance(diseaseName) {
            const guidance = {
                'å¤±çœ ': [
                    'å…¥ç¡æƒ…å†µï¼šéš¾ä»¥å…¥ç¡ã€è¾—è½¬åä¾§ã€å…¥ç¡æ—¶é—´è¶…è¿‡30åˆ†é’Ÿ',
                    'ç¡çœ ç»´æŒï¼šæ—©é†’ã€å¤šæ¢¦ã€ç¡çœ æµ…ã€æ˜“æƒŠé†’',
                    'ä¼´éšç—‡çŠ¶ï¼šå¿ƒçƒ¦ã€å¤´æ™•ã€å¥å¿˜ã€ç–²ä¹ä¹åŠ›',
                    'æƒ…å¿—å› ç´ ï¼šç„¦è™‘ã€æŠ‘éƒã€å·¥ä½œå‹åŠ›ã€æƒ…ç»ªæ³¢åŠ¨',
                    'èˆŒè±¡è„‰è±¡ï¼šèˆŒè´¨ã€èˆŒè‹”ã€è„‰è±¡ï¼ˆæ•°ã€æœ‰åŠ›ã€æ»‘æ¶©ç­‰ï¼‰'
                ],
                'èƒƒç—›': [
                    'ç—›ç—›ç‰¹ç‚¹ï¼šèƒ€ç—›ã€åˆºç—›ã€éšç—›ã€ç»­ç—›ã€é˜µå‘æ€§ç—›ç—›',
                    'ç—›ç—›è¯±å› ï¼šé£Ÿåç—›ã€ç©ºè…¹ç—›ã€æƒ…ç»ªæ¿€åŠ¨ååŠ é‡',
                    'ä¼´éšç—‡çŠ¶ï¼šèƒƒèƒ€ã€åé…¸ã€å—³æ°”ã€æ¶å¿ƒå‘•å',
                    'é£®é£Ÿæƒ…å†µï¼šé£Ÿæ¬²ä¸æŒ¯ã€å–œæŒ‰å–œæ¸©ã€å–œå‡‰æ‹’æŒ‰',
                    'å¤§å°ä¾¿ï¼šå¤§ä¾¿æƒ…å†µã€å°ä¾¿é¢œè‰²åŠé‡'
                ]
            };
            
            const diseaseGuidance = guidance[diseaseName] || [
                'è¯¦ç»†æè¿°ä¸»è¦ç—‡çŠ¶çš„ç‰¹ç‚¹å’Œå‘ä½œè§„å¾‹',
                'è®°å½•ä¼´éšå‡ºç°çš„å…¶ä»–ä¸é€‚ç—‡çŠ¶',
                'æ³¨æ„è§‚å¯ŸèˆŒè±¡å’Œè„‰è±¡çš„å˜åŒ–',
                'è€ƒè™‘ç–¾ç—…çš„èµ·å› å’Œè¯±å‘å› ç´ '
            ];
            
            alert(`${diseaseName}ç—‡çŠ¶é‡‡é›†æŒ‡å¯¼ï¼š\n\n${diseaseGuidance.map((item, index) => `${index + 1}. ${item}`).join('\n\n')}\n\nè¯·æ ¹æ®ä»¥ä¸ŠæŒ‡å¯¼è¡¥å……ç—‡çŠ¶ä¿¡æ¯ï¼Œæé«˜è¯å‹è¯†åˆ«çš„å‡†ç¡®æ€§ã€‚`);
        }
        
        // URLå‚æ•°æ£€æŸ¥å‡½æ•°ï¼ˆåœ¨ä¸»åˆå§‹åŒ–ä¸­è°ƒç”¨ï¼‰
        function checkURLParameters() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const presetSymptoms = urlParams.get('symptoms');
                const presetDisease = urlParams.get('disease');
                
                if (presetDisease) {
                    const diseaseInput = document.getElementById('diseaseName');
                    if (diseaseInput) {
                        diseaseInput.value = presetDisease;
                        console.log('è®¾ç½®é¢„è®¾ç–¾ç—…:', presetDisease);
                    }
                }
                
                if (presetSymptoms) {
                    console.log('å‘ç°é¢„è®¾ç—‡çŠ¶:', presetSymptoms);
                    // TODO: åç»­å¯ä»¥æ·»åŠ è‡ªåŠ¨ç”Ÿæˆç—‡çŠ¶ç¾¤åŠŸèƒ½
                }
            } catch (error) {
                console.error('URLå‚æ•°æ£€æŸ¥å‡ºé”™:', error);
            }
        }
        
        console.log('å†³ç­–æ ‘æ„å»ºå™¨åŠ è½½å®Œæˆ');
        
        // ç´§æ€¥ä¿®å¤ï¼šå¼ºåˆ¶é‡æ–°ç»‘å®šä¸»è¦æŒ‰é’®äº‹ä»¶
        setTimeout(function() {
            console.log('å¼ºåˆ¶é‡æ–°ç»‘å®šäº‹ä»¶...');
            const generateBtn = document.getElementById('generateBtn');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const clearBtn = document.getElementById('clearBtn');
            
            if (generateBtn) {
                generateBtn.onclick = function() {
                    console.log('å¼ºåˆ¶ç»‘å®šçš„generateAITreeè¢«è°ƒç”¨');
                    generateAITree();
                };
                console.log('generateBtné‡æ–°ç»‘å®šæˆåŠŸ');
            }
            
            if (analyzeBtn) {
                analyzeBtn.onclick = function() {
                    console.log('å¼ºåˆ¶ç»‘å®šçš„analyzeCurrentTreeè¢«è°ƒç”¨');
                    analyzeCurrentTree();
                };
                console.log('analyzeBtné‡æ–°ç»‘å®šæˆåŠŸ');
            }
            
            if (clearBtn) {
                clearBtn.onclick = function() {
                    console.log('å¼ºåˆ¶ç»‘å®šçš„clearCanvasè¢«è°ƒç”¨');
                    clearCanvas();
                };
                console.log('clearBtné‡æ–°ç»‘å®šæˆåŠŸ');
            }
        }, 1000);
    </script>
</body>
</html>