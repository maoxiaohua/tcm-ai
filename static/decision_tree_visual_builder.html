<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>可视化决策树构建器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            display: flex;
            height: 100vh;
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }

        .sidebar {
            width: 300px;
            background: #f8fafc;
            border-right: 1px solid #e2e8f0;
            padding: 20px;
            overflow-y: auto;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .right-panel {
            width: 350px;
            background: #f8fafc;
            border-left: 1px solid #e2e8f0;
            padding: 20px;
            overflow-y: auto;
        }

        .header {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .canvas-area {
            flex: 1;
            background: white;
            border-radius: 8px;
            position: relative;
            overflow: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-height: 500px;
        }

        .section-title {
            font-size: 16px;
            font-weight: 600;
            color: #1e40af;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            color: #374151;
            font-weight: 500;
        }

        .form-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
        }

        .form-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .form-textarea {
            min-height: 80px;
            resize: vertical;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
        }

        .btn-success {
            background: #22c55e;
            color: white;
        }

        .btn-success:hover {
            background: #16a34a;
        }

        .btn-warning {
            background: #f59e0b;
            color: white;
        }

        .btn-warning:hover {
            background: #d97706;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .canvas {
            width: 100%;
            height: 100%;
            position: relative;
            padding: 20px;
            background: #fafbfc;
        }

        .canvas svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        .branch-line {
            stroke: #3b82f6;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }

        .branch-line.selected {
            stroke: #ef4444;
            stroke-width: 3;
        }

        .node {
            position: absolute;
            min-width: 120px;
            min-height: 60px;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 10px;
            cursor: move;
            user-select: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 10;
        }

        .node:hover {
            border-color: #3b82f6;
        }

        .node.selected {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .node.symptom { border-left: 4px solid #f59e0b; }
        .node.condition { border-left: 4px solid #0ea5e9; }
        .node.diagnosis { border-left: 4px solid #22c55e; }
        .node.treatment { border-left: 4px solid #ec4899; }
        .node.formula { border-left: 4px solid #a855f7; }

        .node-title {
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .node-content {
            font-size: 11px;
            color: #6b7280;
            word-break: break-word;
        }

        /* 相关症状样式 */
        .related-symptoms {
            margin-top: 8px;
            padding: 6px 8px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 4px;
            border-left: 3px solid #3b82f6;
        }

        .symptoms-label {
            font-size: 10px;
            color: #3b82f6;
            font-weight: 500;
            margin-bottom: 3px;
        }

        .symptoms-list {
            font-size: 10px;
            color: #1e40af;
            line-height: 1.3;
        }

        .node-desc {
            margin-top: 5px;
            font-size: 10px;
            color: #9ca3af;
            font-style: italic;
        }

        .empty-canvas {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #9ca3af;
            text-align: center;
        }

        .loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-content {
            text-align: center;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f4f6;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .result-panel {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .result-title {
            font-weight: 600;
            color: #1e40af;
            margin-bottom: 10px;
        }

        .auth-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, #3b82f6, #1e40af);
            color: white;
            padding: 10px 20px;
            font-size: 12px;
            z-index: 10000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .container.with-auth {
            margin-top: 45px;
            height: calc(100vh - 45px);
        }

        .suggestion-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .suggestion-item:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
        }

        .suggestion-content {
            font-weight: 500;
            color: #1e40af;
            margin-bottom: 4px;
        }

        .suggestion-desc {
            font-size: 12px;
            color: #6b7280;
        }

        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            min-width: 150px;
        }

        .context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #f1f5f9;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:last-child {
            border-bottom: none;
        }

        .context-menu-item:hover {
            background: #f8fafc;
        }

        .context-menu-item.danger {
            color: #ef4444;
        }

        .context-menu-item.danger:hover {
            background: #fef2f2;
        }

        .delete-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 12px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }

        .node:hover .delete-btn {
            display: flex;
        }

        .formula-analysis-panel {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .herb-item {
            display: inline-block;
            background: white;
            border: 1px solid #0ea5e9;
            border-radius: 15px;
            padding: 4px 8px;
            margin: 2px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .herb-item:hover {
            background: #0ea5e9;
            color: white;
        }

        .apply-formula-btn {
            background: #22c55e;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 12px;
            cursor: pointer;
            margin-top: 10px;
        }

        .apply-formula-btn:hover {
            background: #16a34a;
        }

        .auto-analysis-panel {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .pathway-step {
            background: white;
            border-left: 4px solid #3b82f6;
            padding: 10px;
            margin: 8px 0;
            border-radius: 0 6px 6px 0;
        }

        .add-pathway-btn {
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 11px;
            cursor: pointer;
            margin-left: 10px;
        }
        
        /* AI模式切换开关样式 */
        .toggle-switch {
            position: relative;
            display: inline-block;
        }
        
        .toggle-switch input[type="checkbox"] {
            display: none;
        }
        
        .toggle-label {
            display: block;
            width: 50px;
            height: 24px;
            background-color: #cbd5e0;
            border-radius: 12px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .toggle-switch input[type="checkbox"]:checked + .toggle-label {
            background-color: #3b82f6;
        }
        
        .toggle-switch input[type="checkbox"]:checked + .toggle-label .toggle-slider {
            transform: translateX(26px);
        }
        
        /* 数据来源标识样式 */
        .data-source-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .data-source-ai {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .data-source-template {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        
        .data-source-fallback {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            color: #8b4513;
        }
        
        /* 生成状态指示器 */
        .generation-status {
            margin-top: 10px;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            display: none;
        }
        
        .generation-status.ai-mode {
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            color: #1e40af;
        }
        
        .generation-status.template-mode {
            background: #fef3f2;
            border: 1px solid #fecaca;
            color: #dc2626;
        }
    </style>
</head>
<body>
    <div id="authBar"></div>
    <div class="container" id="mainContainer">
        <!-- 左侧工具栏 -->
        <div class="sidebar">
            <!-- 基本信息 -->
            <div class="section-title">🏥 基本信息</div>
            <div class="form-group">
                <label class="form-label">疾病名称</label>
                <input type="text" class="form-input" id="diseaseName" placeholder="如：失眠、胃痛、头痛">
            </div>
            <div class="form-group">
                <label class="form-label">诊疗思路</label>
                <textarea class="form-input form-textarea" id="doctorThought" placeholder="简述您的诊疗思路..."></textarea>
            </div>

            <!-- AI功能 -->
            <div class="section-title">🤖 智能功能</div>
            
            <!-- AI模式选择 -->
            <div class="ai-mode-selector" style="margin-bottom: 15px; padding: 12px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <span style="font-weight: 500; color: #374151;">生成模式:</span>
                    <div class="toggle-switch">
                        <input type="checkbox" id="aiModeToggle" checked>
                        <label for="aiModeToggle" class="toggle-label">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <span id="aiModeText" style="font-size: 12px; color: #6b7280;">AI智能模式</span>
                </div>
                <div id="aiStatusInfo" style="font-size: 11px; color: #9ca3af;">
                    <span id="aiStatusIndicator">⏳ 检查AI状态中...</span>
                </div>
            </div>
            
            <div class="btn-group">
                <button class="btn btn-primary" id="generateBtn">
                    <span id="generateBtnIcon">🤖</span> 
                    <span id="generateBtnText">智能生成决策树</span>
                </button>
                <button class="btn btn-warning" id="analyzeBtn">🧠 理论分析</button>
                <button class="btn btn-success" id="suggestBtn">💡 遗漏检测</button>
            </div>
            <div class="btn-group">
                <button class="btn btn-warning" id="symptomDetectBtn" style="background: #f59e0b;">🔍 症状遗漏检测</button>
                <button class="btn btn-primary" id="formulaAnalyzeBtn" style="background: #a855f7;">💊 方剂AI分析</button>
            </div>
            <div class="btn-group">
                <button class="btn btn-success" id="autoPathwayBtn" style="background: #059669;">🤖 智能诊疗路径</button>
                <button class="btn btn-warning" id="syndromeAnalyzeBtn" style="background: #d97706;">🎯 证型智能识别</button>
            </div>

            <!-- 快速操作 -->
            <div class="section-title">⚡ 快速操作</div>
            <div class="btn-group">
                <button class="btn btn-primary" id="addPathBtn">📋 标准路径</button>
                <button class="btn btn-success" id="arrangeBtn">📐 自动排列</button>
                <button class="btn btn-danger" id="clearBtn">🗑️ 清空画布</button>
            </div>

            <!-- 保存导出 -->
            <div class="section-title">💾 保存导出</div>
            <div class="btn-group">
                <button class="btn btn-success" id="saveBtn">💾 保存决策树</button>
                <button class="btn btn-primary" id="exportBtn">📄 导出JSON</button>
            </div>

            <!-- 选中节点信息 -->
            <div id="selectedNodeInfo" style="display: none;">
                <div class="section-title">📍 选中节点</div>
                <div class="result-panel">
                    <div id="nodeInfoContent"></div>
                </div>
            </div>
        </div>

        <!-- 主要内容区域 -->
        <div class="main-content">
            <div class="header">
                <h1 style="color: #1e40af; margin-bottom: 10px;">🌳 可视化决策树构建器</h1>
                <p style="color: #6b7280; font-size: 14px;">构建中医智能诊疗决策树，支持AI生成和可视化编辑</p>
            </div>

            <!-- 生成状态和数据来源显示 -->
            <div id="generationStatusPanel" class="generation-status" style="display: none;">
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span id="dataSourceBadge" class="data-source-badge data-source-template">Template</span>
                        <span id="generationInfo">已使用标准模板生成</span>
                    </div>
                    <div style="font-size: 10px; color: #6b7280;">
                        <span id="generationTime">即时</span>
                    </div>
                </div>
            </div>

            <div class="canvas-area">
                <div class="canvas" id="canvas">
                    <svg id="branchSvg">
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#3b82f6" />
                            </marker>
                        </defs>
                    </svg>
                    <div class="empty-canvas" id="emptyHint">
                        <div style="font-size: 48px; margin-bottom: 20px;">🌳</div>
                        <h3>开始构建您的决策树</h3>
                        <p style="margin: 10px 0;">输入疾病名称，然后点击"AI生成决策树"</p>
                        <p style="color: #9ca3af; font-size: 12px;">或点击"标准路径"快速开始</p>
                    </div>
                </div>
                <div class="loading" id="loading" style="display: none;">
                    <div class="loading-content">
                        <div class="spinner"></div>
                        <div id="loadingText">加载中...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 右侧分析结果面板 -->
        <div class="right-panel">
            <!-- 中医辨证思维指导 -->
            <div class="section-title">🎯 中医辨证思维指导</div>
            <div class="tcm-guide-panel" style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                <h4 style="color: #0284c7; margin-bottom: 10px;">标准诊疗流程</h4>
                <ol style="font-size: 12px; color: #374151; line-height: 1.6; margin: 0; padding-left: 20px;">
                    <li><strong>病种识别</strong>: 确定疾病的中医病名</li>
                    <li><strong>四诊收集</strong>: 望闻问切，收集全面信息</li>
                    <li><strong>主要症状</strong>: 主症、兼症的归纳分析</li>
                    <li><strong>病因病机</strong>: 分析发病原因和病理机制</li>
                    <li><strong>证候判断</strong>: 辨证分型（支持多种证型）</li>
                    <li><strong>治则治法</strong>: 确定治疗原则和方法</li>
                    <li><strong>方剂处方</strong>: 选方用药，君臣佐使</li>
                    <li><strong>随症加减</strong>: 根据具体症状调整用药</li>
                    <li><strong>预后调理</strong>: 养生建议和注意事项</li>
                </ol>
                
                <div style="margin-top: 15px; padding: 10px; background: #fef3c7; border-radius: 6px;">
                    <h5 style="color: #f59e0b; margin-bottom: 5px;">💡 构建技巧</h5>
                    <ul style="font-size: 11px; color: #78716c; margin: 0; padding-left: 20px;">
                        <li>右键点击节点可添加分支或编辑</li>
                        <li>双击节点内容可直接编辑</li>
                        <li>证候判断支持多分支（不同证型）</li>
                        <li>使用AI功能可快速生成框架</li>
                        <li>点击"自动排列"优化布局</li>
                    </ul>
                </div>
                
                <div style="margin-top: 10px; text-align: center;">
                    <button onclick="showTCMExample()" style="background: #0ea5e9; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 11px; cursor: pointer;">
                        查看示例决策树
                    </button>
                </div>
            </div>
            
            <div class="section-title">📊 分析结果</div>
            <div id="analysisResults"></div>
        </div>
    </div>

    <script>
        // 全局变量
        let nodes = [];
        let selectedNode = null;
        let nodeCounter = 1;
        let isAuthenticated = false;
        let currentUser = null;
        let connections = [];
        let symptomClusters = new Map(); // 症状群存储
        
        // 症状群数据结构
        const SYMPTOM_CLUSTER_TEMPLATES = {
            '失眠群': {
                mainDisease: '失眠',
                icon: '😴',
                color: '#8b5cf6',
                relatedSymptoms: ['早醒', '多梦', '入睡困难', '睡眠浅', '易惊醒'],
                accompanyingSymptoms: ['心烦', '健忘', '头晕', '疲乏']
            },
            '胃痛群': {
                mainDisease: '胃痛',
                icon: '🤢',
                color: '#f59e0b',
                relatedSymptoms: ['胃胀', '反酸', '嗳气', '恶心', '胃脏疼痛'],
                accompanyingSymptoms: ['食欲不振', '乏力', '腹胀', '便秘']
            }
        };

        // 辅助函数：获取疾病名称
        function getCurrentDiseaseName() {
            const value = document.getElementById('diseaseName')?.value?.trim() || '';
            // 演示：添加输入验证
            if (value && value.length < 2) {
                console.warn('疾病名称过短，建议至少2个字符');
                return '';
            }
            return value;
        }

        // 全局AI状态变量
        let aiStatus = {
            ai_enabled: false,
            available: false,
            model: 'unknown',
            features: {
                decision_tree_generation: false,
                theory_analysis: false,
                hybrid_mode: false
            }
        };
        
        // 用户模式偏好
        let userPreferences = {
            aiModePreferred: true,
            complexityLevel: 'standard'
        };

        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 页面初始化开始...');
            
            // 初始化AI状态检查
            initializeAIStatus();
            
            // 初始化模式切换
            initializeModeToggle();
            
            console.log('检查元素是否存在:');
            console.log('generateBtn:', document.getElementById('generateBtn'));
            console.log('analyzeBtn:', document.getElementById('analyzeBtn'));
            console.log('diseaseName:', document.getElementById('diseaseName'));
            
            // 简单测试：直接绑定一个简单的点击事件
            const testBtn = document.getElementById('generateBtn');
            if (testBtn) {
                console.log('尝试绑定简单测试事件...');
                testBtn.onclick = function() {
                    console.log('简单点击事件工作正常!');
                    alert('按钮点击成功!');
                    return false;
                };
            }
            
            try {
                initializeAuth();
                initializeEventListeners();
                checkURLParameters();
                console.log('页面初始化完成');
            } catch (error) {
                console.error('页面初始化出错:', error);
            }
        });

        // 初始化认证状态
        async function initializeAuth() {
            const urlParams = new URLSearchParams(window.location.search);
            
            if (urlParams.get('auto_auth') === '1') {
                const doctorToken = urlParams.get('doctor_token');
                const doctorName = decodeURIComponent(urlParams.get('doctor_name') || '');
                
                if (doctorToken && doctorName) {
                    localStorage.setItem('token', doctorToken);
                    localStorage.setItem('doctorToken', doctorToken);
                    localStorage.setItem('doctorName', doctorName);
                    
                    showAuthStatus(doctorName, true);
                    
                    // 清理URL参数
                    const cleanUrl = window.location.pathname;
                    window.history.replaceState({}, document.title, cleanUrl);
                }
            } else {
                await checkExistingAuth();
            }
        }

        // 检查现有认证状态
        async function checkExistingAuth() {
            const token = localStorage.getItem('token');
            if (!token) return;

            try {
                const response = await fetch('/api/doctor/current', {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    showAuthStatus(data.name, true);
                    isAuthenticated = true;
                    currentUser = data;
                }
            } catch (error) {
                console.log('认证检查失败:', error);
            }
        }

        // 显示认证状态
        function showAuthStatus(doctorName, isLoggedIn) {
            const authBar = document.getElementById('authBar');
            const container = document.getElementById('mainContainer');
            
            if (isLoggedIn) {
                authBar.className = 'auth-bar';
                authBar.innerHTML = `
                    ✅ 已登录医生: ${doctorName} | 决策树将自动保存到您的账户
                    <button onclick="logout()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 4px 12px; border-radius: 4px; margin-left: 20px; cursor: pointer; font-size: 12px;">退出登录</button>
                `;
                container.classList.add('with-auth');
                isAuthenticated = true;
            }
        }

        // 退出登录
        function logout() {
            localStorage.removeItem('token');
            localStorage.removeItem('doctorToken');
            localStorage.removeItem('doctorName');
            document.getElementById('authBar').innerHTML = '';
            document.getElementById('mainContainer').classList.remove('with-auth');
            isAuthenticated = false;
            currentUser = null;
        }

        // 初始化事件监听器
        function initializeEventListeners() {
            try {
                // AI功能按钮
                document.getElementById('generateBtn').addEventListener('click', generateAITree);
                document.getElementById('analyzeBtn').addEventListener('click', analyzeCurrentTree);
                document.getElementById('suggestBtn').addEventListener('click', suggestMissingLogic);
                
                // 专业功能按钮
                document.getElementById('symptomDetectBtn').addEventListener('click', detectMissingSymptoms);
                document.getElementById('formulaAnalyzeBtn').addEventListener('click', analyzeFormula);
                
                // 快速操作按钮
                const autoPathwayBtn = document.getElementById('autoPathwayBtn');
                if (autoPathwayBtn) autoPathwayBtn.addEventListener('click', generateAutoPathway);
                
                const syndromeAnalyzeBtn = document.getElementById('syndromeAnalyzeBtn');
                if (syndromeAnalyzeBtn) syndromeAnalyzeBtn.addEventListener('click', analyzeSyndrome);
                
                // 快速操作按钮
                const addPathBtn = document.getElementById('addPathBtn');
                if (addPathBtn) addPathBtn.addEventListener('click', addStandardPath);
                
                const arrangeBtn = document.getElementById('arrangeBtn');
                if (arrangeBtn) {
                    arrangeBtn.onclick = function(e) {
                        e.preventDefault();
                        console.log('arrangeBtn被点击了!');
                        autoArrangeNodes();
                        return false;
                    };
                }
                
                const clearBtn = document.getElementById('clearBtn');
                if (clearBtn) {
                    clearBtn.onclick = function(e) {
                        e.preventDefault();
                        console.log('clearBtn被点击了!');
                        clearCanvas();
                        return false;
                    };
                }
            
                // 保存导出按钮
                const saveBtn = document.getElementById('saveBtn');
                if (saveBtn) saveBtn.addEventListener('click', saveDecisionTree);
                
                const exportBtn = document.getElementById('exportBtn');
                if (exportBtn) exportBtn.addEventListener('click', exportJSON);

                // 全局事件
                document.addEventListener('contextmenu', hideContextMenu);
                document.addEventListener('click', hideContextMenu);
                
                console.log('事件监听器初始化完成');
            } catch (error) {
                console.error('事件监听器初始化失败:', error);
            }
        }

        // 初始化AI状态检查
        async function initializeAIStatus() {
            try {
                console.log('🔍 检查AI状态...');
                const response = await fetch('/api/ai_status');
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        aiStatus = data.data;
                        updateAIStatusDisplay();
                        console.log('✅ AI状态获取成功:', aiStatus);
                    } else {
                        console.warn('⚠️ AI状态获取失败:', data.message);
                        updateAIStatusDisplay(false, data.message);
                    }
                } else {
                    console.warn('⚠️ AI状态API不可用 (404)，使用降级模式');
                    // 降级处理：假设AI可用，让用户自己选择
                    aiStatus.ai_enabled = true;
                    updateAIStatusDisplay(true, '');
                    
                    // 更新状态显示
                    const statusIndicator = document.getElementById('aiStatusIndicator');
                    if (statusIndicator) {
                        statusIndicator.innerHTML = '⚡ 混合模式 (API降级)';
                        statusIndicator.style.color = '#f59e0b';
                    }
                }
            } catch (error) {
                console.error('❌ AI状态检查网络失败:', error);
                console.log('🔄 启用降级模式，允许用户选择');
                
                // 网络错误也启用降级模式
                aiStatus.ai_enabled = true;
                updateAIStatusDisplay(true, '');
                
                const statusIndicator = document.getElementById('aiStatusIndicator');
                if (statusIndicator) {
                    statusIndicator.innerHTML = '⚡ 混合模式 (网络降级)';
                    statusIndicator.style.color = '#f59e0b';
                }
            }
        }
        
        // 更新AI状态显示
        function updateAIStatusDisplay(success = true, errorMessage = '') {
            const statusIndicator = document.getElementById('aiStatusIndicator');
            const aiModeToggle = document.getElementById('aiModeToggle');
            const aiModeText = document.getElementById('aiModeText');
            
            if (success && aiStatus.ai_enabled) {
                // AI可用或降级模式
                if (!statusIndicator.innerHTML.includes('混合模式')) {
                    statusIndicator.innerHTML = `✅ AI已就绪 (${aiStatus.model || 'qwen-max'})`;
                    statusIndicator.style.color = '#059669';
                }
                aiModeToggle.disabled = false;
                
                console.log('🎛️ AI模式切换已启用');
            } else if (errorMessage && !errorMessage.includes('降级')) {
                // 只有在真正错误时才禁用
                const message = errorMessage || 'AI服务不可用，将使用模板模式';
                statusIndicator.innerHTML = `⚠️ ${message}`;
                statusIndicator.style.color = '#d97706';
                aiModeToggle.checked = false;
                aiModeToggle.disabled = true;
                updateModeDisplay(false);
                
                console.log('🚫 AI模式切换已禁用');
            } else {
                // 降级模式：保持切换可用
                aiModeToggle.disabled = false;
                console.log('⚡ 降级模式：AI切换保持可用');
            }
        }
        
        // 初始化模式切换
        function initializeModeToggle() {
            const aiModeToggle = document.getElementById('aiModeToggle');
            
            console.log('🔧 初始化模式切换...');
            console.log('  - Toggle元素:', aiModeToggle);
            console.log('  - AI状态:', aiStatus);
            
            if (aiModeToggle) {
                // 移除可能存在的旧事件监听器
                aiModeToggle.removeEventListener('change', handleModeToggle);
                
                // 添加新的事件监听器
                aiModeToggle.addEventListener('change', handleModeToggle);
                
                // 初始化显示状态
                const initialUseAI = aiModeToggle.checked && aiStatus.ai_enabled;
                updateModeDisplay(initialUseAI);
                
                console.log('✅ 模式切换初始化完成');
            } else {
                console.error('❌ 找不到aiModeToggle元素');
            }
        }
        
        // 模式切换处理函数
        function handleModeToggle() {
            const useAI = this.checked && aiStatus.ai_enabled;
            console.log('🔄 模式切换事件触发:');
            console.log('  - Toggle选中:', this.checked);
            console.log('  - AI可用:', aiStatus.ai_enabled);
            console.log('  - 最终模式:', useAI ? 'AI模式' : '模板模式');
            
            updateModeDisplay(useAI);
            
            // 可选：保存用户偏好
            if (typeof userPreferences !== 'undefined') {
                userPreferences.aiModePreferred = useAI;
            }
        }
        
        // 更新模式显示
        function updateModeDisplay(useAI) {
            const aiModeText = document.getElementById('aiModeText');
            const generateBtnIcon = document.getElementById('generateBtnIcon');
            const generateBtnText = document.getElementById('generateBtnText');
            
            if (useAI) {
                aiModeText.textContent = 'AI智能模式';
                aiModeText.style.color = '#3b82f6';
                generateBtnIcon.textContent = '🤖';
                generateBtnText.textContent = 'AI智能生成';
            } else {
                aiModeText.textContent = '标准模板模式';
                aiModeText.style.color = '#6b7280';
                generateBtnIcon.textContent = '📋';
                generateBtnText.textContent = '标准模板生成';
            }
            
            userPreferences.aiModePreferred = useAI;
        }
        
        // 显示生成状态和数据来源
        function showGenerationStatus(source, info, time) {
            const statusPanel = document.getElementById('generationStatusPanel');
            const dataSourceBadge = document.getElementById('dataSourceBadge');
            const generationInfo = document.getElementById('generationInfo');
            const generationTime = document.getElementById('generationTime');
            
            // 更新数据来源标识
            dataSourceBadge.className = `data-source-badge data-source-${source}`;
            switch (source) {
                case 'ai':
                    dataSourceBadge.textContent = '🤖 AI Generated';
                    generationInfo.textContent = info || '已使用AI智能生成';
                    break;
                case 'template':
                    dataSourceBadge.textContent = '📋 Template';
                    generationInfo.textContent = info || '已使用标准模板生成';
                    break;
                case 'template_fallback':
                    dataSourceBadge.textContent = '⚠️ Fallback';
                    generationInfo.textContent = info || 'AI失败，使用模板备用';
                    break;
            }
            
            generationTime.textContent = time || '即时';
            
            // 显示状态面板
            statusPanel.style.display = 'block';
            statusPanel.className = `generation-status ${source === 'ai' ? 'ai-mode' : 'template-mode'}`;
        }

        // AI生成决策树（升级版）
        async function generateAITree() {
            console.log('🚀 智能生成决策树被调用');
            
            // 直接使用getCurrentDiseaseName()，不声明局部变量
            if (!getCurrentDiseaseName()) {
                alert('请先输入疾病名称');
                return;
            }

            const doctorThought = document.getElementById('doctorThought').value.trim();
            const useAI = document.getElementById('aiModeToggle').checked && aiStatus.ai_enabled;
            
            // 根据模式显示不同的loading信息
            const loadingMessage = useAI ? 
                (doctorThought ? 'AI正在根据您的思路生成决策树...' : 'AI正在生成标准决策树...') :
                '正在加载标准模板...';
            
            showLoading(loadingMessage);

            try {
                const response = await fetch('/api/generate_visual_decision_tree', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        disease_name: getCurrentDiseaseName(),
                        thinking_process: doctorThought,
                        use_ai: useAI,
                        include_tcm_analysis: true,
                        complexity_level: userPreferences.complexityLevel
                    })
                });

                const result = await response.json();
                
                if (result.success && result.data && result.data.paths) {
                    const pathsData = result.data.paths;
                    const source = result.data.source || 'template';
                    const generationTime = result.data.generation_time || '即时';
                    
                    generateNodesFromPaths(pathsData);
                    hideLoading();
                    
                    // 显示生成状态
                    showGenerationStatus(
                        source, 
                        result.message,
                        generationTime
                    );
                    
                    showResult('成功', `✅ 成功生成了${pathsData.length}条诊疗路径！`, 'success');
                    console.log('📊 生成统计:', {
                        source: source,
                        pathCount: pathsData.length,
                        aiEnabled: aiStatus.ai_enabled,
                        userThinking: !!doctorThought
                    });
                } else {
                    throw new Error(result.message || '生成失败');
                }
            } catch (error) {
                console.error('❌ 生成失败:', error);
                hideLoading();
                showResult('错误', `❌ 生成失败: ${error.message}`, 'error');
            }
        }

        // 从AI路径数据生成节点（优化版：支持中医诊疗流程）
        function generateNodesFromPaths(paths) {
            clearCanvas();
            
            // 重新组织路径数据以符合中医诊疗流程
            const tcmFlowPaths = organizeTCMFlow(paths);
            
            let baseX = 50, baseY = 100;
            const stepWidth = 250;
            const branchHeight = 150;
            
            // 生成主诊疗流程
            let previousMainNode = null;
            tcmFlowPaths.mainFlow.forEach((step, index) => {
                const node = {
                    id: `main_${index}`,
                    type: step.type,
                    name: step.name,
                    description: step.description || step.content,
                    x: baseX + (index * stepWidth),
                    y: baseY
                };
                
                nodes.push(node);
                renderNode(node);
                
                if (previousMainNode) {
                    connections.push({
                        from: previousMainNode.id,
                        to: node.id
                    });
                }
                
                previousMainNode = node;
                
                // 处理分支（如证候分型）
                if (step.branches && step.branches.length > 0) {
                    step.branches.forEach((branch, branchIndex) => {
                        const branchNode = {
                            id: `branch_${index}_${branchIndex}`,
                            type: branch.type,
                            name: branch.name,
                            description: branch.description,
                            x: node.x + stepWidth,
                            y: baseY + (branchIndex - (step.branches.length - 1) / 2) * branchHeight
                        };
                        
                        nodes.push(branchNode);
                        renderNode(branchNode);
                        
                        connections.push({
                            from: node.id,
                            to: branchNode.id
                        });
                        
                        // 为每个分支添加后续节点
                        if (branch.followUp) {
                            branch.followUp.forEach((followStep, followIndex) => {
                                const followNode = {
                                    id: `follow_${index}_${branchIndex}_${followIndex}`,
                                    type: followStep.type,
                                    name: followStep.name,
                                    description: followStep.description,
                                    x: branchNode.x + (followIndex + 1) * stepWidth,
                                    y: branchNode.y
                                };
                                
                                nodes.push(followNode);
                                renderNode(followNode);
                                
                                const prevNode = followIndex === 0 ? branchNode : 
                                    nodes.find(n => n.id === `follow_${index}_${branchIndex}_${followIndex-1}`);
                                
                                connections.push({
                                    from: prevNode.id,
                                    to: followNode.id
                                });
                            });
                        }
                    });
                }
            });
            
            updateCanvas();
            drawConnections();
            
            // 自动排列优化
            setTimeout(() => autoArrangeNodes(), 100);
        }
        
        // 组织中医诊疗流程
        function organizeTCMFlow(paths) {
            // 定义中医诊疗标准流程
            const tcmStages = [
                'disease',        // 病种
                'four_diagnosis', // 四诊
                'symptom',        // 症状
                'pathogenesis',   // 病因病机
                'syndrome',       // 证候
                'principle',      // 治则
                'prescription',   // 处方
                'modification',   // 加减
                'prognosis'       // 预后
            ];
            
            const mainFlow = [];
            const diseaseInfo = getCurrentDiseaseName();
            
            // 构建主流程
            if (diseaseInfo) {
                mainFlow.push({
                    type: 'disease',
                    name: diseaseInfo,
                    description: '病种识别和确认'
                });
            }
            
            // 从原始路径中提取和组织信息
            paths.forEach(path => {
                path.steps.forEach(step => {
                    const stageIndex = tcmStages.indexOf(step.type);
                    if (stageIndex !== -1) {
                        // 将步骤按照中医流程顺序组织
                        const existingStage = mainFlow.find(s => s.type === step.type);
                        if (!existingStage) {
                            mainFlow.push({
                                type: step.type,
                                name: step.content || getDefaultNodeName(step.type),
                                description: step.description || '',
                                branches: []
                            });
                        } else if (step.type === 'syndrome' || step.type === 'prescription') {
                            // 对于证候和处方，支持多分支
                            existingStage.branches.push({
                                type: step.type,
                                name: step.content,
                                description: step.description || ''
                            });
                        }
                    }
                });
            });
            
            // 按照中医流程顺序排序
            mainFlow.sort((a, b) => {
                const aIndex = tcmStages.indexOf(a.type);
                const bIndex = tcmStages.indexOf(b.type);
                return aIndex - bIndex;
            });
            
            return { mainFlow };
        }

        // 分析当前决策树
        async function analyzeCurrentTree() {
            console.log('分析当前决策树被调用');
            
            if (nodes.length === 0) {
                alert('请先创建或生成决策树');
                return;
            }

            // 直接使用getCurrentDiseaseName()，不声明局部变量
            if (!getCurrentDiseaseName()) {
                alert('请先输入疾病名称');
                return;
            }

            showLoading('正在进行中医理论分析...');

            try {
                const treeData = {
                    disease_name: getCurrentDiseaseName(),
                    nodes: nodes
                };

                const response = await fetch('/api/analyze_tree_tcm_theory', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        tree_data: treeData,
                        disease_name: getCurrentDiseaseName()
                    })
                });

                const data = await response.json();
                
                if (data.success && data.data) {
                    hideLoading();
                    showAnalysisResult(data.data.analysis || '分析完成');
                } else {
                    throw new Error(data.message || '分析失败');
                }
            } catch (error) {
                console.error('理论分析失败:', error);
                hideLoading();
                showResult('错误', `❌ 分析失败: ${error.message}`, 'error');
            }
        }

        // 建议遗漏逻辑
        async function suggestMissingLogic() {
            console.log('建议遗漏逻辑被调用');
            
            if (nodes.length === 0) {
                alert('请先创建或生成决策树');
                return;
            }

            // 直接使用getCurrentDiseaseName()，不声明局部变量
            if (!getCurrentDiseaseName()) {
                alert('请先输入疾病名称');
                return;
            }

            showLoading('正在检测遗漏逻辑...');

            try {
                const response = await fetch('/api/detect_missing_logic', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        disease_name: getCurrentDiseaseName(),
                        current_paths: [],
                        existing_nodes: nodes
                    })
                });

                const data = await response.json();
                
                if (data.success && data.data) {
                    hideLoading();
                    showMissingLogicResult(data.data);
                } else {
                    throw new Error(data.message || '检测失败');
                }
            } catch (error) {
                console.error('遗漏逻辑检测失败:', error);
                hideLoading();
                showResult('错误', `❌ 检测失败: ${error.message}`, 'error');
            }
        }

        // 添加标准路径
        function addStandardPath() {
            console.log('添加标准路径被调用');
            
            // 直接使用getCurrentDiseaseName()，不声明局部变量
            
            clearCanvas();
            
            // 检查是否应该创建症状群
            const template = SYMPTOM_CLUSTER_TEMPLATES[`${getCurrentDiseaseName()}群`];
            if (template) {
                // 创建症状群模式
                // TODO: 优化后添加症状群功能
                
                // 创建后续节点
                const followUpNodes = [
                    { type: 'diagnosis', name: '中医诊断', description: '辨证分型', x: 400, y: 150 },
                    { type: 'treatment', name: '治疗方法', description: '治则治法', x: 650, y: 150 },
                    { type: 'formula', name: '方剂选择', description: '具体方药', x: 900, y: 150 }
                ];
                
                let previousNode = null;
                followUpNodes.forEach((nodeData, index) => {
                    const node = {
                        id: `std_${index + 2}`,
                        ...nodeData
                    };
                    nodes.push(node);
                    renderNode(node);
                    previousNode = node;
                });
            } else {
                // 传统模式 - 创建符合中医诊疗流程的标准路径节点
                const standardNodes = [
                    { type: 'disease', name: `${getCurrentDiseaseName()}`, description: '病种识别', x: 50, y: 100 },
                    { type: 'four_diagnosis', name: '四诊收集', description: '望闻问切', x: 250, y: 100 },
                    { type: 'symptom', name: '主要症状', description: '症状分析', x: 450, y: 100 },
                    { type: 'pathogenesis', name: '病因病机', description: '病理分析', x: 650, y: 100 },
                    { type: 'syndrome', name: '证候判断', description: '辨证分型', x: 850, y: 100 },
                    { type: 'principle', name: '治则治法', description: '确定治疗原则', x: 1050, y: 100 },
                    { type: 'prescription', name: '方剂处方', description: '选方用药', x: 1250, y: 100 },
                    { type: 'formula', name: '方剂选择', description: '具体方药', x: 1050, y: 100 }
                ];
                
                let previousNode = null;
                standardNodes.forEach((nodeData, index) => {
                    const node = {
                        id: `std_${index + 1}`,
                        ...nodeData
                    };
                    nodes.push(node);
                    renderNode(node);
                    
                    // 创建连接
                    if (previousNode) {
                        connections.push({
                            from: previousNode.id,
                            to: node.id
                        });
                    }
                    
                    previousNode = node;
                });
            }
            
            let previousNode = null;
            standardNodes.forEach((nodeData, index) => {
                const node = {
                    id: `std_${index + 1}`,
                    ...nodeData
                };
                nodes.push(node);
                renderNode(node);
                
                // 创建连接
                if (previousNode) {
                    connections.push({
                        from: previousNode.id,
                        to: node.id
                    });
                }
                
                previousNode = node;
            });
            
            updateCanvas();
            drawConnections();
            showResult('成功', '✅ 标准诊疗路径已添加', 'success');
        }

        // 自动排列节点
        function autoArrangeNodes() {
            console.log('自动排列节点被调用');
            
            if (nodes.length === 0) {
                showResult('提示', '没有节点需要排列', 'info');
                return;
            }
            
            // 基于中医诊疗流程的智能排列
            const nodeHierarchy = buildNodeHierarchy();
            
            // 计算布局
            const baseX = 50;
            const baseY = 300;
            const horizontalGap = 280;
            const verticalGap = 150;
            
            // 按层级排列
            Object.keys(nodeHierarchy).forEach((level, levelIndex) => {
                const levelNodes = nodeHierarchy[level];
                const levelX = baseX + levelIndex * horizontalGap;
                
                levelNodes.forEach((node, nodeIndex) => {
                    // 计算垂直位置，使同层节点居中分布
                    const totalHeight = (levelNodes.length - 1) * verticalGap;
                    const startY = baseY - (totalHeight / 2);
                    node.x = levelX;
                    node.y = startY + (nodeIndex * verticalGap);
                    
                    updateNodePosition(node);
                });
            });
            
            // 重绘连接线
            setTimeout(() => {
                drawConnections();
                showResult('成功', `✅ 已按中医诊疗流程智能排列${nodes.length}个节点`, 'success');
            }, 50);
        }
        
        // 构建节点层级关系
        function buildNodeHierarchy() {
            const hierarchy = {};
            const visited = new Set();
            
            // 查找根节点（没有入边的节点）
            const rootNodes = nodes.filter(node => {
                return !connections.some(conn => conn.to === node.id);
            });
            
            // 如果没有明确的根节点，选择病种类型的节点作为根
            if (rootNodes.length === 0) {
                const diseaseNodes = nodes.filter(n => n.type === 'disease');
                if (diseaseNodes.length > 0) {
                    rootNodes.push(...diseaseNodes);
                } else if (nodes.length > 0) {
                    rootNodes.push(nodes[0]);
                }
            }
            
            // 广度优先遍历构建层级
            let currentLevel = 0;
            let currentLevelNodes = rootNodes;
            
            while (currentLevelNodes.length > 0 && currentLevel < 10) {
                hierarchy[currentLevel] = [...currentLevelNodes];
                currentLevelNodes.forEach(n => visited.add(n.id));
                
                // 获取下一层节点
                const nextLevelNodes = [];
                currentLevelNodes.forEach(node => {
                    const childConnections = connections.filter(conn => conn.from === node.id);
                    childConnections.forEach(conn => {
                        const childNode = nodes.find(n => n.id === conn.to);
                        if (childNode && !visited.has(childNode.id)) {
                            nextLevelNodes.push(childNode);
                            visited.add(childNode.id);
                        }
                    });
                });
                
                currentLevelNodes = nextLevelNodes;
                currentLevel++;
            }
            
            return hierarchy;
        }

        // 清空画布
        function clearCanvas() {
            console.log('清空画布被调用');
            
            nodes = [];
            selectedNode = null;
            connections = [];
            
            const canvas = document.getElementById('canvas');
            canvas.innerHTML = `
                <svg id="branchSvg">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#3b82f6" />
                        </marker>
                    </defs>
                </svg>
                <div class="empty-canvas" id="emptyHint">
                    <div style="font-size: 48px; margin-bottom: 20px;">🌳</div>
                    <h3>开始构建您的决策树</h3>
                    <p style="margin: 10px 0;">输入疾病名称，然后点击"AI生成决策树"</p>
                    <p style="color: #9ca3af; font-size: 12px;">或点击"标准路径"快速开始</p>
                </div>
            `;
            
            clearResults();
            hideSelectedNodeInfo();
            showResult('成功', '✅ 画布已清空', 'success');
        }

        // 保存决策树
        async function saveDecisionTree() {
            console.log('保存决策树被调用');
            
            // 直接使用getCurrentDiseaseName()，不声明局部变量
            if (!getCurrentDiseaseName()) {
                alert('请先输入疾病名称');
                return;
            }

            if (nodes.length === 0) {
                alert('请先构建决策树');
                return;
            }

            if (!isAuthenticated) {
                alert('请先登录医生账户');
                return;
            }

            showLoading('正在保存决策树...');

            try {
                const saveData = {
                    disease_name: getCurrentDiseaseName(),
                    paths: convertNodesToPaths(),
                    integration_enabled: true
                };

                const response = await fetch('/api/save_decision_tree_v3', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify(saveData)
                });

                const data = await response.json();
                
                if (data.success) {
                    hideLoading();
                    showResult('成功', `✅ 决策树已保存！包含${nodes.length}个节点`, 'success');
                } else {
                    throw new Error(data.message || '保存失败');
                }
            } catch (error) {
                console.error('保存失败:', error);
                hideLoading();
                showResult('错误', `❌ 保存失败: ${error.message}`, 'error');
            }
        }

        // 导出JSON
        function exportJSON() {
            console.log('导出JSON被调用');
            
            // 直接使用getCurrentDiseaseName()，不声明局部变量
            
            const exportData = {
                disease_name: getCurrentDiseaseName() || '未命名疾病',
                nodes: nodes,
                exported_at: new Date().toISOString(),
                version: '2.0'
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `决策树_${getCurrentDiseaseName() || '未命名'}_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
            showResult('成功', '✅ JSON文件已下载', 'success');
        }

        // 渲染节点
        function renderNode(node) {
            const canvas = document.getElementById('canvas');
            const emptyHint = document.getElementById('emptyHint');
            
            if (emptyHint) {
                emptyHint.remove();
            }

            const nodeElement = document.createElement('div');
            nodeElement.className = `node ${node.type}`;
            nodeElement.id = node.id;
            nodeElement.style.left = `${node.x}px`;
            nodeElement.style.top = `${node.y}px`;
            
            // 构建节点内容，支持相关症状显示
            let nodeContent = node.description || '';
            if (node.relatedSymptoms && node.relatedSymptoms.length > 0) {
                nodeContent = `${nodeContent}
                    <div class="related-symptoms">
                        <div class="symptoms-label">相关症状:</div>
                        <div class="symptoms-list">${node.relatedSymptoms.join(', ')}</div>
                    </div>`;
            }
            
            nodeElement.innerHTML = `
                <button class="delete-btn" onclick="deleteNodeById('${node.id}')">×</button>
                <div class="node-title">${node.name}</div>
                <div class="node-content">${nodeContent}</div>
            `;
            
            // 添加点击事件
            nodeElement.addEventListener('click', function(e) {
                e.stopPropagation();
                selectNode(node);
            });
            
            // 添加右键菜单事件
            nodeElement.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                e.stopPropagation();
                showContextMenu(e, node);
            });
            
            // 使用统一的编辑功能绑定
            ensureNodeEditability(nodeElement, node);
            
            // 添加拖拽
            makeNodeDraggable(nodeElement, node);
            
            canvas.appendChild(nodeElement);
        }

        // 编辑节点内容
        function editNodeContent(node) {
            const nodeElement = document.getElementById(node.id);
            const contentDiv = nodeElement.querySelector('.node-content');
            const originalContent = node.description || '';
            
            // 创建编辑输入框
            const textarea = document.createElement('textarea');
            textarea.className = 'node-edit-input';
            textarea.value = originalContent;
            textarea.style.cssText = `
                width: 100%;
                height: 60px;
                border: 2px solid #007bff;
                border-radius: 4px;
                padding: 5px;
                font-size: 12px;
                font-family: inherit;
                resize: vertical;
                background: #fff;
                z-index: 1000;
            `;
            
            // 替换内容
            contentDiv.innerHTML = '';
            contentDiv.appendChild(textarea);
            textarea.focus();
            textarea.select();
            
            // 保存编辑
            function saveEdit() {
                const newContent = textarea.value.trim();
                if (newContent !== originalContent) {
                    node.description = newContent;
                    updateNodeDisplay(node);
                    // 如果当前节点被选中，更新侧边栏信息
                    if (selectedNode && selectedNode.id === node.id) {
                        showSelectedNodeInfo(node);
                    }
                }
                restoreContent();
            }
            
            // 恢复内容显示
            function restoreContent() {
                updateNodeDisplay(node);
            }
            
            // 监听事件
            textarea.addEventListener('blur', saveEdit);
            textarea.addEventListener('keydown', function(e) {
                e.stopPropagation();
                if (e.key === 'Enter' && e.ctrlKey) {
                    saveEdit();
                } else if (e.key === 'Escape') {
                    restoreContent();
                }
            });
        }
        

        // 选择节点
        function selectNode(node) {
            // 清除其他选择
            document.querySelectorAll('.node').forEach(el => {
                el.classList.remove('selected');
            });
            
            // 选择当前节点
            document.getElementById(node.id).classList.add('selected');
            selectedNode = node;
            
            showSelectedNodeInfo(node);
            console.log('选择了节点:', node.name);
        }

        // 使节点可拖拽
        function makeNodeDraggable(element, node) {
            let isDragging = false;
            let startX, startY, startNodeX, startNodeY;

            element.addEventListener('mousedown', function(e) {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startNodeX = node.x;
                startNodeY = node.y;
                
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            });

            function handleMouseMove(e) {
                if (!isDragging) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                node.x = Math.max(0, startNodeX + deltaX);
                node.y = Math.max(0, startNodeY + deltaY);
                
                updateNodePosition(node);
            }

            function handleMouseUp() {
                isDragging = false;
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            }
        }

        // 更新节点位置
        function updateNodePosition(node) {
            const element = document.getElementById(node.id);
            if (element) {
                element.style.left = `${node.x}px`;
                element.style.top = `${node.y}px`;
            }
        }

        // 转换节点为路径格式
        function convertNodesToPaths() {
            if (nodes.length === 0) return [];
            
            return [{
                id: 'path_1',
                steps: nodes.map(node => ({
                    type: node.type,
                    content: node.name
                })),
                keywords: [document.getElementById('diseaseName').value.trim()],
                created_by: currentUser?.name || '匿名用户'
            }];
        }

        // 更新画布状态
        function updateCanvas() {
            const canvas = document.getElementById('canvas');
            const emptyHint = document.getElementById('emptyHint');
            
            if (nodes.length === 0 && !emptyHint) {
                canvas.innerHTML = `
                    <div class="empty-canvas" id="emptyHint">
                        <div style="font-size: 48px; margin-bottom: 20px;">🌳</div>
                        <h3>开始构建您的决策树</h3>
                        <p style="margin: 10px 0;">输入疾病名称，然后点击"AI生成决策树"</p>
                        <p style="color: #9ca3af; font-size: 12px;">或点击"标准路径"快速开始</p>
                    </div>
                `;
            }
        }

        // 显示加载状态
        function showLoading(message) {
            const loading = document.getElementById('loading');
            const loadingText = document.getElementById('loadingText');
            
            loadingText.textContent = message;
            loading.style.display = 'flex';
        }

        // 隐藏加载状态
        function hideLoading() {
            const loading = document.getElementById('loading');
            loading.style.display = 'none';
        }

        // 显示结果
        function showResult(title, message, type) {
            const resultsDiv = document.getElementById('analysisResults');
            
            const typeColors = {
                success: '#22c55e',
                error: '#ef4444',
                warning: '#f59e0b',
                info: '#3b82f6'
            };
            
            const color = typeColors[type] || typeColors.info;
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = `
                <div class="result-title" style="color: ${color};">${title}</div>
                <div style="font-size: 13px; color: #374151;">${message}</div>
            `;
            
            resultsDiv.appendChild(resultElement);
            
            // 5秒后自动移除成功消息
            if (type === 'success') {
                setTimeout(() => {
                    resultElement.remove();
                }, 5000);
            }
        }

        // 显示分析结果
        function showAnalysisResult(analysisHtml) {
            // 清除之前的结果，避免重复
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = `
                <div class="result-title">🧠 中医理论分析结果</div>
                <div style="font-size: 13px;">${analysisHtml}</div>
            `;
            
            resultsDiv.appendChild(resultElement);
        }

        // 显示遗漏逻辑结果
        function showMissingLogicResult(data) {
            // 清除之前的结果，避免重复
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            let html = '<div class="result-title">💡 遗漏逻辑检测结果</div>';
            
            if (data.missing_analyses && data.missing_analyses.length > 0) {
                data.missing_analyses.forEach(analysis => {
                    html += `<div style="margin: 15px 0;"><strong>${analysis.category}:</strong><br>`;
                    analysis.items.forEach(item => {
                        html += `
                            <div class="suggestion-item" onclick="addSuggestionToTree('${item.suggested_addition.step_type}', '${item.content}', '${item.description}')">
                                <div class="suggestion-content">${item.content}</div>
                                <div class="suggestion-desc">${item.description}</div>
                            </div>
                        `;
                    });
                    html += `</div>`;
                });
            } else {
                html += '<div style="color: #22c55e;">✅ 当前决策树逻辑完整，未发现明显遗漏</div>';
            }
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = html;
            
            resultsDiv.appendChild(resultElement);
        }

        // 清除结果
        function clearResults() {
            const resultsDiv = document.getElementById('analysisResults');
            resultsDiv.innerHTML = '';
        }

        // 画布点击事件
        document.addEventListener('click', function(e) {
            if (e.target.id === 'canvas') {
                // 清除选择
                document.querySelectorAll('.node').forEach(el => {
                    el.classList.remove('selected');
                });
                selectedNode = null;
            }
        });

        // 绘制连接线
        function drawConnections() {
            const svg = document.getElementById('branchSvg');
            
            // 清除现有连接线
            const existingPaths = svg.querySelectorAll('.branch-line, .branch-path');
            existingPaths.forEach(path => path.remove());
            
            connections.forEach(conn => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);
                
                if (fromNode && toNode) {
                    const fromElement = document.getElementById(fromNode.id);
                    const toElement = document.getElementById(toNode.id);
                    
                    if (fromElement && toElement) {
                        const fromRect = fromElement.getBoundingClientRect();
                        const toRect = toElement.getBoundingClientRect();
                        const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                        
                        // 计算连接点位置
                        const x1 = fromRect.left - canvasRect.left + fromRect.width;
                        const y1 = fromRect.top - canvasRect.top + fromRect.height / 2;
                        const x2 = toRect.left - canvasRect.left;
                        const y2 = toRect.top - canvasRect.top + toRect.height / 2;
                        
                        // 使用贝塞尔曲线创建平滑连接
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const midX = (x1 + x2) / 2;
                        
                        // 创建平滑的曲线路径
                        const d = `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`;
                        
                        path.setAttribute('d', d);
                        path.setAttribute('class', 'branch-path');
                        path.setAttribute('fill', 'none');
                        path.setAttribute('stroke', '#3b82f6');
                        path.setAttribute('stroke-width', '2');
                        path.setAttribute('marker-end', 'url(#arrowhead)');
                        
                        // 添加连接标签（如果需要）
                        if (conn.label) {
                            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            text.setAttribute('x', midX);
                            text.setAttribute('y', (y1 + y2) / 2 - 10);
                            text.setAttribute('text-anchor', 'middle');
                            text.setAttribute('font-size', '12');
                            text.setAttribute('fill', '#6b7280');
                            text.textContent = conn.label;
                            svg.appendChild(text);
                        }
                        
                        svg.appendChild(path);
                    }
                }
            });
        }

        // 显示选中节点信息
        function showSelectedNodeInfo(node) {
            const infoDiv = document.getElementById('selectedNodeInfo');
            const contentDiv = document.getElementById('nodeInfoContent');
            
            contentDiv.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 8px;">${node.name}</div>
                <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">类型: ${getNodeTypeText(node.type)}</div>
                <div style="font-size: 12px; color: #374151;">${node.description}</div>
                ${selectedNode ? '<div style="margin-top: 10px; font-size: 11px; color: #059669;">💡 点击遗漏逻辑检测结果中的建议可添加到此节点</div>' : ''}
            `;
            
            infoDiv.style.display = 'block';
        }

        // 隐藏选中节点信息
        function hideSelectedNodeInfo() {
            const infoDiv = document.getElementById('selectedNodeInfo');
            infoDiv.style.display = 'none';
        }

        // 获取节点类型文本
        function getNodeTypeText(type) {
            const typeMap = {
                'symptom': '症状',
                'condition': '判断条件',
                'diagnosis': '诊断',
                'treatment': '治疗',
                'formula': '方剂'
            };
            return typeMap[type] || type;
        }

        // 添加建议到决策树 (支持异步数据库查询)
        async function addSuggestionToTree(nodeType, nodeName, description) {
            if (!selectedNode) {
                alert('请先选择一个节点作为添加位置');
                return;
            }
            
            // 智能症状合并：检查是否应该合并到现有症状群
            if (nodeType === 'symptom') {
                console.log(`开始智能症状分析: ${nodeName}`);
                const mergeTarget = await findSymptomMergeTarget(nodeName);
                if (mergeTarget) {
                    // 给用户一个确认提示
                    const isSelectedNode = mergeTarget === selectedNode;
                    const targetDescription = isSelectedNode ? 
                        `当前选中的"${mergeTarget.name}"` : 
                        `现有的"${mergeTarget.name}"`;
                    
                    console.log(`准备合并症状"${nodeName}"到${targetDescription}节点`);
                    mergeSymptomToNode(mergeTarget, nodeName, description);
                    return;
                }
            }
            
            // 如果不需要合并，创建新的独立节点
            const newX = selectedNode.x + 250;
            const newY = selectedNode.y + (Math.random() - 0.5) * 100; // 稍微随机偏移
            
            const newNode = {
                id: `suggested_${nodeCounter++}`,
                type: nodeType,
                name: nodeName,
                description: description,
                x: newX,
                y: newY
            };
            
            nodes.push(newNode);
            renderNode(newNode);
            
            // 创建连接
            connections.push({
                from: selectedNode.id,
                to: newNode.id
            });
            
            drawConnections();
            updateCanvas();
            
            // 显示成功消息
            showResult('成功', `✅ 已添加"${nodeName}"到决策树`, 'success');
        }

        // 智能症状合并：查找应该合并的目标节点 (数据库版本)
        async function findSymptomMergeTarget(newSymptom) {
            console.log(`\n=== 智能症状合并分析 ===`);
            console.log(`新症状: ${newSymptom}`);
            console.log(`当前选中节点:`, selectedNode);
            console.log(`当前选中节点的相关症状:`, selectedNode?.relatedSymptoms);
            
            // 第一优先级：如果当前选中的节点是症状类型，优先检查数据库关系
            if (selectedNode && selectedNode.type === 'symptom') {
                console.log(`检查选中节点与新症状的数据库关系...`);
                
                try {
                    // 调用症状关系数据库API
                    const response = await fetch(`/api/symptom/quick_analyze/${encodeURIComponent(selectedNode.name)}`);
                    const data = await response.json();
                    
                    if (data.success) {
                        const allRelatedSymptoms = [
                            ...data.data.related_symptoms,
                            ...data.data.accompanying_symptoms
                        ];
                        
                        console.log(`数据库查询成功，找到相关症状:`, allRelatedSymptoms);
                        
                        if (allRelatedSymptoms.includes(newSymptom)) {
                            console.log(`✅ 数据库确认关系，优先合并到选中节点: ${newSymptom} -> ${selectedNode.name}`);
                            return selectedNode;
                        }
                        
                        // 检查模糊匹配
                        const fuzzyMatch = allRelatedSymptoms.find(symptom => 
                            symptom.includes(newSymptom) || newSymptom.includes(symptom)
                        );
                        if (fuzzyMatch) {
                            console.log(`✅ 数据库模糊匹配成功: ${newSymptom} ≈ ${fuzzyMatch} -> ${selectedNode.name}`);
                            return selectedNode;
                        }
                    }
                } catch (error) {
                    console.warn(`数据库查询失败，回退到本地逻辑:`, error);
                }
                
                // 回退到原有的本地关系检查
                if (isSymptomRelated(selectedNode.name, newSymptom)) {
                    console.log(`✅ 本地关系检查通过，合并到选中节点: ${newSymptom} -> ${selectedNode.name}`);
                    return selectedNode;
                }
                
                console.log(`❌ 选中节点与新症状不相关`);
            }
            
            // 第二优先级：查找其他现有症状节点的数据库关系
            console.log(`检查其他症状节点的数据库关系...`);
            const existingSymptomNodes = nodes.filter(node => 
                node.type === 'symptom' && node !== selectedNode
            );
            
            for (const node of existingSymptomNodes) {
                try {
                    const response = await fetch(`/api/symptom/quick_analyze/${encodeURIComponent(node.name)}`);
                    const data = await response.json();
                    
                    if (data.success) {
                        const allRelatedSymptoms = [
                            ...data.data.related_symptoms,
                            ...data.data.accompanying_symptoms
                        ];
                        
                        if (allRelatedSymptoms.includes(newSymptom)) {
                            console.log(`✅ 数据库找到合并目标: ${newSymptom} -> ${node.name}`);
                            return node;
                        }
                    }
                } catch (error) {
                    console.warn(`节点 ${node.name} 数据库查询失败:`, error);
                    // 继续下一个节点
                }
                
                // 本地关系检查作为后备
                if (isSymptomRelated(node.name, newSymptom)) {
                    console.log(`✅ 本地关系找到合并目标: ${newSymptom} -> ${node.name}`);
                    return node;
                }
            }
            
            console.log(`❌ 未找到任何合并目标，将创建新节点: ${newSymptom}`);
            return null; // 没找到合并目标，需要创建新节点
        }

        // 判断两个症状是否相关
        function isSymptomRelated(existingSymptom, newSymptom) {
            console.log(`  检查症状关联性: "${existingSymptom}" vs "${newSymptom}"`);
            
            const relationshipMap = {
                '失眠': ['早醒', '多梦', '入睡困难', '睡眠浅', '易惊醒', '夜醒', '心烦', '健忘', '头晕', '疲乏', '精神不振'],
                '头痛': ['头胀', '头晕', '偏头痛', '太阳穴痛', '后脑痛', '颈项强直', '恶心'],
                '胃痛': ['胃胀', '胃酸', '反酸', '嗳气', '胃脘痛', '胃部不适', '食欲不振', '恶心', '呕吐'],
                '便秘': ['大便干燥', '排便困难', '大便干结', '便干如栗', '腹胀', '口干'],
                '腹泻': ['便溏', '泄泻', '水泻', '大便稀薄', '腹痛', '肠鸣', '里急后重'],
                '咳嗽': ['咳痰', '干咳', '咳喘', '痰多', '喉痒', '胸闷', '气短']
            };
            
            // 检查双向关系
            for (const [mainSymptom, relatedList] of Object.entries(relationshipMap)) {
                const condition1 = existingSymptom.includes(mainSymptom) && relatedList.includes(newSymptom);
                const condition2 = newSymptom.includes(mainSymptom) && relatedList.includes(existingSymptom);
                
                if (condition1 || condition2) {
                    console.log(`    ✅ 找到关联: ${mainSymptom} -> [${relatedList.join(', ')}]`);
                    console.log(`    条件1 (${existingSymptom} 包含 ${mainSymptom} 且 ${newSymptom} 在列表中): ${condition1}`);
                    console.log(`    条件2 (${newSymptom} 包含 ${mainSymptom} 且 ${existingSymptom} 在列表中): ${condition2}`);
                    return true;
                }
            }
            
            console.log(`    ❌ 未找到关联关系`);
            return false;
        }

        // 将症状合并到现有节点
        function mergeSymptomToNode(targetNode, newSymptom, description) {
            console.log(`开始合并症状: ${newSymptom} -> ${targetNode.name}`);
            
            // 更新节点内容，将新症状添加到描述中
            if (!targetNode.relatedSymptoms) {
                targetNode.relatedSymptoms = [];
            }
            
            // 避免重复添加
            if (!targetNode.relatedSymptoms.includes(newSymptom)) {
                targetNode.relatedSymptoms.push(newSymptom);
                
                console.log(`症状合并成功，当前相关症状:`, targetNode.relatedSymptoms);
                
                // 更新节点显示
                updateNodeDisplay(targetNode);
                
                // 显示合并成功消息，区分是否为选中节点
                const isSelectedNode = targetNode === selectedNode;
                const message = isSelectedNode ? 
                    `✅ 已将"${newSymptom}"合并到您选中的"${targetNode.name}"症状群` :
                    `✅ 已将"${newSymptom}"合并到相关的"${targetNode.name}"症状群`;
                showResult('成功', message, 'success');
                
                console.log(`节点显示更新完成，目标节点:`, targetNode);
            } else {
                showResult('提示', `"${newSymptom}"已存在于"${targetNode.name}"症状群中`, 'info');
            }
        }

        // 更新节点显示以显示相关症状
        function updateNodeDisplay(node) {
            const nodeElement = document.getElementById(node.id);
            if (!nodeElement) return;
            
            const contentDiv = nodeElement.querySelector('.node-content');
            if (!contentDiv) return;
            
            // 使用与renderNode相同的逻辑
            let nodeContent = node.description || '';
            if (node.relatedSymptoms && node.relatedSymptoms.length > 0) {
                nodeContent = `${nodeContent}
                    <div class="related-symptoms">
                        <div class="symptoms-label">相关症状:</div>
                        <div class="symptoms-list">${node.relatedSymptoms.join(', ')}</div>
                    </div>`;
            }
            
            contentDiv.innerHTML = nodeContent;
            
            // 关键修复：确保传递的是nodes数组中的实际节点对象
            const actualNode = nodes.find(n => n.id === node.id);
            if (actualNode) {
                ensureNodeEditability(nodeElement, actualNode);
            } else {
                // 作为后备，使用传入的node对象
                ensureNodeEditability(nodeElement, node);
            }
        }
        
        // 确保节点具有编辑功能（防御性编程）
        function ensureNodeEditability(nodeElement, node) {
            // 移除旧的双击事件监听器（如果存在）
            const existingHandler = nodeElement._editHandler;
            if (existingHandler) {
                nodeElement.removeEventListener('dblclick', existingHandler);
            }
            
            // 创建新的事件处理函数
            const newHandler = function(e) {
                e.stopPropagation();
                e.preventDefault();
                // 直接查找最新的节点数据
                const currentNode = nodes.find(n => n.id === node.id) || node;
                editNodeContent(currentNode);
            };
            
            // 保存事件处理器引用以便后续移除
            nodeElement._editHandler = newHandler;
            
            // 添加双击编辑功能
            nodeElement.addEventListener('dblclick', newHandler);
            
            // 标记为已绑定编辑事件
            nodeElement.setAttribute('data-editable', 'true');
        }

        // 更新节点拖拽后重绘连接线
        function updateNodePosition(node) {
            const element = document.getElementById(node.id);
            if (element) {
                element.style.left = `${node.x}px`;
                element.style.top = `${node.y}px`;
                
                // 重绘连接线
                setTimeout(drawConnections, 10);
            }
        }

        // 删除节点
        function deleteNodeById(nodeId) {
            if (confirm('确定要删除这个节点吗？')) {
                // 从数组中移除节点
                nodes = nodes.filter(node => node.id !== nodeId);
                
                // 移除相关连接
                connections = connections.filter(conn => 
                    conn.from !== nodeId && conn.to !== nodeId
                );
                
                // 从DOM中移除节点
                const element = document.getElementById(nodeId);
                if (element) {
                    element.remove();
                }
                
                // 如果删除的是选中节点，清除选择
                if (selectedNode && selectedNode.id === nodeId) {
                    selectedNode = null;
                    hideSelectedNodeInfo();
                }
                
                // 重绘连接线
                drawConnections();
                updateCanvas();
                
                showResult('成功', '✅ 节点已删除', 'success');
            }
        }
        
        // 添加分支节点（支持多分支诊断）
        function addBranchNode(parentNode) {
            const nodeType = getNextNodeType(parentNode.type);
            const newNode = {
                id: `branch_${nodeCounter++}`,
                type: nodeType,
                name: getDefaultNodeName(nodeType),
                description: '',
                x: parentNode.x + 200,
                y: parentNode.y + 150
            };
            
            nodes.push(newNode);
            renderNode(newNode);
            
            // 创建连接
            connections.push({
                from: parentNode.id,
                to: newNode.id
            });
            
            drawConnections();
            updateCanvas();
            
            // 自动选中新节点以便编辑
            selectNode(newNode);
            editNodeContent(newNode);
        }
        
        // 添加子节点（顺序流程）
        function addChildNode(parentNode) {
            const nodeType = getNextNodeType(parentNode.type);
            const newNode = {
                id: `child_${nodeCounter++}`,
                type: nodeType,
                name: getDefaultNodeName(nodeType),
                description: '',
                x: parentNode.x + 250,
                y: parentNode.y
            };
            
            nodes.push(newNode);
            renderNode(newNode);
            
            // 创建连接
            connections.push({
                from: parentNode.id,
                to: newNode.id
            });
            
            drawConnections();
            updateCanvas();
            
            // 自动选中新节点以便编辑
            selectNode(newNode);
            editNodeContent(newNode);
        }
        
        // 添加证候分型（支持多种证型）
        function addSyndromeTypes(syndromeNode) {
            const syndromeTypes = [
                { name: '证型1', desc: '请编辑证型名称和描述' },
                { name: '证型2', desc: '请编辑证型名称和描述' }
            ];
            
            syndromeTypes.forEach((type, index) => {
                const newNode = {
                    id: `syndrome_type_${nodeCounter++}`,
                    type: 'syndrome',
                    name: type.name,
                    description: type.desc,
                    x: syndromeNode.x + 200,
                    y: syndromeNode.y + (index - 0.5) * 120
                };
                
                nodes.push(newNode);
                renderNode(newNode);
                
                connections.push({
                    from: syndromeNode.id,
                    to: newNode.id
                });
            });
            
            drawConnections();
            updateCanvas();
            showResult('成功', '✅ 已添加证候分型模板，请编辑具体内容', 'success');
        }
        
        // 编辑节点（增强版）
        function editNode(node) {
            // 创建编辑对话框
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.2);
                z-index: 10000;
                width: 400px;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-bottom: 15px;">编辑节点</h3>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px;">节点名称:</label>
                    <input type="text" id="editNodeName" value="${node.name}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px;">节点类型:</label>
                    <select id="editNodeType" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <option value="disease" ${node.type === 'disease' ? 'selected' : ''}>病种</option>
                        <option value="four_diagnosis" ${node.type === 'four_diagnosis' ? 'selected' : ''}>四诊信息</option>
                        <option value="symptom" ${node.type === 'symptom' ? 'selected' : ''}>主要症状</option>
                        <option value="pathogenesis" ${node.type === 'pathogenesis' ? 'selected' : ''}>病因病机</option>
                        <option value="syndrome" ${node.type === 'syndrome' ? 'selected' : ''}>证候判断</option>
                        <option value="principle" ${node.type === 'principle' ? 'selected' : ''}>治则治法</option>
                        <option value="prescription" ${node.type === 'prescription' ? 'selected' : ''}>方剂处方</option>
                        <option value="modification" ${node.type === 'modification' ? 'selected' : ''}>随症加减</option>
                        <option value="prognosis" ${node.type === 'prognosis' ? 'selected' : ''}>预后调理</option>
                    </select>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px;">详细描述:</label>
                    <textarea id="editNodeDesc" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; min-height: 80px;">${node.description || ''}</textarea>
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="this.parentElement.parentElement.remove()" style="padding: 8px 16px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">取消</button>
                    <button id="saveNodeEdit" style="padding: 8px 16px; border: none; background: #3b82f6; color: white; border-radius: 4px; cursor: pointer;">保存</button>
                </div>
            `;
            
            document.body.appendChild(dialog);
            
            // 保存编辑
            document.getElementById('saveNodeEdit').onclick = function() {
                node.name = document.getElementById('editNodeName').value;
                node.type = document.getElementById('editNodeType').value;
                node.description = document.getElementById('editNodeDesc').value;
                
                // 更新显示
                const nodeElement = document.getElementById(node.id);
                nodeElement.className = `node ${node.type}`;
                updateNodeDisplay(node);
                
                dialog.remove();
                showResult('成功', '✅ 节点已更新', 'success');
            };
        }
        
        // 获取下一个节点的默认类型
        function getNextNodeType(currentType) {
            const typeFlow = {
                'disease': 'four_diagnosis',
                'four_diagnosis': 'symptom',
                'symptom': 'pathogenesis',
                'pathogenesis': 'syndrome',
                'syndrome': 'principle',
                'principle': 'prescription',
                'prescription': 'modification',
                'modification': 'prognosis'
            };
            return typeFlow[currentType] || 'symptom';
        }
        
        // 获取节点默认名称
        function getDefaultNodeName(nodeType) {
            const defaultNames = {
                'disease': '病种名称',
                'four_diagnosis': '四诊信息',
                'symptom': '主要症状',
                'pathogenesis': '病因病机',
                'syndrome': '证候类型',
                'principle': '治则治法',
                'prescription': '方剂名称',
                'modification': '加减方案',
                'prognosis': '预后建议'
            };
            return defaultNames[nodeType] || '新节点';
        }

        // 显示右键菜单
        function showContextMenu(e, node) {
            hideContextMenu();
            
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.id = 'contextMenu';
            menu.style.left = `${e.clientX}px`;
            menu.style.top = `${e.clientY}px`;
            
            const menuItems = [
                { text: '🔍 分析此节点', action: () => analyzeSelectedNode(node) },
                { text: '📝 编辑节点', action: () => editNode(node) },
                { text: '➕ 添加子节点', action: () => addChildNode(node) },
                { text: '🌿 添加分支', action: () => addBranchNode(node) }
            ];
            
            if (node.type === 'prescription') {
                menuItems.push({ text: '💊 AI方剂分析', action: () => analyzeFormulaNode(node) });
            }
            
            if (node.type === 'syndrome') {
                menuItems.push({ text: '📋 添加证候分型', action: () => addSyndromeTypes(node) });
            }
            
            menuItems.push({ text: '🗑️ 删除节点', action: () => deleteNodeById(node.id), danger: true });
            
            menuItems.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.className = `context-menu-item ${item.danger ? 'danger' : ''}`;
                menuItem.innerHTML = item.text;
                menuItem.onclick = () => {
                    item.action();
                    hideContextMenu();
                };
                menu.appendChild(menuItem);
            });
            
            document.body.appendChild(menu);
        }

        // 隐藏右键菜单
        function hideContextMenu() {
            const menu = document.getElementById('contextMenu');
            if (menu) {
                menu.remove();
            }
        }

        // 症状遗漏检测
        async function detectMissingSymptoms() {
            console.log('症状遗漏检测被调用');
            
            // 直接使用getCurrentDiseaseName()，不声明局部变量
            if (!getCurrentDiseaseName()) {
                alert('请先输入疾病名称');
                return;
            }

            // 收集现有症状节点
            const symptomNodes = nodes.filter(node => node.type === 'symptom');
            const existingSymptoms = symptomNodes.map(node => node.name);
            
            showLoading('正在检测症状遗漏...');

            try {
                // 使用现有的API，但专注于症状检测
                const response = await fetch('/api/detect_missing_logic', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        disease_name: getCurrentDiseaseName(),
                        current_paths: [],
                        existing_nodes: nodes.filter(node => node.type === 'symptom')
                    })
                });

                const data = await response.json();
                
                if (data.success && data.data) {
                    hideLoading();
                    showSymptomDetectionResult(data.data, existingSymptoms);
                } else {
                    throw new Error(data.message || '检测失败');
                }
            } catch (error) {
                console.error('症状遗漏检测失败:', error);
                hideLoading();
                showResult('错误', `❌ 检测失败: ${error.message}`, 'error');
            }
        }

        // 显示症状检测结果
        function showSymptomDetectionResult(data, existingSymptoms) {
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            // 生成常见症状建议
            // 直接使用getCurrentDiseaseName()，不声明局部变量
            const commonSymptoms = getCommonSymptomsForDisease(getCurrentDiseaseName());
            const missingSymptoms = commonSymptoms.filter(symptom => 
                !existingSymptoms.some(existing => existing.includes(symptom))
            );
            
            let html = '<div class="result-title">🔍 症状遗漏检测结果</div>';
            
            if (missingSymptoms.length > 0) {
                html += '<div style="margin: 15px 0;"><strong>建议补充的症状:</strong><br>';
                missingSymptoms.forEach(symptom => {
                    html += `
                        <div class="suggestion-item" onclick="addSuggestionToTree('symptom', '${symptom}', '${getCurrentDiseaseName()}的常见症状')">
                            <div class="suggestion-content">${symptom}</div>
                            <div class="suggestion-desc">${getCurrentDiseaseName()}的常见症状表现</div>
                        </div>
                    `;
                });
                html += '</div>';
            } else {
                html += '<div style="color: #22c55e;">✅ 症状覆盖较为完整</div>';
            }
            
            // 添加现有症状分析
            if (existingSymptoms.length > 0) {
                html += '<div style="margin: 15px 0;"><strong>现有症状:</strong><br>';
                html += `<div style="font-size: 12px; color: #6b7280;">${existingSymptoms.join('、')}</div></div>`;
            }
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = html;
            
            resultsDiv.appendChild(resultElement);
        }

        // 获取疾病常见症状
        function getCommonSymptomsForDisease(diseaseName) {
            const symptomDatabase = {
                '失眠': ['难以入睡', '早醒', '多梦', '睡眠浅', '心烦', '健忘', '头晕', '疲乏'],
                '胃痛': ['胃脘疼痛', '胃胀', '反酸', '嗳气', '恶心', '食欲不振', '腹胀', '便秘'],
                '头痛': ['头部疼痛', '眩晕', '恶心呕吐', '畏光', '颈项强直', '耳鸣', '视物模糊'],
                '咳嗽': ['干咳', '咳痰', '气短', '胸闷', '咽痒', '声嘶', '发热', '乏力'],
                '腹泻': ['大便稀溏', '腹痛', '腹胀', '肠鸣', '里急后重', '发热', '恶心', '食欲减退']
            };
            
            return symptomDatabase[diseaseName] || ['相关症状1', '相关症状2', '相关症状3'];
        }

        // 方剂AI分析
        async function analyzeFormula() {
            console.log('方剂AI分析被调用');
            
            const formulaNodes = nodes.filter(node => node.type === 'formula');
            if (formulaNodes.length === 0) {
                alert('请先添加方剂节点');
                return;
            }

            // 直接使用getCurrentDiseaseName()，不声明局部变量
            if (!getCurrentDiseaseName()) {
                alert('请先输入疾病名称');
                return;
            }

            showLoading('正在进行AI方剂分析...');

            try {
                const response = await fetch('/api/analyze_formula_composition', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        disease_name: getCurrentDiseaseName(),
                        formulas: formulaNodes.map(node => ({
                            name: node.name,
                            description: node.description
                        })),
                        patient_symptoms: nodes.filter(n => n.type === 'symptom').map(n => n.name)
                    })
                });

                const data = await response.json();
                
                if (data.success) {
                    hideLoading();
                    showFormulaAnalysisResult(data.data || {});
                } else {
                    // 如果API不存在，使用本地分析
                    hideLoading();
                    showLocalFormulaAnalysis(formulaNodes, getCurrentDiseaseName());
                }
            } catch (error) {
                console.error('方剂分析失败:', error);
                hideLoading();
                // 使用本地分析作为后备
                showLocalFormulaAnalysis(formulaNodes, getCurrentDiseaseName());
            }
        }

        // 本地方剂分析
        function showLocalFormulaAnalysis(formulaNodes, diseaseName) {
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            let html = '<div class="result-title">💊 方剂AI分析结果</div>';
            
            formulaNodes.forEach(formulaNode => {
                const analysis = analyzeFormulaLocally(formulaNode.name, getCurrentDiseaseName());
                html += `
                    <div class="formula-analysis-panel">
                        <div style="font-weight: 600; margin-bottom: 10px;">📋 ${formulaNode.name}</div>
                        <div style="margin-bottom: 10px;">
                            <strong>建议药材组成:</strong><br>
                            <div style="margin-top: 5px;">
                                ${analysis.herbs.map(herb => 
                                    `<span class="herb-item" onclick="addHerbToFormula('${formulaNode.id}', '${herb.name}', '${herb.dosage}')" title="点击添加到方剂">${herb.name} ${herb.dosage}</span>`
                                ).join('')}
                            </div>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <strong>加减建议:</strong><br>
                            <div style="font-size: 12px; color: #059669;">${analysis.modifications}</div>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <strong>功效:</strong><br>
                            <div style="font-size: 12px; color: #6b7280;">${analysis.effects}</div>
                        </div>
                        <button class="apply-formula-btn" onclick="applyFullFormulaToNode('${formulaNode.id}', '${JSON.stringify(analysis.herbs).replace(/"/g, "&quot;")}')">
                            ✨ 应用完整方剂
                        </button>
                    </div>
                `;
            });
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = html;
            
            resultsDiv.appendChild(resultElement);
        }

        // 完整的方剂数据库，包含具体药材信息
        function analyzeFormulaLocally(formulaName, diseaseName) {
            const formulaDatabase = {
                '逍遥散': {
                    herbs: [
                        { name: '柴胡', dosage: '10g' },
                        { name: '当归', dosage: '10g' },
                        { name: '白芍', dosage: '10g' },
                        { name: '白术', dosage: '10g' },
                        { name: '茯苓', dosage: '15g' },
                        { name: '炙甘草', dosage: '6g' },
                        { name: '薄荷', dosage: '6g' },
                        { name: '生姜', dosage: '3片' }
                    ],
                    effects: '疏肝解郁，健脾养血',
                    modifications: '肝郁重者加香附12g，郁金10g；脾虚重者加党参12g'
                },
                '甘麦大枣汤': {
                    herbs: [
                        { name: '淮小麦', dosage: '30g' },
                        { name: '炙甘草', dosage: '10g' },
                        { name: '大枣', dosage: '10枚' }
                    ],
                    effects: '养心安神，缓急止痛',
                    modifications: '心神不安重者加酸枣仁15g，远志10g'
                },
                '逍遥散合甘麦大枣汤': {
                    herbs: [
                        { name: '柴胡', dosage: '10g' },
                        { name: '当归', dosage: '10g' },
                        { name: '白芍', dosage: '10g' },
                        { name: '白术', dosage: '10g' },
                        { name: '茯苓', dosage: '15g' },
                        { name: '炙甘草', dosage: '10g' },
                        { name: '薄荷', dosage: '6g' },
                        { name: '生姜', dosage: '3片' },
                        { name: '淮小麦', dosage: '30g' },
                        { name: '大枣', dosage: '10枚' }
                    ],
                    effects: '疏肝解郁，健脾养血，养心安神',
                    modifications: '情志抑郁重者加合欢皮12g；心神不安重者加酸枣仁15g，龙骨20g'
                },
                '黄连阿胶汤': {
                    herbs: [
                        { name: '黄连', dosage: '6g' },
                        { name: '阿胶', dosage: '9g' },
                        { name: '黄芩', dosage: '6g' },
                        { name: '白芍', dosage: '9g' },
                        { name: '鸡子黄', dosage: '2枚' }
                    ],
                    effects: '清心火，养心阴，安神志',
                    modifications: '心火偏盛加栀子6g；阴虚明显加麦冬12g'
                },
                '归脾汤': {
                    herbs: [
                        { name: '党参', dosage: '12g' },
                        { name: '白术', dosage: '10g' },
                        { name: '茯苓', dosage: '12g' },
                        { name: '当归', dosage: '9g' },
                        { name: '龙眼肉', dosage: '12g' },
                        { name: '酸枣仁', dosage: '15g' },
                        { name: '木香', dosage: '6g' },
                        { name: '炙甘草', dosage: '6g' }
                    ],
                    effects: '补益心脾，养血安神',
                    modifications: '气虚明显加黄芪15g；血虚甚者加熟地12g'
                },
                '理中汤': {
                    herbs: [
                        { name: '人参', dosage: '9g' },
                        { name: '白术', dosage: '9g' },
                        { name: '干姜', dosage: '9g' },
                        { name: '炙甘草', dosage: '6g' }
                    ],
                    effects: '温中散寒，补气健脾',
                    modifications: '寒盛加附子6g；气虚甚加黄芪15g'
                }
            };
            
            return formulaDatabase[formulaName] || {
                herbs: [
                    { name: '主药', dosage: '10-15g' },
                    { name: '辅药', dosage: '6-12g' },
                    { name: '佐药', dosage: '3-9g' }
                ],
                effects: `治疗${getCurrentDiseaseName()}的有效方剂`,
                modifications: '请根据具体症状进行加减'
            };
        }

        // 显示方剂分析结果
        function showFormulaAnalysisResult(data) {
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = `
                <div class="result-title">💊 方剂AI分析结果</div>
                <div style="font-size: 13px;">${data.analysis || '分析完成，请查看具体建议'}</div>
            `;
            
            resultsDiv.appendChild(resultElement);
        }

        // 分析选中节点
        function analyzeSelectedNode(node) {
            if (node.type === 'formula') {
                analyzeFormulaNode(node);
            } else {
                showResult('提示', `正在分析${getNodeTypeText(node.type)}节点: ${node.name}`, 'info');
            }
        }

        // 分析方剂节点
        function analyzeFormulaNode(node) {
            const analysis = analyzeFormulaLocally(node.name, getCurrentDiseaseName());
            
            clearResults();
            const resultsDiv = document.getElementById('analysisResults');
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = `
                <div class="result-title">💊 ${node.name} 详细分析</div>
                <div class="formula-analysis-panel">
                    <div style="margin-bottom: 10px;">
                        <strong>药材组成:</strong><br>
                        <div style="font-size: 12px; margin-top: 5px;">
                            ${analysis.herbs.map(herb => `${herb.name} ${herb.dosage}`).join('、')}
                        </div>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>功效主治:</strong><br>
                        <div style="font-size: 12px; color: #6b7280;">${analysis.effects}</div>
                    </div>
                    <div>
                        <strong>加减化裁:</strong><br>
                        <div style="font-size: 12px; color: #059669;">${analysis.modifications}</div>
                    </div>
                </div>
            `;
            
            resultsDiv.appendChild(resultElement);
        }

        // 编辑节点
        function editNode(node) {
            const newName = prompt('请输入新的节点名称:', node.name);
            if (newName && newName.trim() && newName !== node.name) {
                node.name = newName.trim();
                
                const element = document.getElementById(node.id);
                const titleElement = element.querySelector('.node-title');
                if (titleElement) {
                    titleElement.textContent = node.name;
                }
                
                showResult('成功', '✅ 节点已更新', 'success');
            }
        }

        // 添加子节点
        function addChildNode(parentNode) {
            const nodeType = prompt('请输入节点类型 (symptom/condition/diagnosis/treatment/formula):', 'condition');
            if (!nodeType) return;
            
            const nodeName = prompt('请输入节点名称:', '新节点');
            if (!nodeName) return;
            
            const newNode = {
                id: `child_${nodeCounter++}`,
                type: nodeType,
                name: nodeName,
                description: `${parentNode.name}的相关节点`,
                x: parentNode.x + 250,
                y: parentNode.y + (Math.random() - 0.5) * 100
            };
            
            nodes.push(newNode);
            renderNode(newNode);
            
            connections.push({
                from: parentNode.id,
                to: newNode.id
            });
            
            drawConnections();
            showResult('成功', `✅ 已添加子节点"${nodeName}"`, 'success');
        }

        // 添加药材到方剂节点
        function addHerbToFormula(formulaNodeId, herbName, dosage) {
            const formulaNode = nodes.find(node => node.id === formulaNodeId);
            if (!formulaNode) {
                showResult('错误', '找不到方剂节点', 'error');
                return;
            }
            
            // 初始化 herbs 数组
            if (!formulaNode.herbs) {
                formulaNode.herbs = [];
            }
            
            // 检查是否已存在该药材
            const existingHerb = formulaNode.herbs.find(h => h.name === herbName);
            if (existingHerb) {
                existingHerb.dosage = dosage;
                showResult('成功', `✅ 已更新 ${herbName} 用量为 ${dosage}`, 'success');
            } else {
                formulaNode.herbs.push({ name: herbName, dosage: dosage });
                showResult('成功', `✅ 已添加 ${herbName} ${dosage} 到方剂`, 'success');
            }
            
            // 更新节点显示
            updateFormulaNodeDisplay(formulaNode);
        }

        // 应用完整方剂到节点
        function applyFullFormulaToNode(formulaNodeId, herbsJsonStr) {
            const formulaNode = nodes.find(node => node.id === formulaNodeId);
            if (!formulaNode) {
                showResult('错误', '找不到方剂节点', 'error');
                return;
            }
            
            try {
                const herbs = JSON.parse(herbsJsonStr.replace(/&quot;/g, '"'));
                formulaNode.herbs = herbs;
                
                updateFormulaNodeDisplay(formulaNode);
                showResult('成功', `✅ 已应用完整方剂到 ${formulaNode.name}，包含 ${herbs.length} 味药材`, 'success');
            } catch (error) {
                showResult('错误', '方剂数据解析失败', 'error');
            }
        }

        // 更新方剂节点显示
        function updateFormulaNodeDisplay(formulaNode) {
            const element = document.getElementById(formulaNode.id);
            if (!element) return;
            
            const contentDiv = element.querySelector('.node-content');
            if (contentDiv && formulaNode.herbs && formulaNode.herbs.length > 0) {
                const herbsList = formulaNode.herbs.map(h => `${h.name} ${h.dosage}`).join('、');
                contentDiv.innerHTML = `${formulaNode.description || ''}<br><small style="color: #059669;">药材: ${herbsList}</small>`;
            }
        }

        // 增强的证型智能识别
        async function analyzeSyndrome() {
            console.log('证型智能识别被调用');
            
            // 直接使用getCurrentDiseaseName()，不声明局部变量
            if (!getCurrentDiseaseName()) {
                alert('请先输入疾病名称');
                return;
            }
            
            // 收集所有症状（从节点和症状群）
            const symptomNodes = nodes.filter(node => node.type === 'symptom');
            const allSymptoms = symptomNodes.map(n => n.name);
            
            // 即使没有症状也进行分析（使用疾病名称）
            const symptomsForAnalysis = allSymptoms.length > 0 ? allSymptoms : [getCurrentDiseaseName()];

            // 直接使用getCurrentDiseaseName()，不声明局部变量
            if (!getCurrentDiseaseName()) {
                alert('请先输入疾病名称');
                return;
            }

            showLoading('正在进行证型智能识别...');

            try {
                    const syndromeAnalysis = analyzeSyndromeLocally(getCurrentDiseaseName(), symptomsForAnalysis || []);
                
                hideLoading();
                showSyndromeAnalysisResult(syndromeAnalysis);
                
            } catch (error) {
                console.error('证型识别失败:', error);
                hideLoading();
                showResult('错误', `❌ 识别失败: ${error.message}`, 'error');
            }
        }

        // 增强的证型分析数据库
        function analyzeSyndromeLocally(diseaseName, symptoms) {
            const syndromeDatabase = {
                '失眠': {
                    '心火旺盛证': {
                        keywords: ['心烦', '多梦', '口干', '舌红', '苔黄', '失眠', '难以入睡'],
                        description: '心火亢盛，扰乱神明',
                        treatment: '清心火，安神志',
                        formula: '黄连阿胶汤',
                        weight: 0.8
                    },
                    '心脾两虚证': {
                        keywords: ['健忘', '心悸', '面色萎黄', '舌淡', '脉弱', '失眠', '疲乏', '食欲不振'],
                        description: '心脾气血不足，神失所养',
                        treatment: '补益心脾，养血安神',
                        formula: '归脾汤',
                        weight: 0.7
                    },
                    '肝郁化火证': {
                        keywords: ['易怒', '胸胁胀满', '口苦', '脉弦', '失眠', '烦躁', '头痛'],
                        description: '肝郁化火，上扰神明',
                        treatment: '疏肝解郁，清热安神',
                        formula: '逍遥散合甘麦大枣汤',
                        weight: 0.8
                    },
                    '阴虚火旺证': {
                        keywords: ['失眠', '早醒', '五心烦热', '盗汗', '口干', '舌红少苔'],
                        description: '肾阴不足，虚火上炎',
                        treatment: '滋阴降火，养心安神',
                        formula: '黄连阿胶汤',
                        weight: 0.7
                    }
                },
                '胃痛': {
                    '脾胃虚寒证': {
                        keywords: ['喜温喜按', '面色萎白', '舌淡苔白', '脉细弱', '胃痛', '胃胀'],
                        description: '脾胃阳气不足，失于温煦',
                        treatment: '温中散寒，补气健脾',
                        formula: '理中汤',
                        weight: 0.8
                    },
                    '肝气犯胃证': {
                        keywords: ['胀痛拒按', '嗳气', '情志不遂', '脉弦', '胃痛', '反酸'],
                        description: '肝气郁结，横逆犯胃',
                        treatment: '疏肝理气，和胃止痛',
                        formula: '柴胡疏肝散',
                        weight: 0.7
                    }
                },
                // 通用症状匹配（降低阈值）
                '通用': {
                    '气血不足证': {
                        keywords: ['疲乏', '乏力', '面色萎黄', '头晕', '心悸'],
                        description: '气血亏虚，脏腑失养',
                        treatment: '益气养血',
                        formula: '八珍汤',
                        weight: 0.4
                    },
                    '痰湿内阻证': {
                        keywords: ['胸闷', '恶心', '食欲不振', '舌苔厚腻', '头重'],
                        description: '痰湿内生，阻滞气机',
                        treatment: '化痰除湿，理气和中',
                        formula: '二陈汤',
                        weight: 0.4
                    }
                }
            };

            const diseaseSymptoms = syndromeDatabase[diseaseName] || {};
            const matchedSyndromes = [];

            // 检查疾病特定证型
            Object.keys(diseaseSymptoms).forEach(syndromeName => {
                const syndrome = diseaseSymptoms[syndromeName];
                const matchCount = syndrome.keywords.filter(keyword => 
                    symptoms.some(symptom => symptom.includes(keyword) || keyword.includes(symptom))
                ).length;
                
                const baseMatchRate = matchCount / syndrome.keywords.length;
                const weightedMatchRate = baseMatchRate * (syndrome.weight || 0.5);
                
                // 降低匹配阈值到15%，让更多证型能被识别
                if (weightedMatchRate > 0.15) {
                    matchedSyndromes.push({
                        name: syndromeName,
                        matchRate: weightedMatchRate,
                        confidence: Math.min(weightedMatchRate * 1.5, 1.0),
                        ...syndrome
                    });
                }
            });
            
            // 检查通用证型（当疾病特定证型匹配度低时）
            if (matchedSyndromes.length === 0 && syndromeDatabase['通用']) {
                Object.keys(syndromeDatabase['通用']).forEach(syndromeName => {
                    const syndrome = syndromeDatabase['通用'][syndromeName];
                    const matchCount = syndrome.keywords.filter(keyword => 
                        symptoms.some(symptom => symptom.includes(keyword) || keyword.includes(symptom))
                    ).length;
                    
                    const matchRate = matchCount / syndrome.keywords.length;
                    
                    if (matchRate > 0.2) { // 通用证型阈值稍高
                        matchedSyndromes.push({
                            name: syndromeName,
                            matchRate: matchRate,
                            confidence: matchRate * 0.8, // 通用证型置信度稍低
                            isGeneric: true,
                            ...syndrome
                        });
                    }
                });
            }

            // 按匹配度排序
            matchedSyndromes.sort((a, b) => b.matchRate - a.matchRate);

            return {
                matchedSyndromes,
                recommendation: matchedSyndromes.length > 0 ? matchedSyndromes[0] : null
            };
        }

        // 显示证型分析结果
        function showSyndromeAnalysisResult(analysis) {
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            let html = '<div class="result-title">🎯 证型智能识别结果</div>';
            
            if (analysis.recommendation) {
                html += `
                    <div class="auto-analysis-panel">
                        <div style="font-weight: 600; margin-bottom: 10px; color: #d97706;">
                            🏆 推荐证型: ${analysis.recommendation.name} 
                            <span style="font-size: 12px; color: #6b7280;">(匹配度: ${Math.round(analysis.recommendation.matchRate * 100)}%)</span>
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>病机:</strong> ${analysis.recommendation.description}
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>治法:</strong> ${analysis.recommendation.treatment}
                        </div>
                        <div style="margin-bottom: 10px;">
                            <strong>推荐方剂:</strong> ${analysis.recommendation.formula}
                        </div>
                        <button class="add-pathway-btn" onclick="addSyndromeToTree('${analysis.recommendation.name}', '${analysis.recommendation.description}')">
                            ➕ 添加证型到决策树
                        </button>
                        <button class="add-pathway-btn" onclick="addTreatmentToTree('${analysis.recommendation.treatment}', '${analysis.recommendation.formula}')">
                            ➕ 添加治疗方案
                        </button>
                    </div>
                `;
            }

            if (analysis.matchedSyndromes.length > 1) {
                html += '<div style="margin-top: 15px;"><strong>其他可能证型:</strong><br>';
                analysis.matchedSyndromes.slice(1, 3).forEach(syndrome => {
                    html += `
                        <div class="suggestion-item" onclick="addSyndromeToTree('${syndrome.name}', '${syndrome.description}')">
                            <div class="suggestion-content">${syndrome.name}</div>
                            <div class="suggestion-desc">匹配度: ${Math.round(syndrome.matchRate * 100)}% - ${syndrome.description}</div>
                        </div>
                    `;
                });
                html += '</div>';
            }

            if (analysis.matchedSyndromes.length === 0) {
                // 提供更多帮助信息
                // 直接使用getCurrentDiseaseName()，不声明局部变量
                html += `
                    <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 8px; padding: 12px; color: #92400e;">
                        <div style="font-weight: 600; margin-bottom: 8px;">⚠️ 证型识别建议</div>
                        <div style="font-size: 12px; margin-bottom: 8px;">
                            当前${diseaseName}的症状信息不足，建议补充以下信息：
                        </div>
                        <div style="font-size: 11px; line-height: 1.4;">
                            • 详细描述症状特点（如痛痛性质、发作时间）<br>
                            • 添加伴随症状（如睡眠、饮食、大小便）<br>
                            • 提供舌象脉象信息<br>
                            • 记录情志因素和起病原因
                        </div>
                        <div style="margin-top: 10px;">
                            <button onclick="showSymptomGuidance('${diseaseName}')" style="
                                background: #f59e0b; color: white; border: none; border-radius: 6px; 
                                padding: 6px 12px; font-size: 11px; cursor: pointer;
                            ">
                                📝 获取症状指导
                            </button>
                        </div>
                    </div>
                `;
            }
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = html;
            
            resultsDiv.appendChild(resultElement);
        }

        // 添加证型到决策树
        function addSyndromeToTree(syndromeName, description) {
            if (!selectedNode) {
                // 自动选择最后一个condition节点或创建新位置
                const conditionNodes = nodes.filter(n => n.type === 'condition');
                if (conditionNodes.length > 0) {
                    selectedNode = conditionNodes[conditionNodes.length - 1];
                } else {
                    showResult('提示', '请先选择一个节点作为添加位置', 'info');
                    return;
                }
            }

            const newNode = {
                id: `syndrome_${nodeCounter++}`,
                type: 'diagnosis',
                name: syndromeName,
                description: description,
                x: selectedNode.x + 250,
                y: selectedNode.y
            };
            
            nodes.push(newNode);
            renderNode(newNode);
            
            connections.push({
                from: selectedNode.id,
                to: newNode.id
            });
            
            drawConnections();
            showResult('成功', `✅ 已添加证型"${syndromeName}"到决策树`, 'success');
        }

        // 添加治疗方案到决策树
        function addTreatmentToTree(treatmentMethod, formulaName) {
            const diagnosisNodes = nodes.filter(n => n.type === 'diagnosis');
            if (diagnosisNodes.length === 0) {
                showResult('提示', '请先添加诊断节点', 'info');
                return;
            }

            const lastDiagnosisNode = diagnosisNodes[diagnosisNodes.length - 1];
            
            // 添加治疗节点
            const treatmentNode = {
                id: `treatment_${nodeCounter++}`,
                type: 'treatment',
                name: '治疗方案',
                description: treatmentMethod,
                x: lastDiagnosisNode.x + 250,
                y: lastDiagnosisNode.y
            };
            
            nodes.push(treatmentNode);
            renderNode(treatmentNode);
            
            connections.push({
                from: lastDiagnosisNode.id,
                to: treatmentNode.id
            });

            // 添加方剂节点
            const formulaNode = {
                id: `formula_${nodeCounter++}`,
                type: 'formula',
                name: formulaName,
                description: '推荐方剂',
                x: treatmentNode.x + 250,
                y: treatmentNode.y
            };
            
            nodes.push(formulaNode);
            renderNode(formulaNode);
            
            connections.push({
                from: treatmentNode.id,
                to: formulaNode.id
            });
            
            drawConnections();
            showResult('成功', `✅ 已添加治疗方案和方剂到决策树`, 'success');
        }

        // 生成基础诊疗路径（无症状时）
        function generateBasicPathway(diseaseName) {
            const basicSteps = [
                {
                    type: 'inquiry',
                    title: '问诊采集',
                    content: `详细了解${diseaseName}相关症状`,
                    action: 'collect_symptoms'
                },
                {
                    type: 'examination',
                    title: '体格检查',
                    content: '望闻问切四诊合参',
                    action: 'physical_exam'
                },
                {
                    type: 'analysis',
                    title: '辨证分析',
                    content: `根据症状特点进行${diseaseName}的证型判断`,
                    action: 'syndrome_analysis'
                },
                {
                    type: 'treatment',
                    title: '治疗方案',
                    content: '制定针对性的中医治疗方案',
                    action: 'treatment_plan'
                }
            ];
            
            return {
                pathway: basicSteps,
                message: `为${diseaseName}生成的基础诊疗路径`
            };
        }
        
        // 生成通用诊疗路径（有症状但无明确证型）
        function generateGenericPathway(diseaseName, symptoms) {
            const genericSteps = [
                {
                    type: 'analysis',
                    title: '症状分析',
                    content: `当前症状: ${symptoms.join('、')}，需进一步分析辨证`,
                    action: 'symptom_analysis'
                },
                {
                    type: 'differential',
                    title: '鉴别诊断',
                    content: `排除${diseaseName}的其他可能证型`,
                    action: 'differential_diagnosis'
                },
                {
                    type: 'supplementary',
                    title: '补充检查',
                    content: '完善四诊信息，明确证型',
                    action: 'supplementary_exam'
                },
                {
                    type: 'treatment',
                    title: '分型治疗',
                    content: '根据最终证型选择合适治法',
                    action: 'targeted_treatment'
                }
            ];
            
            return {
                pathway: genericSteps,
                syndrome: null,
                message: `基于现有症状生成的${diseaseName}通用诊疗路径`
            };
        }
        
        // 增强的智能诊疗路径生成
        async function generateAutoPathway() {
            console.log('智能诊疗路径被调用');
            
            // 直接使用getCurrentDiseaseName()，不声明局部变量
            if (!getCurrentDiseaseName()) {
                alert('请先输入疾病名称');
                return;
            }
            
            showLoading('正在生成智能诊疗路径...');

            try {
                // 收集症状（从节点和症状群）
                const symptomNodes = nodes.filter(node => node.type === 'symptom');
                const allSymptoms = symptomNodes.map(n => n.name);
                
                // 基于现有症状生成完整路径
                const pathwayData = generatePathwayFromSymptoms(diseaseName, allSymptoms || []);
                
                hideLoading();
                showPathwayGenerationResult(pathwayData);
                
            } catch (error) {
                console.error('路径生成失败:', error);
                hideLoading();
                showResult('错误', `❌ 生成失败: ${error.message}`, 'error');
            }
        }

        // 增强的诊疗路径生成
        function generatePathwayFromSymptoms(diseaseName, symptoms) {
            // 先进行证型分析
            const syndromeAnalysis = analyzeSyndromeLocally(diseaseName, symptoms);
            const recommendedSyndrome = syndromeAnalysis.recommendation;
            
            // 降低阈值，即使没有明确证型也生成基础路径
            if (!recommendedSyndrome && symptoms.length === 0) {
                // 完全没有症状时的默认路径
                return generateBasicPathway(diseaseName);
            }
            
            if (!recommendedSyndrome && symptoms.length > 0) {
                // 有症状但没有匹配证型时的通用路径
                return generateGenericPathway(diseaseName, symptoms);
            }

            // 生成完整路径步骤
            const pathway = [
                {
                    type: 'analysis',
                    title: '症状分析',
                    content: `当前症状: ${symptoms.join('、')}`,
                    action: 'review_symptoms'
                },
                {
                    type: 'syndrome',
                    title: '证型诊断',
                    content: `${recommendedSyndrome.name} (匹配度: ${Math.round(recommendedSyndrome.matchRate * 100)}%)`,
                    description: recommendedSyndrome.description,
                    action: 'add_syndrome'
                },
                {
                    type: 'treatment',
                    title: '治疗原则',
                    content: recommendedSyndrome.treatment,
                    action: 'add_treatment'
                },
                {
                    type: 'formula',
                    title: '方药选择',
                    content: recommendedSyndrome.formula,
                    action: 'add_formula'
                }
            ];

            return {
                pathway: pathway,
                syndrome: recommendedSyndrome,
                message: '基于现有症状生成的智能诊疗路径'
            };
        }

        // 显示路径生成结果
        function showPathwayGenerationResult(pathwayData) {
            clearResults();
            
            const resultsDiv = document.getElementById('analysisResults');
            
            let html = '<div class="result-title">🤖 智能诊疗路径</div>';
            
            if (pathwayData.pathway.length > 0) {
                html += `<div style="margin-bottom: 15px; color: #059669; font-size: 12px;">${pathwayData.message}</div>`;
                
                pathwayData.pathway.forEach((step, index) => {
                    html += `
                        <div class="pathway-step">
                            <div style="font-weight: 600; color: #1e40af; margin-bottom: 5px;">
                                ${index + 1}. ${step.title}
                            </div>
                            <div style="font-size: 13px; margin-bottom: 8px;">${step.content}</div>
                            ${step.description ? `<div style="font-size: 11px; color: #6b7280; margin-bottom: 8px;">${step.description}</div>` : ''}
                            <button class="add-pathway-btn" onclick="executePathwayStep('${step.action}', '${step.title}', '${step.content.replace(/'/g, "\\'")}')">
                                ➕ 添加到决策树
                            </button>
                        </div>
                    `;
                });

                html += `
                    <div style="margin-top: 15px; padding: 10px; background: #f0f9ff; border-radius: 6px;">
                        <button class="apply-formula-btn" onclick="applyFullPathway('${JSON.stringify(pathwayData).replace(/"/g, "&quot;")}')">
                            🚀 应用完整路径
                        </button>
                    </div>
                `;
            } else {
                html += `<div style="color: #f59e0b;">${pathwayData.message}</div>`;
            }
            
            const resultElement = document.createElement('div');
            resultElement.className = 'result-panel';
            resultElement.innerHTML = html;
            
            resultsDiv.appendChild(resultElement);
        }

        // 执行路径步骤
        function executePathwayStep(action, title, content) {
            const lastNode = nodes.length > 0 ? nodes[nodes.length - 1] : null;
            const baseX = lastNode ? lastNode.x + 250 : 50;
            const baseY = lastNode ? lastNode.y : 100;

            let nodeType, nodeName, nodeDescription;

            switch (action) {
                case 'add_syndrome':
                    nodeType = 'diagnosis';
                    nodeName = content.split(' (')[0]; // 移除匹配度信息
                    nodeDescription = title;
                    break;
                case 'add_treatment':
                    nodeType = 'treatment';
                    nodeName = title;
                    nodeDescription = content;
                    break;
                case 'add_formula':
                    nodeType = 'formula';
                    nodeName = content;
                    nodeDescription = title;
                    break;
                default:
                    showResult('提示', `已记录: ${title}`, 'info');
                    return;
            }

            const newNode = {
                id: `pathway_${nodeCounter++}`,
                type: nodeType,
                name: nodeName,
                description: nodeDescription,
                x: baseX,
                y: baseY + (Math.random() - 0.5) * 50
            };
            
            nodes.push(newNode);
            renderNode(newNode);
            
            if (lastNode) {
                connections.push({
                    from: lastNode.id,
                    to: newNode.id
                });
                drawConnections();
            }
            
            showResult('成功', `✅ 已添加${title}到决策树`, 'success');
        }

        // 应用完整路径
        function applyFullPathway(pathwayJsonStr) {
            try {
                const pathwayData = JSON.parse(pathwayJsonStr.replace(/&quot;/g, '"'));
                
                let previousNode = nodes.length > 0 ? nodes[nodes.length - 1] : null;
                let x = previousNode ? previousNode.x + 250 : 300;
                const baseY = previousNode ? previousNode.y : 100;
                
                pathwayData.pathway.forEach((step, index) => {
                    let nodeType, nodeName, nodeDescription;

                    switch (step.action) {
                        case 'add_syndrome':
                            nodeType = 'diagnosis';
                            nodeName = step.content.split(' (')[0];
                            nodeDescription = step.description || step.title;
                            break;
                        case 'add_treatment':
                            nodeType = 'treatment';
                            nodeName = step.title;
                            nodeDescription = step.content;
                            break;
                        case 'add_formula':
                            nodeType = 'formula';
                            nodeName = step.content;
                            nodeDescription = step.title;
                            break;
                        default:
                            return;
                    }

                    const newNode = {
                        id: `full_pathway_${nodeCounter++}`,
                        type: nodeType,
                        name: nodeName,
                        description: nodeDescription,
                        x: x,
                        y: baseY + (index * 20) - 40
                    };
                    
                    nodes.push(newNode);
                    renderNode(newNode);
                    
                    if (previousNode) {
                        connections.push({
                            from: previousNode.id,
                            to: newNode.id
                        });
                    }
                    
                    previousNode = newNode;
                    x += 250;
                });
                
                drawConnections();
                showResult('成功', `✅ 已应用完整诊疗路径，包含${pathwayData.pathway.filter(s => s.action !== 'review_symptoms').length}个步骤`, 'success');
                
            } catch (error) {
                showResult('错误', '路径数据解析失败', 'error');
            }
        }

        // 显示症状指导
        function showSymptomGuidance(diseaseName) {
            const guidance = {
                '失眠': [
                    '入睡情况：难以入睡、辗转反侧、入睡时间超过30分钟',
                    '睡眠维持：早醒、多梦、睡眠浅、易惊醒',
                    '伴随症状：心烦、头晕、健忘、疲乏乏力',
                    '情志因素：焦虑、抑郁、工作压力、情绪波动',
                    '舌象脉象：舌质、舌苔、脉象（数、有力、滑涩等）'
                ],
                '胃痛': [
                    '痛痛特点：胀痛、刺痛、隐痛、续痛、阵发性痛痛',
                    '痛痛诱因：食后痛、空腹痛、情绪激动后加重',
                    '伴随症状：胃胀、反酸、嗳气、恶心呕吐',
                    '飮食情况：食欲不振、喜按喜温、喜凉拒按',
                    '大小便：大便情况、小便颜色及量'
                ]
            };
            
            const diseaseGuidance = guidance[diseaseName] || [
                '详细描述主要症状的特点和发作规律',
                '记录伴随出现的其他不适症状',
                '注意观察舌象和脉象的变化',
                '考虑疾病的起因和诱发因素'
            ];
            
            alert(`${diseaseName}症状采集指导：\n\n${diseaseGuidance.map((item, index) => `${index + 1}. ${item}`).join('\n\n')}\n\n请根据以上指导补充症状信息，提高证型识别的准确性。`);
        }
        
        // URL参数检查函数（在主初始化中调用）
        function checkURLParameters() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const presetSymptoms = urlParams.get('symptoms');
                const presetDisease = urlParams.get('disease');
                
                if (presetDisease) {
                    const diseaseInput = document.getElementById('diseaseName');
                    if (diseaseInput) {
                        diseaseInput.value = presetDisease;
                        console.log('设置预设疾病:', presetDisease);
                    }
                }
                
                if (presetSymptoms) {
                    console.log('发现预设症状:', presetSymptoms);
                    // TODO: 后续可以添加自动生成症状群功能
                }
            } catch (error) {
                console.error('URL参数检查出错:', error);
            }
        }
        
        console.log('决策树构建器加载完成');
        
        // 紧急修复：强制重新绑定主要按钮事件
        setTimeout(function() {
            console.log('强制重新绑定事件...');
            const generateBtn = document.getElementById('generateBtn');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const clearBtn = document.getElementById('clearBtn');
            const aiModeToggle = document.getElementById('aiModeToggle');
            
            if (generateBtn) {
                generateBtn.onclick = function() {
                    console.log('强制绑定的generateAITree被调用');
                    generateAITree();
                };
                console.log('generateBtn重新绑定成功');
            }
            
            if (analyzeBtn) {
                analyzeBtn.onclick = function() {
                    console.log('强制绑定的analyzeCurrentTree被调用');
                    analyzeCurrentTree();
                };
                console.log('analyzeBtn重新绑定成功');
            }
            
            if (clearBtn) {
                clearBtn.onclick = function() {
                    console.log('强制绑定的clearCanvas被调用');
                    clearCanvas();
                };
                console.log('clearBtn重新绑定成功');
            }
            
            // 🔧 强制修复AI模式切换
            if (aiModeToggle) {
                console.log('🔧 强制绑定AI模式切换...');
                console.log('  当前AI状态:', aiStatus);
                
                aiModeToggle.onchange = function() {
                    console.log('🔄 AI模式切换触发!');
                    console.log('  - 切换状态:', this.checked);
                    console.log('  - AI可用性:', aiStatus.ai_enabled);
                    
                    const useAI = this.checked && aiStatus.ai_enabled;
                    console.log('  - 最终模式:', useAI ? 'AI模式' : '模板模式');
                    
                    // 立即更新UI显示
                    const aiModeText = document.getElementById('aiModeText');
                    const generateBtnText = document.getElementById('generateBtnText');
                    const generateBtnIcon = document.getElementById('generateBtnIcon');
                    
                    if (useAI) {
                        aiModeText.textContent = 'AI智能模式';
                        aiModeText.style.color = '#3b82f6';
                        if (generateBtnText) generateBtnText.textContent = 'AI智能生成';
                        if (generateBtnIcon) generateBtnIcon.textContent = '🤖';
                    } else {
                        aiModeText.textContent = '标准模板模式';
                        aiModeText.style.color = '#6b7280';
                        if (generateBtnText) generateBtnText.textContent = '标准模板生成';
                        if (generateBtnIcon) generateBtnIcon.textContent = '📋';
                    }
                    
                    console.log('✅ UI更新完成');
                };
                
                // 触发初始状态设置
                const event = new Event('change');
                aiModeToggle.dispatchEvent(event);
                
                console.log('✅ AI模式切换强制绑定完成');
            } else {
                console.error('❌ 找不到aiModeToggle元素');
            }
        }, 1500);
        
        // 展示中医决策树示例
        function showTCMExample() {
            // 清空当前画布
            clearCanvas();
            
            // 设置疾病名称
            document.getElementById('diseaseName').value = '失眠症';
            
            // 创建示例决策树
            const exampleNodes = [
                // 主流程
                { id: 'ex1', type: 'disease', name: '失眠症', description: '不寐病，睡眠障碍', x: 50, y: 300 },
                { id: 'ex2', type: 'four_diagnosis', name: '四诊信息收集', description: '望：面色晦暗、舌红苔薄\n闻：语声低微\n问：入睡困难、多梦易醒\n切：脉细数', x: 300, y: 300 },
                { id: 'ex3', type: 'symptom', name: '主症分析', description: '主症：入睡困难、易醒\n兼症：心烦、口干、头晕', x: 550, y: 300 },
                { id: 'ex4', type: 'pathogenesis', name: '病因病机', description: '思虑过度，暗耗阴血\n心肾不交，虚火上炎', x: 800, y: 300 },
                { id: 'ex5', type: 'syndrome', name: '证候判断', description: '综合四诊，辨证分型', x: 1050, y: 300 },
                
                // 证型分支
                { id: 'ex5a', type: 'syndrome', name: '心肾不交证', description: '心烦不寐，心悸健忘\n头晕耳鸣，腰膝酸软', x: 1300, y: 200 },
                { id: 'ex5b', type: 'syndrome', name: '阴虚火旺证', description: '虚烦不眠，五心烦热\n口干咽燥，舌红少苔', x: 1300, y: 400 },
                
                // 心肾不交证的治疗
                { id: 'ex6a', type: 'principle', name: '滋阴降火', description: '交通心肾，宁心安神', x: 1550, y: 200 },
                { id: 'ex7a', type: 'prescription', name: '交泰丸加减', description: '黄连6g 肉桂3g\n酸枣仁15g 龙骨30g', x: 1800, y: 200 },
                
                // 阴虚火旺证的治疗
                { id: 'ex6b', type: 'principle', name: '滋阴清热', description: '养阴清热，宁心安神', x: 1550, y: 400 },
                { id: 'ex7b', type: 'prescription', name: '黄连阿胶汤', description: '黄连9g 阿胶9g\n黄芩6g 白芍12g\n鸡子黄2枚', x: 1800, y: 400 }
            ];
            
            // 创建连接关系
            const exampleConnections = [
                { from: 'ex1', to: 'ex2' },
                { from: 'ex2', to: 'ex3' },
                { from: 'ex3', to: 'ex4' },
                { from: 'ex4', to: 'ex5' },
                { from: 'ex5', to: 'ex5a' },
                { from: 'ex5', to: 'ex5b' },
                { from: 'ex5a', to: 'ex6a' },
                { from: 'ex6a', to: 'ex7a' },
                { from: 'ex5b', to: 'ex6b' },
                { from: 'ex6b', to: 'ex7b' }
            ];
            
            // 添加节点
            exampleNodes.forEach(node => {
                nodes.push(node);
                renderNode(node);
            });
            
            // 添加连接
            connections = exampleConnections;
            
            // 绘制连接线
            setTimeout(() => {
                drawConnections();
                showResult('成功', '✅ 已加载失眠症的中医诊疗决策树示例', 'success');
            }, 100);
        }
    </script>
</body>
</html>