# TCM-AI 认证系统统一方案

## 📊 现状分析

### 当前三套认证系统

#### 1️⃣ RBAC系统 (core/security/rbac_system.py)
**数据表**: `user_sessions`
- **使用量**: 14,673个匿名会话 + 15个医生会话 + 12个患者会话
- **特点**:
  - 完整的RBAC权限管理
  - 支持角色枚举: ANONYMOUS, PATIENT, DOCTOR, ADMIN, SUPERADMIN
  - 内存+数据库双层会话管理
  - 完善的权限检查机制
- **问题**: **主要被匿名用户使用,实际登录用户很少**

#### 2️⃣ 统一认证系统 (v2.5新增)
**数据表**: `unified_users` + `unified_sessions` + `user_roles_new`
- **使用量**: 101个用户, 9个活跃会话, 111个角色分配
- **特点**:
  - 完整的用户生命周期管理
  - 设备管理、安全等级、双因素认证
  - 多设备会话追踪
  - 规范的用户-角色-权限模型
- **问题**: **与RBAC系统和医生JWT系统不互通**

#### 3️⃣ 医生JWT系统 (core/doctor_management/doctor_auth.py)
**数据表**: `doctors`
- **使用量**: 16个医生记录, 只有1个有JWT token
- **特点**:
  - 独立的JWT认证
  - 医生专属字段(执业证号、医院、专业)
  - 简单的token生成和验证
- **问题**: **完全独立,不与其他系统互通**

### 🔴 核心问题

1. **数据冗余**: 同一个医生可能在三个表中都有记录
2. **认证混乱**: 不同API使用不同的认证机制
3. **维护困难**: 修改认证逻辑需要改三个地方
4. **安全隐患**: 认证逻辑不统一,容易出现漏洞
5. **功能缺失**: 医生JWT系统缺少设备管理、安全审计等功能

---

## ✅ 统一认证系统设计方案

### 架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                    统一认证系统架构                           │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────┐      ┌──────────────┐     ┌──────────────┐ │
│  │ 用户管理层   │      │  会话管理层   │     │  权限控制层   │ │
│  │             │      │              │     │              │ │
│  │ unified_    │─────▶│ unified_     │────▶│ user_roles_  │ │
│  │ users       │      │ sessions     │     │ new          │ │
│  │             │      │              │     │              │ │
│  │ - 患者      │      │ - 多设备     │     │ - PATIENT    │ │
│  │ - 医生      │      │ - 会话追踪   │     │ - DOCTOR     │ │
│  │ - 管理员    │      │ - 安全审计   │     │ - ADMIN      │ │
│  │ - 访客      │      │              │     │ - ANONYMOUS  │ │
│  └─────────────┘      └──────────────┘     └──────────────┘ │
│                                                               │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │             扩展信息表(通过user_id关联)                  │ │
│  ├─────────────────────────────────────────────────────────┤ │
│  │  doctors (医生专属)  │  patients (患者专属)              │ │
│  │  - 执业证号          │  - 病历号                         │ │
│  │  - 医院科室          │  - 健康档案                       │ │
│  │  - 专业职称          │  - 过敏史                         │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 核心设计原则

1. **统一身份**: 所有用户在`unified_users`表中有唯一记录
2. **角色分离**: 角色信息存储在`user_roles_new`表
3. **扩展灵活**: 医生、患者特有信息存储在各自扩展表
4. **单点认证**: 统一使用`unified_sessions`管理所有会话
5. **向下兼容**: 保留旧表,逐步迁移

---

## 🗄️ 数据库结构调整

### 1. 核心表保持不变

- ✅ `unified_users` - 已经很完善
- ✅ `unified_sessions` - 已支持多设备
- ✅ `user_roles_new` - 已有完整的角色管理

### 2. 扩展表改造

#### doctors表改造
```sql
ALTER TABLE doctors ADD COLUMN user_id VARCHAR(50);  -- 关联到unified_users
CREATE INDEX idx_doctors_user_id ON doctors(user_id);

-- 保留医生专属字段:
-- license_no, hospital, speciality, specialties
-- average_rating, total_reviews, consultation_count
-- commission_rate, available_hours, introduction, avatar_url

-- 废弃字段(迁移到unified_users):
-- auth_token → unified_sessions.session_id
-- password_hash → unified_users.password_hash
```

#### 新增patients表(患者扩展信息)
```sql
CREATE TABLE IF NOT EXISTS patients (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id VARCHAR(50) UNIQUE NOT NULL,  -- 关联unified_users
    patient_no VARCHAR(50) UNIQUE,        -- 病历号
    id_card VARCHAR(20),                  -- 身份证(脱敏)
    gender VARCHAR(10),                   -- 性别
    birth_date DATE,                      -- 出生日期
    blood_type VARCHAR(10),               -- 血型
    allergy_history TEXT,                 -- 过敏史
    family_history TEXT,                  -- 家族病史
    medical_records TEXT,                 -- 病历摘要
    emergency_contact VARCHAR(100),       -- 紧急联系人
    emergency_phone VARCHAR(20),          -- 紧急联系电话
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES unified_users(global_user_id)
);
```

### 3. 数据迁移映射

```sql
-- 医生数据迁移示例
-- 1. 在unified_users中创建医生账户
-- 2. 在user_roles_new中分配DOCTOR角色
-- 3. 在doctors表中关联user_id
-- 4. 医生登录时创建unified_sessions记录

-- 患者数据迁移示例
-- 1. 在unified_users中创建患者账户
-- 2. 在user_roles_new中分配PATIENT角色
-- 3. 在patients表中存储健康档案
```

---

## 🔧 代码改造方案

### 1. 统一认证服务 (新建)

```python
# core/security/unified_auth_service.py

class UnifiedAuthService:
    """统一认证服务 - 整合三套系统"""

    def __init__(self):
        self.db_path = "/opt/tcm-ai/data/user_history.sqlite"
        self.session_manager = UnifiedSessionManager()
        self.role_manager = UnifiedRoleManager()

    async def login(
        self,
        username: str,
        password: str,
        login_method: str = "password",
        device_info: Dict = None
    ) -> Dict[str, Any]:
        """
        统一登录入口 - 支持所有用户类型

        Returns:
            {
                "success": bool,
                "user": UserInfo,
                "session_token": str,
                "roles": List[str],
                "permissions": List[str]
            }
        """
        # 1. 从unified_users验证密码
        user = self._verify_credentials(username, password)
        if not user:
            return {"success": False, "error": "用户名或密码错误"}

        # 2. 获取用户角色
        roles = self.role_manager.get_user_roles(user['global_user_id'])

        # 3. 创建会话
        session = self.session_manager.create_session(
            user_id=user['global_user_id'],
            roles=roles,
            device_info=device_info,
            login_method=login_method
        )

        # 4. 加载角色专属信息
        profile = await self._load_role_profile(user['global_user_id'], roles)

        return {
            "success": True,
            "user": user,
            "profile": profile,  # 医生→doctors表, 患者→patients表
            "session_token": session.session_id,
            "roles": [r.role_name for r in roles],
            "permissions": self._get_permissions(roles)
        }

    async def verify_session(
        self,
        session_token: str,
        request: Request
    ) -> Optional[UserSession]:
        """
        统一会话验证 - 替代三套系统的验证逻辑

        Returns:
            UserSession对象(含用户信息、角色、权限)
        """
        # 1. 从unified_sessions验证
        session = self.session_manager.get_session(session_token)
        if not session or session.is_expired():
            return None

        # 2. 更新最后活动时间
        self.session_manager.update_activity(session_token)

        # 3. 返回完整用户会话信息
        return session

    async def _load_role_profile(self, user_id: str, roles: List) -> Dict:
        """加载角色专属信息"""
        profile = {}

        for role in roles:
            if role.role_name == 'DOCTOR':
                # 从doctors表加载医生信息
                profile['doctor'] = self._get_doctor_info(user_id)
            elif role.role_name == 'PATIENT':
                # 从patients表加载患者信息
                profile['patient'] = self._get_patient_info(user_id)

        return profile
```

### 2. FastAPI依赖注入改造

```python
# api/dependencies.py

from core.security.unified_auth_service import UnifiedAuthService

unified_auth = UnifiedAuthService()

async def get_current_user(
    request: Request,
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(HTTPBearer(auto_error=False))
) -> UserSession:
    """
    统一的用户认证依赖 - 替代所有旧的认证函数

    兼容性:
    - 支持旧的RBAC token
    - 支持医生JWT token
    - 支持unified_sessions token
    """
    # 1. 提取token
    token = None
    if credentials:
        token = credentials.credentials
    elif 'Authorization' in request.headers:
        token = request.headers['Authorization'].replace('Bearer ', '')
    elif 'session_token' in request.cookies:
        token = request.cookies['session_token']

    # 2. 统一验证
    user_session = await unified_auth.verify_session(token, request)

    if not user_session:
        # 3. 兼容模式: 尝试旧系统验证
        user_session = await _legacy_auth_fallback(token, request)

    if not user_session:
        raise HTTPException(status_code=401, detail="未登录或会话已过期")

    return user_session

# 角色权限装饰器
def require_roles(*roles: str):
    """要求特定角色"""
    async def dependency(user: UserSession = Depends(get_current_user)):
        if not any(r in user.roles for r in roles):
            raise HTTPException(
                status_code=403,
                detail=f"需要以下角色之一: {', '.join(roles)}"
            )
        return user
    return dependency

# 使用示例
@router.get("/doctor/patients")
async def get_doctor_patients(
    current_user: UserSession = Depends(require_roles('DOCTOR', 'ADMIN'))
):
    """获取医生的患者列表 - 需要DOCTOR或ADMIN角色"""
    ...
```

### 3. 旧API兼容层

```python
# api/legacy_compat.py

async def _legacy_auth_fallback(token: str, request: Request) -> Optional[UserSession]:
    """
    兼容旧系统的认证 - 逐步废弃

    支持:
    1. 旧的user_sessions表token
    2. 医生JWT token
    3. 其他遗留token
    """
    # 尝试1: RBAC user_sessions
    session = await _try_rbac_session(token)
    if session:
        # 迁移到新系统
        await _migrate_to_unified_session(session)
        return session

    # 尝试2: 医生JWT
    doctor = await _try_doctor_jwt(token)
    if doctor:
        # 迁移到新系统
        await _migrate_doctor_to_unified(doctor, token)
        return _create_doctor_session(doctor)

    return None
```

---

## 📋 迁移实施计划

### 阶段1: 准备阶段 (1-2天)
- [ ] 创建数据库迁移脚本
- [ ] 备份现有数据
- [ ] 添加doctors.user_id字段
- [ ] 创建patients扩展表
- [ ] 编写数据迁移工具

### 阶段2: 核心实现 (2-3天)
- [ ] 实现UnifiedAuthService
- [ ] 实现统一的get_current_user依赖
- [ ] 实现兼容层(支持旧token)
- [ ] 编写单元测试

### 阶段3: API改造 (3-5天)
- [ ] 改造登录API (支持新旧两种方式)
- [ ] 改造医生端API (使用新认证)
- [ ] 改造患者端API (使用新认证)
- [ ] 改造管理端API (使用新认证)
- [ ] 逐个测试API端点

### 阶段4: 前端改造 (2-3天)
- [ ] 统一前端认证流程
- [ ] 统一localStorage存储格式
- [ ] 统一token传递方式
- [ ] 测试所有登录流程

### 阶段5: 数据迁移 (1天)
- [ ] 迁移现有医生账户到unified_users
- [ ] 迁移现有患者账户到unified_users
- [ ] 验证数据完整性
- [ ] 清理冗余数据

### 阶段6: 清理废弃代码 (1-2天)
- [ ] 移除RBAC独立认证逻辑
- [ ] 移除医生JWT独立认证
- [ ] 移除兼容层代码
- [ ] 删除废弃表(可选)
- [ ] 更新文档

---

## 🎯 最终效果

### 统一后的认证流程

```
用户登录
  ↓
验证unified_users表
  ↓
查询user_roles_new获取角色
  ↓
创建unified_sessions会话
  ↓
根据角色加载扩展信息
  ├─ DOCTOR → doctors表
  ├─ PATIENT → patients表
  └─ ADMIN → 管理员配置
  ↓
返回session_token
  ↓
所有API使用统一的get_current_user验证
  ↓
基于角色和权限控制访问
```

### 优势

✅ **单一数据源**: 所有用户信息在unified_users中统一管理
✅ **灵活扩展**: 通过角色和扩展表支持各类用户
✅ **统一认证**: 一套代码处理所有认证逻辑
✅ **安全增强**: 统一的安全审计和会话管理
✅ **易于维护**: 修改认证逻辑只需改一处
✅ **向下兼容**: 保留兼容层支持旧系统

---

## 📊 工作量评估

- **总工作量**: 10-15天
- **风险等级**: 中等(有兼容层保护)
- **优先级**: 高(解决根本架构问题)
- **建议时间**: 安排在功能开发空档期

---

## 🚨 注意事项

1. **分步实施**: 不要一次性切换,保持兼容层
2. **充分测试**: 每个阶段都要完整测试
3. **数据备份**: 迁移前必须完整备份
4. **灰度发布**: 先在测试环境验证,再上生产
5. **监控日志**: 密切关注错误日志和性能

---

## 💡 后续优化方向

1. **OAuth集成**: 支持微信、支付宝等第三方登录
2. **单点登录**: 实现跨子系统的SSO
3. **权限细化**: 从角色级细化到功能级权限
4. **安全增强**: 增加设备指纹、异常检测
5. **性能优化**: session缓存、连接池优化

---

**结论**: 统一认证系统是架构优化的关键一步,虽然需要一定工作量,但能从根本上解决当前的混乱状态,大幅提升系统的可维护性和安全性。建议尽快启动此项重构工作。
