# 统一认证系统使用指南

## 🎉 已完成的工作

### ✅ 阶段1-4: 核心系统实现 (已完成)

1. **数据库结构**:
   - ✅ `doctors`表添加`user_id`字段
   - ✅ 创建`patients`扩展表
   - ✅ 数据库备份完成

2. **核心服务**:
   - ✅ `UnifiedAuthService` - 统一认证服务
   - ✅ 统一登录/登出/会话管理
   - ✅ 角色权限控制

3. **API接口**:
   - ✅ `/api/auth/login` - 统一登录
   - ✅ `/api/auth/logout` - 统一登出
   - ✅ `/api/auth/session` - 会话信息
   - ✅ `/api/auth/me` - 用户信息
   - ✅ `/api/auth/doctor/current` - 兼容旧API

4. **依赖注入**:
   - ✅ `get_current_user` - 统一认证依赖
   - ✅ `require_roles` - 角色控制
   - ✅ `require_doctor/patient/admin` - 便捷角色依赖
   - ✅ 向下兼容旧系统token

---

## 📋 后续步骤

### 步骤5: 数据迁移 (需要执行)

#### 5.1 迁移现有医生账户

目前张仲景已迁移,但需要设置密码:

```bash
# 为张仲景设置密码
python3 << 'EOF'
import sqlite3
import hashlib
import secrets

# 生成密码哈希
password = "zhang123"  # 临时密码
salt = secrets.token_hex(16)
password_hash = hashlib.pbkdf2_hmac('sha256', password.encode(), salt.encode(), 100000).hex()

# 更新密码
conn = sqlite3.connect("/opt/tcm-ai/data/user_history.sqlite")
cursor = conn.cursor()

cursor.execute("""
    UPDATE unified_users
    SET password_hash = ?, salt = ?
    WHERE username = 'TCM-ZZJ-001'
""", (password_hash, salt))

conn.commit()
print(f"✅ 张仲景密码已设置: zhang123")
print(f"   Username: TCM-ZZJ-001")
print(f"   Salt: {salt}")
conn.close()
EOF
```

#### 5.2 迁移其他医生

```bash
# 批量迁移所有active医生
sqlite3 /opt/tcm-ai/data/user_history.sqlite << 'EOF'
-- 迁移剩余医生
INSERT OR IGNORE INTO unified_users (
    global_user_id, username, display_name, password_hash, salt,
    account_status, security_level, registration_source
)
SELECT
    'usr_doctor_' || id,
    license_no,
    name,
    '临时密码需重置',
    hex(randomblob(16)),
    'active',
    'verified',
    'doctor_migration'
FROM doctors
WHERE status = 'active'
AND id NOT IN (
    SELECT CAST(REPLACE(global_user_id, 'usr_doctor_', '') AS INTEGER)
    FROM unified_users
    WHERE global_user_id LIKE 'usr_doctor_%'
);

-- 分配DOCTOR角色
INSERT OR IGNORE INTO user_roles_new (
    user_id, role_name, is_primary, assigned_by, assigned_reason
)
SELECT
    'usr_doctor_' || d.id,
    'DOCTOR',
    1,
    'system',
    '医生数据迁移'
FROM doctors d
WHERE d.status = 'active'
AND NOT EXISTS (
    SELECT 1 FROM user_roles_new ur
    WHERE ur.user_id = 'usr_doctor_' || d.id
);

-- 关联user_id
UPDATE doctors
SET user_id = 'usr_doctor_' || id
WHERE status = 'active' AND user_id IS NULL;

-- 查看结果
SELECT COUNT(*) as migrated_doctors FROM unified_users WHERE global_user_id LIKE 'usr_doctor_%';
SELECT COUNT(*) as doctor_roles FROM user_roles_new WHERE role_name = 'DOCTOR';
EOF
```

### 步骤6: 测试统一认证

#### 6.1 测试登录

```bash
# 1. 张仲景医生登录
curl -X POST "http://localhost:8000/api/auth/login" \
  -H "Content-Type: application/json" \
  -d '{
    "username": "TCM-ZZJ-001",
    "password": "zhang123"
  }' | python3 -m json.tool

# 期望输出:
# {
#   "success": true,
#   "session_token": "xxx",
#   "user": {...},
#   "roles": ["DOCTOR"],
#   "profile": {"doctor": {...}}
# }
```

#### 6.2 测试会话验证

```bash
# 使用登录返回的session_token
TOKEN="<session_token>"

curl -X GET "http://localhost:8000/api/auth/me" \
  -H "Authorization: Bearer $TOKEN" | python3 -m json.tool
```

#### 6.3 测试兼容性API

```bash
# 旧的医生端API应该继续工作
curl -X GET "http://localhost:8000/api/doctor/current" \
  -H "Authorization: Bearer $TOKEN" | python3 -m json.tool
```

---

## 🔧 前端改造指南

### 方案A: 新页面使用新API (推荐)

```javascript
// 统一登录
async function login(username, password) {
    const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            username: username,
            password: password,
            login_method: 'password'
        })
    });

    const result = await response.json();

    if (result.success) {
        // 保存token
        localStorage.setItem('session_token', result.session_token);
        localStorage.setItem('user', JSON.stringify(result.user));
        localStorage.setItem('roles', JSON.stringify(result.roles));

        return result;
    } else {
        throw new Error(result.message);
    }
}

// 统一认证请求
async function authenticatedRequest(url, options = {}) {
    const token = localStorage.getItem('session_token');

    const response = await fetch(url, {
        ...options,
        headers: {
            ...options.headers,
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
        }
    });

    return response;
}

// 获取当前用户信息
async function getCurrentUser() {
    const response = await authenticatedRequest('/api/auth/me');
    const result = await response.json();
    return result.user;
}

// 登出
async function logout() {
    await authenticatedRequest('/api/auth/logout', {method: 'POST'});
    localStorage.clear();
    window.location.href = '/login';
}
```

### 方案B: 兼容旧代码

旧的 `/api/doctor/current` 已经自动兼容新认证系统,无需修改前端代码。

---

## 📊 系统状态检查

### 检查迁移状态

```bash
sqlite3 /opt/tcm-ai/data/user_history.sqlite << 'EOF'
-- 统计迁移情况
SELECT '=== 统一用户表 ===' as section;
SELECT
    COUNT(*) as total_users,
    COUNT(CASE WHEN global_user_id LIKE 'usr_doctor_%' THEN 1 END) as doctors,
    COUNT(CASE WHEN global_user_id LIKE 'usr_patient_%' THEN 1 END) as patients
FROM unified_users;

SELECT '=== 角色分配 ===' as section;
SELECT
    role_name,
    COUNT(*) as count
FROM user_roles_new
WHERE is_active = 1
GROUP BY role_name;

SELECT '=== 医生关联状态 ===' as section;
SELECT
    COUNT(*) as total_doctors,
    COUNT(user_id) as linked_doctors,
    COUNT(*) - COUNT(user_id) as unlinked_doctors
FROM doctors
WHERE status = 'active';

SELECT '=== 活跃会话 ===' as section;
SELECT
    COUNT(*) as active_sessions
FROM unified_sessions
WHERE session_status = 'active'
AND expires_at > datetime('now');
EOF
```

---

## 🎯 使用新系统的优势

### 1. 统一入口
- 所有用户类型使用同一套登录API
- 不再需要区分医生登录、患者登录

### 2. 安全增强
- 统一的会话管理和过期控制
- 完整的安全审计日志
- 设备管理和异常检测

### 3. 权限灵活
- 基于角色的访问控制
- 一个用户可以有多个角色
- 临时角色和权限委派

### 4. 易于扩展
- 新增用户类型只需添加角色
- 扩展信息存储在专属表中
- 不影响核心认证逻辑

### 5. 向下兼容
- 旧的token继续有效
- 兼容层自动转换
- 逐步迁移,无需一次性切换

---

## ❓ 常见问题

### Q: 旧的医生JWT token还能用吗?
**A**: 能!兼容层会自动转换为新的UserSession对象。但建议逐步迁移到新系统。

### Q: 患者如何登录?
**A**: 使用 `/api/auth/login`,用户名可以是手机号、邮箱或用户名。

### Q: 如何给用户分配多个角色?
**A**: 在 `user_roles_new` 表插入多条记录,设置不同的 `role_name`。

### Q: 密码如何重置?
**A**: 目前需要数据库操作。后续可实现 `/api/auth/reset-password` 接口。

### Q: 兼容层什么时候可以移除?
**A**: 等所有前端代码迁移到新API,并且所有用户重新登录一次后。

---

## 📝 下一步开发建议

1. **密码重置功能**
   - 实现 `/api/auth/forgot-password`
   - 邮箱/短信验证码

2. **注册功能**
   - 实现 `/api/auth/register`
   - 患者自助注册
   - 医生注册审核

3. **多设备管理**
   - 查看所有登录设备
   - 远程登出其他设备

4. **OAuth集成**
   - 微信登录
   - 支付宝登录

5. **权限细化**
   - 从角色级细化到功能级
   - 实现权限检查装饰器

6. **监控和审计**
   - 登录失败告警
   - 异常登录检测
   - 完整审计日志

---

**恭喜!统一认证系统核心功能已完成 🎉**

现在你的系统有了一个统一、安全、灵活的认证基础。
